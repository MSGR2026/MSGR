{
  "id": "Informer_2020",
  "paper_title": "Informer: Beyond Efficient Transformer for Long Sequence Time-Series Forecasting",
  "alias": "Informer",
  "year": 2020,
  "domain": "TimeSeries",
  "task": "anomaly_detection",
  "idea": "Informer introduces three key innovations for long sequence time-series forecasting (LSTF): (1) ProbSparse self-attention mechanism that selects dominant queries based on sparsity measurement, reducing complexity from O(L²) to O(L log L); (2) Self-attention distilling operation in the encoder that progressively reduces the time dimension using 1-D convolution and max-pooling, achieving O((2-ε)L log L) memory usage; (3) Generative style decoder that predicts long sequences in one forward pass using start tokens instead of autoregressive dynamic decoding, avoiding error accumulation.",
  "introduction": "# 1 Introduction\n\nTime-series forecasting is a critical ingredient across many domains, such as sensor network monitoring (Papadimitriou and Yu 2006), energy and smart grid management, economics and finance (Zhu and Shasha 2002), and disease propagation analysis (Matsubara et al. 2014). In these scenarios, we can leverage a substantial amount of time-series data on past behavior to make a forecast in the long run, namely long sequence time-series forecasting (LSTF). However, existing methods are mostly designed under short-term problem setting, like predicting 48 points or less (Hochreiter and Schmidhuber 1997; Li et al. 2018; Yu et al. 2017; Liu et al. 2019; Qin et al. 2017; Wen et al. 2017). The increasingly long sequences strain the models' prediction capacity to the point where this trend is holding the research on LSTF. As an empirical example, Fig.(1) shows the forecasting results on a real dataset, where the LSTM network predicts the\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-11-26/b330edeb-c0f6-4c52-ae80-35aa5b05ddd9/50a245e624e6716f45105f6b9b8a38f4c739565db85a9774e8a7128261c4fe41.jpg)  \n(a) Sequence Forecasting.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-11-26/b330edeb-c0f6-4c52-ae80-35aa5b05ddd9/5ffc0f9014b5d07fcae76647b6b088f2a43c2dd27ad3add21fe071df68e52ef0.jpg)  \n(b) Run LSTM on sequences.  \nFigure 1: (a) LSTF can cover an extended period than the short sequence predictions, making vital distinction in policy-planning and investment-protecting. (b) The prediction capacity of existing methods limits LSTF's performance. E.g., starting from length  $= 48$ , MSE rises unacceptably high, and the inference speed drops rapidly.\n\nhourly temperature of an electrical transformer station from the short-term period (12 points, 0.5 days) to the long-term period (480 points, 20 days). The overall performance gap is substantial when the prediction length is greater than 48 points (the solid star in Fig.(1b)), where the MSE rises to unsatisfactory performance, the inference speed gets sharp drop, and the LSTM model starts to fail.\n\nThe major challenge for LSTF is to enhance the prediction capacity to meet the increasingly long sequence demand, which requires (a) extraordinary long-range alignment ability and (b) efficient operations on long sequence inputs and outputs. Recently, Transformer models have shown superior performance in capturing long-range dependency than RNN models. The self-attention mechanism can reduce the maximum length of network signals traveling paths into the theoretical shortest  $\\mathcal{O}(1)$  and avoid the recurrent structure, whereby Transformer shows great potential for the LSTF problem. Nevertheless, the self-attention mechanism violates requirement (b) due to its  $L$ -quadratic computation and memory consumption on  $L$ -length inputs/outputs. Some large-scale Transformer models pour resources and yield impressive results on NLP tasks (Brown et al. 2020), but the training on dozens of GPUs and expensive deploying cost make theses models unaffordable on real-world LSTF problems. The efficiency of the self-attention mechanism and Transformer architecture becomes the bottleneck of applying them to LSTF problems. Thus, in this paper, we seek to answer the question: can we improve Transformer models to\n\nbe computation, memory, and architecture efficient, as well as maintaining higher prediction capacity?\n\nVanilla Transformer (Vaswani et al. 2017) has three significant limitations when solving the LSTF problem:\n\n1. The quadratic computation of self-attention. The atom operation of self-attention mechanism, namely canonical dot-product, causes the time complexity and memory usage per layer to be  $\\mathcal{O}(L^2)$ .  \n2. The memory bottleneck in stacking layers for long inputs. The stack of  $J$  encoder/decoder layers makes total memory usage to be  $\\mathcal{O}(J \\cdot L^2)$ , which limits the model scalability in receiving long sequence inputs.  \n3. The speed plunge in predicting long outputs. Dynamic decoding of vanilla Transformer makes the step-by-step inference as slow as RNN-based model (Fig.(1b)).\n\nThere are some prior works on improving the efficiency of self-attention. The Sparse Transformer (Child et al. 2019), LogSparse Transformer (Li et al. 2019), and Longformer (Beltagy, Peters, and Cohan 2020) all use a heuristic method to tackle limitation 1 and reduce the complexity of self-attention mechanism to  $\\mathcal{O}(L\\log L)$ , where their efficiency gain is limited (Qiu et al. 2019). Reformer (Kitaev, Kaiser, and Levskaya 2019) also achieves  $\\mathcal{O}(L\\log L)$  with locally-sensitive hashing self-attention, but it only works on extremely long sequences. More recently, Linformer (Wang et al. 2020) claims a linear complexity  $\\mathcal{O}(L)$ , but the project matrix can not be fixed for real-world long sequence input, which may have the risk of degradation to  $\\mathcal{O}(L^2)$ . Transformer-XL (Dai et al. 2019) and Compressive Transformer (Rae et al. 2019) use auxiliary hidden states to capture long-range dependency, which could amplify limitation 1 and be adverse to break the efficiency bottleneck. All these works mainly focus on limitation 1, and the limitation 2&3 remains unsolved in the LSTF problem. To enhance the prediction capacity, we tackle all these limitations and achieve improvement beyond efficiency in the proposed Informer.\n\nTo this end, our work delves explicitly into these three issues. We investigate the sparsity in the self-attention mechanism, make improvements of network components, and conduct extensive experiments. The contributions of this paper are summarized as follows:\n\n- We propose Informer to successfully enhance the prediction capacity in the LSTF problem, which validates the Transformer-like model's potential value to capture individual long-range dependency between long sequence time-series outputs and inputs.  \n- We propose ProbSparse self-attention mechanism to efficiently replace the canonical self-attention. It achieves the  $\\mathcal{O}(L\\log L)$  time complexity and  $\\mathcal{O}(L\\log L)$  memory usage on dependency alignments.  \n- We propose self-attention distilling operation to privilege dominating attention scores in  $J$ -stacking layers and sharply reduce the total space complexity to be  $\\mathcal{O}((2 - \\epsilon)L\\log L)$ , which helps receiving long sequence input.  \n- We propose generative style decoder to acquire long sequence output with only one forward step needed, simultaneously avoiding cumulative error spreading during the inference phase.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-11-26/b330edeb-c0f6-4c52-ae80-35aa5b05ddd9/2d554c8e5ad638d196f03d187d1de9512e1ec2a9fc383a0ac5264b1482ca7cc4.jpg)  \nFigure 2: Informer model overview. Left: The encoder receives massive long sequence inputs (green series). We replace canonical self-attention with the proposed ProbSparse self-attention. The blue trapezoid is the self-attention distilling operation to extract dominating attention, reducing the network size sharply. The layer stacking replicas increase robustness. Right: The decoder receives long sequence inputs, pads the target elements into zero, measures the weighted attention composition of the feature map, and instantly predicts output elements (orange series) in a generative style.\n",
  "method": "# 3 Methodology\n\nExisting methods for time-series forecasting can be roughly grouped into two categories<sup>1</sup>. Classical time-series models serve as a reliable workhorse for time-series forecasting (Box et al. 2015; Ray 1990; Seeger et al. 2017; Seeger, Salinas, and Flunkert 2016), and deep learning techniques mainly develop an encoder-decoder prediction paradigm by using RNN and their variants (Hochreiter and Schmidhuber 1997; Li et al. 2018; Yu et al. 2017). Our proposed Informer holds the encoder-decoder architecture while targeting the\n\nLSTF problem. Please refer to Fig.(2) for an overview and the following sections for details.\n\n# Efficient Self-attention Mechanism\n\nThe canonical self-attention in (Vaswani et al. 2017) is defined based on the tuple inputs, i.e., query, key and value, which performs the scaled dot-product as  $\\mathcal{A}(\\mathbf{Q},\\mathbf{K},\\mathbf{V}) =$  Softmax  $(\\mathbf{Q}\\mathbf{K}^{\\top} / \\sqrt{d})\\mathbf{V}$ , where  $\\mathbf{Q}\\in \\mathbb{R}^{L_Q\\times d}$ ,  $\\mathbf{K}\\in \\mathbb{R}^{L_K\\times d}$ ,  $\\mathbf{V}\\in \\mathbb{R}^{L_V\\times d}$  and  $d$  is the input dimension. To further discuss the self-attention mechanism, let  $\\mathbf{q}_i,\\mathbf{k}_i,\\mathbf{v}_i$  stand for the  $i$ -th row in  $\\mathbf{Q}$ ,  $\\mathbf{K}$ ,  $\\mathbf{V}$  respectively. Following the formulation in Tsai et al. 2019), the  $i$ -th query's attention is defined as a kernel smoother in a probability form:\n\n$$\n\\mathcal {A} (\\mathbf {q} _ {i}, \\mathbf {K}, \\mathbf {V}) = \\sum_ {j} \\frac {k (\\mathbf {q} _ {i} , \\mathbf {k} _ {j})}{\\sum_ {l} k (\\mathbf {q} _ {i} , \\mathbf {k} _ {l})} \\mathbf {v} _ {j} = \\mathbb {E} _ {p \\left(\\mathbf {k} _ {j} \\mid \\mathbf {q} _ {i}\\right)} [ \\mathbf {v} _ {j} ], \\tag {1}\n$$\n\nwhere  $p(\\mathbf{k}_j|\\mathbf{q}_i) = k(\\mathbf{q}_i,\\mathbf{k}_j) / \\sum_lk(\\mathbf{q}_i,\\mathbf{k}_l)$  and  $k(\\mathbf{q}_i,\\mathbf{k}_j)$  selects the asymmetric exponential kernel  $\\exp (\\mathbf{q}_i\\mathbf{k}_j^\\top /\\sqrt{d})$  The self-attention combines the values and acquires outputs based on computing the probability  $p(\\mathbf{k}_j|\\mathbf{q}_i)$  . It requires the quadratic times dot-product computation and  $\\mathcal{O}(L_Q L_K)$  memory usage, which is the major drawback when enhancing prediction capacity.\n\nSome previous attempts have revealed that the distribution of self-attention probability has potential sparsity, and they have designed \"selective\" counting strategies on all  $p(\\mathbf{k}_j|\\mathbf{q}_i)$  without significantly affecting the performance. The Sparse Transformer (Child et al. 2019) incorporates both the row outputs and column inputs, in which the sparsity arises from the separated spatial correlation. The LogSparse Transformer (Li et al. 2019) notices the cyclical pattern in self-attention and forces each cell to attend to its previous one by an exponential step size. The Longformer (Beltagy, Peters, and Cohan 2020) extends previous two works to more complicated sparse configuration. However, they are limited to theoretical analysis from following heuristic methods and tackle each multi-head self-attention with the same strategy, which narrows their further improvement.\n\nTo motivate our approach, we first perform a qualitative assessment on the learned attention patterns of the canonical self-attention. The \"sparsity\" self-attention score forms a long tail distribution (see Appendix C for details), i.e., a few dot-product pairs contribute to the major attention, and others generate trivial attention. Then, the next question is how to distinguish them?\n\nQuery Sparsity Measurement From Eq.(1), the  $i$ -th query's attention on all the keys are defined as a probability  $p(\\mathbf{k}_j|\\mathbf{q}_i)$  and the output is its composition with values  $\\mathbf{v}$ . The dominant dot-product pairs encourage the corresponding query's attention probability distribution away from the uniform distribution. If  $p(\\mathbf{k}_j|\\mathbf{q}_i)$  is close to a uniform distribution  $q(\\mathbf{k}_j|\\mathbf{q}_i) = 1 / L_K$ , the self-attention becomes a trivial sum of values  $\\mathbf{V}$  and is redundant to the residential input. Naturally, the \"likeness\" between distribution  $p$  and  $q$  can be used to distinguish the \"important\" queries. We measure the \"likeness\" through Kullback-Leibler divergence\n\n$$\nK L (q | | p) = \\ln \\sum_ {l = 1} ^ {L _ {K}} e ^ {\\mathbf {q} _ {i} \\mathbf {k} _ {l} ^ {\\top} / \\sqrt {d}} - \\frac {1}{L _ {K}} \\sum_ {j = 1} ^ {L _ {K}} \\mathbf {q} _ {i} \\mathbf {k} _ {j} ^ {\\top} / \\sqrt {d} -\n$$\n\n$\\ln L_K$ . Dropping the constant, we define the  $i$ -th query's sparsity measurement as\n\n$$\nM (\\mathbf {q} _ {i}, \\mathbf {K}) = \\ln \\sum_ {j = 1} ^ {L _ {K}} e ^ {\\frac {\\mathbf {q} _ {i} \\mathbf {k} _ {j} ^ {\\top}}{\\sqrt {d}}} - \\frac {1}{L _ {K}} \\sum_ {j = 1} ^ {L _ {K}} \\frac {\\mathbf {q} _ {i} \\mathbf {k} _ {j} ^ {\\top}}{\\sqrt {d}} \\quad , \\tag {2}\n$$\n\nwhere the first term is the Log-Sum-Exp (LSE) of  $\\mathbf{q}_i$  on all the keys, and the second term is the arithmetic mean on them. If the  $i$ -th query gains a larger  $M(\\mathbf{q}_i, \\mathbf{K})$ , its attention probability  $p$  is more \"diverse\" and has a high chance to contain the dominate dot-product pairs in the header field of the long tail self-attention distribution.\n\nProbSparse Self-attention Based on the proposed measurement, we have the ProbSparse self-attention by allowing each key to only attend to the  $u$  dominant queries:\n\n$$\n\\mathcal {A} (\\mathbf {Q}, \\mathbf {K}, \\mathbf {V}) = \\operatorname {S o f t m a x} \\left(\\frac {\\overline {{\\mathbf {Q}}} \\mathbf {K} ^ {\\top}}{\\sqrt {d}}\\right) \\mathbf {V} \\quad , \\tag {3}\n$$\n\nwhere  $\\overline{\\mathbf{Q}}$  is a sparse matrix of the same size of  $\\mathbf{q}$  and it only contains the Top- $u$  queries under the sparsity measurement  $M(\\mathbf{q},\\mathbf{K})$ . Controlled by a constant sampling factor  $c$ , we set  $u = c\\cdot \\ln L_{Q}$ , which makes the ProbSparse self-attention only need to calculate  $\\mathcal{O}(\\ln L_Q)$  dot-product for each query-key lookup and the layer memory usage maintains  $\\mathcal{O}(L_K\\ln L_Q)$ . Under the multi-head perspective, this attention generates different sparse query-key pairs for each head, which avoids severe information loss in return.\n\nHowever, the traversing of all the queries for the measurement  $M(\\mathbf{q}_i,\\mathbf{K})$  requires calculating each dot-product pairs, i.e., quadratically  $\\mathcal{O}(L_Q L_K)$ , besides the LSE operation has the potential numerical stability issue. Motivated by this, we propose an empirical approximation for the efficient acquisition of the query sparsity measurement.\n\nLemma 1. For each query  $\\mathbf{q}_i\\in \\mathbb{R}^d$  and  $\\mathbf{k}_j\\in \\mathbb{R}^d$  in the keys set  $\\mathbf{K}$ , we have the bound as  $\\ln L_K\\leq M(\\mathbf{q}_i,\\mathbf{K})\\leq \\max_j\\{\\mathbf{q}_i\\mathbf{k}_j^\\top /\\sqrt{d}\\} -\\frac{1}{L_K}\\sum_{j = 1}^{L_K}\\{\\mathbf{q}_i\\mathbf{k}_j^\\top /\\sqrt{d}\\} +\\ln L_K$ . When  $\\mathbf{q}_i\\in \\mathbf{K}$ , it also holds.\n\nFrom the Lemma 1 (proof is given in Appendix D.1), we propose the max-mean measurement as\n\n$$\n\\overline {{M}} (\\mathbf {q} _ {i}, \\mathbf {K}) = \\max  _ {j} \\left\\{\\frac {\\mathbf {q} _ {i} \\mathbf {k} _ {j} ^ {\\top}}{\\sqrt {d}} \\right\\} - \\frac {1}{L _ {K}} \\sum_ {j = 1} ^ {L _ {K}} \\frac {\\mathbf {q} _ {i} \\mathbf {k} _ {j} ^ {\\top}}{\\sqrt {d}}. \\tag {4}\n$$\n\nThe range of Top- $u$  approximately holds in the boundary relaxation with Proposition 1 (refers in Appendix D.2). Under the long tail distribution, we only need to randomly sample  $U = L_{K} \\ln L_{Q}$  dot-product pairs to calculate the  $\\overline{M}(\\mathbf{q}_i, \\mathbf{K})$ , i.e., filling other pairs with zero. Then, we select sparse Top- $u$  from them as  $\\overline{\\mathbf{Q}}$ . The max-operator in  $\\overline{M}(\\mathbf{q}_i, \\mathbf{K})$  is less sensitive to zero values and is numerical stable. In practice, the input length of queries and keys are typically equivalent in the self-attention computation, i.e.  $L_{Q} = L_{K} = \\bar{L}$  such that the total ProbSparse self-attention time complexity and space complexity are  $\\mathcal{O}(L \\ln L)$ .\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-11-26/b330edeb-c0f6-4c52-ae80-35aa5b05ddd9/45e99a216ab8e7c7a6fa95d0b85c92ab6c40c50bdee2f811435d5bef5c8a8ece.jpg)  \nFigure 3: The single stack in Informer's encoder. (1) The horizontal stack stands for an individual one of the encoder replicas in Fig.(2). (2) The presented one is the main stack receiving the whole input sequence. Then the second stack takes half slices of the input, and the subsequent stacks repeat. (3) The red layers are dot-product matrixes, and they get cascade decrease by applying self-attention distilling on each layer. (4) Concatenate all stacks' feature maps as the encoder's output.\n\n# Encoder: Allowing for Processing Longer Sequential Inputs under the Memory Usage Limitation\n\nThe encoder is designed to extract the robust long-range dependency of the long sequential inputs. After the input representation, the  $t$ -th sequence input  $\\mathcal{X}^t$  has been shaped into a matrix  $\\mathbf{X}_{\\mathrm{en}}^t \\in \\mathbb{R}^{L_x \\times d_{\\mathrm{model}}}$ . We give a sketch of the encoder in Fig.(3) for clarity.\n\nSelf-attention Distilling As the natural consequence of the ProbSparse self-attention mechanism, the encoder's feature map has redundant combinations of value  $\\mathbf{V}$ . We use the distilling operation to privilege the superior ones with dominating features and make a focused self-attention feature map in the next layer. It trims the input's time dimension sharply, seeing the  $n$ -heads weights matrix (overlapping red squares) of Attention blocks in Fig.(3). Inspired by the dilated convolution (Yu, Koltun, and Funkhouser 2017; Gupta and Rush 2017), our \"distilling\" procedure forwards from  $j$ -th layer into  $(j + 1)$ -th layer as:\n\n$$\n\\mathbf {X} _ {j + 1} ^ {t} = \\operatorname {M a x P o o l} \\left(\\operatorname {E L U} \\left(\\operatorname {C o n v 1 d} \\left([ \\mathbf {X} _ {j} ^ {t} ] _ {\\mathrm {A B}}\\right)\\right)\\right) \\quad , \\tag {5}\n$$\n\nwhere  $[\\cdot]_{\\mathrm{AB}}$  represents the attention block. It contains the Multi-head ProbSparse self-attention and the essential operations, where  $\\mathrm{Conv1d}(\\cdot)$  performs an 1-D convolutional filters (kernel width=3) on time dimension with the  $\\mathrm{ELU}(\\cdot)$  activation function (Clevert, Unterthiner, and Hochreiter 2016). We add a max-pooling layer with stride 2 and down-sample  $\\mathbf{X}^t$  into its half slice after stacking a layer, which reduces the whole memory usage to be  $\\mathcal{O}((2 - \\epsilon)L\\log L)$ , where  $\\epsilon$  is a small number. To enhance the robustness of the distilling operation, we build replicas of the main stack with halving inputs, and progressively decrease the number of self-attention distilling layers by dropping one layer at a time, like a pyramid in Fig.(2), such that their output dimension is aligned. Thus, we concatenate all the stacks' outputs and have the final hidden representation of encoder.\n\n# Decoder: Generating Long Sequential Outputs Through One Forward Procedure\n\nWe use a standard decoder structure (Vaswani et al. 2017) in Fig.(2), and it is composed of a stack of two identical multihead attention layers. However, the generative inference is employed to alleviate the speed plunge in long prediction. We feed the decoder with the following vectors as\n\n$$\n\\mathbf {X} _ {\\mathrm {d e}} ^ {t} = \\operatorname {C o n c a t} \\left(\\mathbf {X} _ {\\text {t o k e n}} ^ {t}, \\mathbf {X} _ {\\mathbf {0}} ^ {t}\\right) \\in \\mathbb {R} ^ {\\left(L _ {\\text {t o k e n}} + L _ {y}\\right) \\times d _ {\\text {m o d e l}}} \\quad , \\tag {6}\n$$\n\nwhere  $\\mathbf{X}_{\\mathrm{token}}^t\\in \\mathbb{R}^{L_{\\mathrm{token}}\\times d_{\\mathrm{model}}}$  is the start token,  $\\mathbf{X}_0^t\\in$ $\\mathbb{R}^{L_y\\times d_{\\mathrm{model}}}$  is a placeholder for the target sequence (set scalar as 0). Masked multi-head attention is applied in the ProbSparse self-attention computing by setting masked dotproducts to  $-\\infty$  . It prevents each position from attending to coming positions, which avoids auto-regressive. A fully connected layer acquires the final output, and its outsize  $d_{y}$  depends on whether we are performing a univariate forecasting or a multivariate one.\n\nGenerative Inference Start token is efficiently applied in NLP's \"dynamic decoding\" (Devlin et al. 2018), and we extend it into a generative way. Instead of choosing specific flags as the token, we sample a  $L_{\\mathrm{token}}$  long sequence in the input sequence, such as an earlier slice before the output sequence. Take predicting 168 points as an example (7-day temperature prediction in the experiment section), we will take the known 5 days before the target sequence as \"start-token\", and feed the generative-style inference decoder with  $\\mathbf{X}_{\\mathrm{de}} = \\{\\mathbf{X}_{5d}, \\mathbf{X}_0\\}$ . The  $\\mathbf{X}_0$  contains target sequence's time stamp, i.e., the context at the target week. Then our proposed decoder predicts outputs by one forward procedure rather than the time consuming \"dynamic decoding\" in the conventional encoder-decoder architecture. A detailed performance comparison is given in the computation efficiency section.\n\nLoss function We choose the MSE loss function on prediction w.r.t the target sequences, and the loss is propagated back from the decoder's outputs across the entire model.\n\n<table><tr><td colspan=\"2\">Methods</td><td colspan=\"2\">Informer</td><td colspan=\"2\">Informer†</td><td colspan=\"2\">LogTrans</td><td colspan=\"2\">Reformer</td><td colspan=\"2\">LSTMMa</td><td colspan=\"2\">DeepAR</td><td colspan=\"2\">ARIMA</td><td colspan=\"2\">Prophet</td></tr><tr><td colspan=\"2\">Metric</td><td>MSE</td><td>MAE</td><td>MSE</td><td>MAE</td><td>MSE</td><td>MAE</td><td>MSE</td><td>MAE</td><td>MSE</td><td>MAE</td><td>MSE</td><td>MAE</td><td>MSE</td><td>MAE</td><td>MSE</td><td>MAE</td></tr><tr><td rowspan=\"5\">ETTh1</td><td>24</td><td>0.098</td><td>0.247</td><td>0.092</td><td>0.246</td><td>0.103</td><td>0.259</td><td>0.222</td><td>0.389</td><td>0.114</td><td>0.272</td><td>0.107</td><td>0.280</td><td>0.108</td><td>0.284</td><td>0.115</td><td>0.275</td></tr><tr><td>48</td><td>0.158</td><td>0.319</td><td>0.161</td><td>0.322</td><td>0.167</td><td>0.328</td><td>0.284</td><td>0.445</td><td>0.193</td><td>0.358</td><td>0.162</td><td>0.327</td><td>0.175</td><td>0.424</td><td>0.168</td><td>0.330</td></tr><tr><td>168</td><td>0.183</td><td>0.346</td><td>0.187</td><td>0.355</td><td>0.207</td><td>0.375</td><td>1.522</td><td>1.191</td><td>0.236</td><td>0.392</td><td>0.239</td><td>0.422</td><td>0.396</td><td>0.504</td><td>1.224</td><td>0.763</td></tr><tr><td>336</td><td>0.222</td><td>0.387</td><td>0.215</td><td>0.369</td><td>0.230</td><td>0.398</td><td>1.860</td><td>1.124</td><td>0.590</td><td>0.698</td><td>0.445</td><td>0.552</td><td>0.468</td><td>0.593</td><td>1.549</td><td>1.820</td></tr><tr><td>720</td><td>0.269</td><td>0.435</td><td>0.257</td><td>0.421</td><td>0.273</td><td>0.463</td><td>2.112</td><td>1.436</td><td>0.683</td><td>0.768</td><td>0.658</td><td>0.707</td><td>0.659</td><td>0.766</td><td>2.735</td><td>3.253</td></tr><tr><td rowspan=\"5\">ETTh2</td><td>24</td><td>0.093</td><td>0.240</td><td>0.099</td><td>0.241</td><td>0.102</td><td>0.255</td><td>0.263</td><td>0.437</td><td>0.155</td><td>0.307</td><td>0.098</td><td>0.263</td><td>3.554</td><td>0.445</td><td>0.199</td><td>0.381</td></tr><tr><td>48</td><td>0.155</td><td>0.314</td><td>0.159</td><td>0.317</td><td>0.169</td><td>0.348</td><td>0.458</td><td>0.545</td><td>0.190</td><td>0.348</td><td>0.163</td><td>0.341</td><td>3.190</td><td>0.474</td><td>0.304</td><td>0.462</td></tr><tr><td>168</td><td>0.232</td><td>0.389</td><td>0.235</td><td>0.390</td><td>0.246</td><td>0.422</td><td>1.029</td><td>0.879</td><td>0.385</td><td>0.514</td><td>0.255</td><td>0.414</td><td>2.800</td><td>0.595</td><td>2.145</td><td>1.068</td></tr><tr><td>336</td><td>0.263</td><td>0.417</td><td>0.258</td><td>0.423</td><td>0.267</td><td>0.437</td><td>1.668</td><td>1.228</td><td>0.558</td><td>0.606</td><td>0.604</td><td>0.607</td><td>2.753</td><td>0.738</td><td>2.096</td><td>2.543</td></tr><tr><td>720</td><td>0.277</td><td>0.431</td><td>0.285</td><td>0.442</td><td>0.303</td><td>0.493</td><td>2.030</td><td>1.721</td><td>0.640</td><td>0.681</td><td>0.429</td><td>0.580</td><td>2.878</td><td>1.044</td><td>3.355</td><td>4.664</td></tr><tr><td rowspan=\"5\">ETTm1</td><td>24</td><td>0.030</td><td>0.137</td><td>0.034</td><td>0.160</td><td>0.065</td><td>0.202</td><td>0.095</td><td>0.228</td><td>0.121</td><td>0.233</td><td>0.091</td><td>0.243</td><td>0.090</td><td>0.206</td><td>0.120</td><td>0.290</td></tr><tr><td>48</td><td>0.069</td><td>0.203</td><td>0.066</td><td>0.194</td><td>0.078</td><td>0.220</td><td>0.249</td><td>0.390</td><td>0.305</td><td>0.411</td><td>0.219</td><td>0.362</td><td>0.179</td><td>0.306</td><td>0.133</td><td>0.305</td></tr><tr><td>96</td><td>0.194</td><td>0.372</td><td>0.187</td><td>0.384</td><td>0.199</td><td>0.386</td><td>0.920</td><td>0.767</td><td>0.287</td><td>0.420</td><td>0.364</td><td>0.496</td><td>0.272</td><td>0.399</td><td>0.194</td><td>0.396</td></tr><tr><td>288</td><td>0.401</td><td>0.554</td><td>0.409</td><td>0.548</td><td>0.411</td><td>0.572</td><td>1.108</td><td>1.245</td><td>0.524</td><td>0.584</td><td>0.948</td><td>0.795</td><td>0.462</td><td>0.558</td><td>0.452</td><td>0.574</td></tr><tr><td>672</td><td>0.512</td><td>0.644</td><td>0.519</td><td>0.665</td><td>0.598</td><td>0.702</td><td>1.793</td><td>1.528</td><td>1.064</td><td>0.873</td><td>2.437</td><td>1.352</td><td>0.639</td><td>0.697</td><td>2.747</td><td>1.174</td></tr><tr><td rowspan=\"5\">Weather</td><td>24</td><td>0.117</td><td>0.251</td><td>0.119</td><td>0.256</td><td>0.136</td><td>0.279</td><td>0.231</td><td>0.401</td><td>0.131</td><td>0.254</td><td>0.128</td><td>0.274</td><td>0.219</td><td>0.355</td><td>0.302</td><td>0.433</td></tr><tr><td>48</td><td>0.178</td><td>0.318</td><td>0.185</td><td>0.316</td><td>0.206</td><td>0.356</td><td>0.328</td><td>0.423</td><td>0.190</td><td>0.334</td><td>0.203</td><td>0.353</td><td>0.273</td><td>0.409</td><td>0.445</td><td>0.536</td></tr><tr><td>168</td><td>0.266</td><td>0.398</td><td>0.269</td><td>0.404</td><td>0.309</td><td>0.439</td><td>0.654</td><td>0.634</td><td>0.341</td><td>0.448</td><td>0.293</td><td>0.451</td><td>0.503</td><td>0.599</td><td>2.441</td><td>1.142</td></tr><tr><td>336</td><td>0.297</td><td>0.416</td><td>0.310</td><td>0.422</td><td>0.359</td><td>0.484</td><td>1.792</td><td>1.093</td><td>0.456</td><td>0.554</td><td>0.585</td><td>0.644</td><td>0.728</td><td>0.730</td><td>1.987</td><td>2.468</td></tr><tr><td>720</td><td>0.359</td><td>0.466</td><td>0.361</td><td>0.471</td><td>0.388</td><td>0.499</td><td>2.087</td><td>1.534</td><td>0.866</td><td>0.809</td><td>0.499</td><td>0.596</td><td>1.062</td><td>0.943</td><td>3.859</td><td>1.144</td></tr><tr><td rowspan=\"5\">ECL</td><td>48</td><td>0.239</td><td>0.359</td><td>0.238</td><td>0.368</td><td>0.280</td><td>0.429</td><td>0.971</td><td>0.884</td><td>0.493</td><td>0.539</td><td>0.204</td><td>0.357</td><td>0.879</td><td>0.764</td><td>0.524</td><td>0.595</td></tr><tr><td>168</td><td>0.447</td><td>0.503</td><td>0.442</td><td>0.514</td><td>0.454</td><td>0.529</td><td>1.671</td><td>1.587</td><td>0.723</td><td>0.655</td><td>0.315</td><td>0.436</td><td>1.032</td><td>0.833</td><td>2.725</td><td>1.273</td></tr><tr><td>336</td><td>0.489</td><td>0.528</td><td>0.501</td><td>0.552</td><td>0.514</td><td>0.563</td><td>3.528</td><td>2.196</td><td>1.212</td><td>0.898</td><td>0.414</td><td>0.519</td><td>1.136</td><td>0.876</td><td>2.246</td><td>3.077</td></tr><tr><td>720</td><td>0.540</td><td>0.571</td><td>0.543</td><td>0.578</td><td>0.558</td><td>0.609</td><td>4.891</td><td>4.047</td><td>1.511</td><td>0.966</td><td>0.563</td><td>0.595</td><td>1.251</td><td>0.933</td><td>4.243</td><td>1.415</td></tr><tr><td>960</td><td>0.582</td><td>0.608</td><td>0.594</td><td>0.638</td><td>0.624</td><td>0.645</td><td>7.019</td><td>5.105</td><td>1.545</td><td>1.006</td><td>0.657</td><td>0.683</td><td>1.370</td><td>0.982</td><td>6.901</td><td>4.264</td></tr><tr><td colspan=\"2\">Count</td><td colspan=\"2\">32</td><td colspan=\"2\">12</td><td colspan=\"2\">0</td><td colspan=\"2\">0</td><td colspan=\"2\">0</td><td colspan=\"2\">6</td><td colspan=\"2\">0</td><td colspan=\"2\">0</td></tr></table>\n\nTable 1: Univariate long sequence time-series forecasting results on four datasets (five cases).\n",
  "experiments": "# 4 Experiment\n\n# Datasets\n\nWe extensively perform experiments on four datasets, including 2 collected real-world datasets for LSTF and 2 public benchmark datasets.\n\nETT (Electricity Transformer Temperature)<sup>2</sup>: The ETT is a crucial indicator in the electric power long-term deployment. We collected 2-year data from two separated counties in China. To explore the granularity on the LSTF problem, we create separate datasets as  $\\{\\mathrm{ETTh}_1, \\mathrm{ETTh}_2\\}$  for 1-hour-level and  $\\mathrm{ETTm}_1$  for 15-minute-level. Each data point consists of the target value \"oil temperature\" and 6 power load features. The train/val/test is 12/4/4 months.\n\nECL (Electricity Consuming Load): It collects the electricity consumption (Kwh) of 321 clients. Due to the missing data (Li et al. 2019), we convert the dataset into hourly consumption of 2 years and set 'MT_320' as the target value. The train/val/test is 15/3/4 months.\n\nWeather<sup>4</sup>: This dataset contains local climatological data for nearly 1,600 U.S. locations, 4 years from 2010 to 2013, where data points are collected every 1 hour. Each data point\n\nconsists of the target value \"wet bulb\" and 11 climate features. The train/val/test is 28/10/10 months.\n\n# Experimental Details\n\nWe briefly summarize basics, and more information on network components and setups are given in Appendix E.\n\nBaselines: We have selected five time-series forecasting methods as comparison, including ARIMA (Ariyo, Adewumi, and Ayo 2014), Prophet (Taylor and Letham 2018), LSTMa (Bahdanau, Cho, and Bengio 2015), LSTM (Lai et al. 2018) and DeepAR (Flunkert, Salinas, and Gasthaus 2017). To better explore the ProbSparse self-attention's performance in our proposed Informer, we incorporate the canonical self-attention variant (Informer†), the efficient variant Reformer (Kitaev, Kaiser, and Levskaya 2019) and the most related work LogSparse self-attention (Li et al. 2019) in the experiments. The details of network components are given in Appendix E.1.\n\nHyper-parameter tuning: We conduct grid search over the hyper-parameters, and detailed ranges are given in Appendix E.3. Informer contains a 3-layer stack and a 1-layer stack (1/4 input) in the encoder, and a 2-layer decoder. Our proposed methods are optimized with Adam optimizer, and its learning rate starts from  $1e^{-4}$ , decaying two times smaller every epoch. The total number of epochs is 8 with proper early stopping. We set the comparison methods as recommended, and the batch size is 32. Setup: The input of each dataset is zero-mean normalized.\n\n<table><tr><td colspan=\"2\">Methods</td><td colspan=\"2\">Informer</td><td colspan=\"2\">Informer†</td><td colspan=\"2\">LogTrans</td><td colspan=\"2\">Reformer</td><td colspan=\"2\">LSTMa</td><td colspan=\"2\">LSTnet</td></tr><tr><td colspan=\"2\">Metric</td><td>MSE</td><td>MAE</td><td>MSE</td><td>MAE</td><td>MSE</td><td>MAE</td><td>MSE</td><td>MAE</td><td>MSE</td><td>MAE</td><td>MSE</td><td>MAE</td></tr><tr><td rowspan=\"5\">ETTh1</td><td>24</td><td>0.577</td><td>0.549</td><td>0.620</td><td>0.577</td><td>0.686</td><td>0.604</td><td>0.991</td><td>0.754</td><td>0.650</td><td>0.624</td><td>1.293</td><td>0.901</td></tr><tr><td>48</td><td>0.685</td><td>0.625</td><td>0.692</td><td>0.671</td><td>0.766</td><td>0.757</td><td>1.313</td><td>0.906</td><td>0.702</td><td>0.675</td><td>1.456</td><td>0.960</td></tr><tr><td>168</td><td>0.931</td><td>0.752</td><td>0.947</td><td>0.797</td><td>1.002</td><td>0.846</td><td>1.824</td><td>1.138</td><td>1.212</td><td>0.867</td><td>1.997</td><td>1.214</td></tr><tr><td>336</td><td>1.128</td><td>0.873</td><td>1.094</td><td>0.813</td><td>1.362</td><td>0.952</td><td>2.117</td><td>1.280</td><td>1.424</td><td>0.994</td><td>2.655</td><td>1.369</td></tr><tr><td>720</td><td>1.215</td><td>0.896</td><td>1.241</td><td>0.917</td><td>1.397</td><td>1.291</td><td>2.415</td><td>1.520</td><td>1.960</td><td>1.322</td><td>2.143</td><td>1.380</td></tr><tr><td rowspan=\"5\">ETTh2</td><td>24</td><td>0.720</td><td>0.665</td><td>0.753</td><td>0.727</td><td>0.828</td><td>0.750</td><td>1.531</td><td>1.613</td><td>1.143</td><td>0.813</td><td>2.742</td><td>1.457</td></tr><tr><td>48</td><td>1.457</td><td>1.001</td><td>1.461</td><td>1.077</td><td>1.806</td><td>1.034</td><td>1.871</td><td>1.735</td><td>1.671</td><td>1.221</td><td>3.567</td><td>1.687</td></tr><tr><td>168</td><td>3.489</td><td>1.515</td><td>3.485</td><td>1.612</td><td>4.070</td><td>1.681</td><td>4.660</td><td>1.846</td><td>4.117</td><td>1.674</td><td>3.242</td><td>2.513</td></tr><tr><td>336</td><td>2.723</td><td>1.340</td><td>2.626</td><td>1.285</td><td>3.875</td><td>1.763</td><td>4.028</td><td>1.688</td><td>3.434</td><td>1.549</td><td>2.544</td><td>2.591</td></tr><tr><td>720</td><td>3.467</td><td>1.473</td><td>3.548</td><td>1.495</td><td>3.913</td><td>1.552</td><td>5.381</td><td>2.015</td><td>3.963</td><td>1.788</td><td>4.625</td><td>3.709</td></tr><tr><td rowspan=\"5\">ETTm1</td><td>24</td><td>0.323</td><td>0.369</td><td>0.306</td><td>0.371</td><td>0.419</td><td>0.412</td><td>0.724</td><td>0.607</td><td>0.621</td><td>0.629</td><td>1.968</td><td>1.170</td></tr><tr><td>48</td><td>0.494</td><td>0.503</td><td>0.465</td><td>0.470</td><td>0.507</td><td>0.583</td><td>1.098</td><td>0.777</td><td>1.392</td><td>0.939</td><td>1.999</td><td>1.215</td></tr><tr><td>96</td><td>0.678</td><td>0.614</td><td>0.681</td><td>0.612</td><td>0.768</td><td>0.792</td><td>1.433</td><td>0.945</td><td>1.339</td><td>0.913</td><td>2.762</td><td>1.542</td></tr><tr><td>288</td><td>1.056</td><td>0.786</td><td>1.162</td><td>0.879</td><td>1.462</td><td>1.320</td><td>1.820</td><td>1.094</td><td>1.740</td><td>1.124</td><td>1.257</td><td>2.076</td></tr><tr><td>672</td><td>1.192</td><td>0.926</td><td>1.231</td><td>1.103</td><td>1.669</td><td>1.461</td><td>2.187</td><td>1.232</td><td>2.736</td><td>1.555</td><td>1.917</td><td>2.941</td></tr><tr><td rowspan=\"5\">Weather</td><td>24</td><td>0.335</td><td>0.381</td><td>0.349</td><td>0.397</td><td>0.435</td><td>0.477</td><td>0.655</td><td>0.583</td><td>0.546</td><td>0.570</td><td>0.615</td><td>0.545</td></tr><tr><td>48</td><td>0.395</td><td>0.459</td><td>0.386</td><td>0.433</td><td>0.426</td><td>0.495</td><td>0.729</td><td>0.666</td><td>0.829</td><td>0.677</td><td>0.660</td><td>0.589</td></tr><tr><td>168</td><td>0.608</td><td>0.567</td><td>0.613</td><td>0.582</td><td>0.727</td><td>0.671</td><td>1.318</td><td>0.855</td><td>1.038</td><td>0.835</td><td>0.748</td><td>0.647</td></tr><tr><td>336</td><td>0.702</td><td>0.620</td><td>0.707</td><td>0.634</td><td>0.754</td><td>0.670</td><td>1.930</td><td>1.167</td><td>1.657</td><td>1.059</td><td>0.782</td><td>0.683</td></tr><tr><td>720</td><td>0.831</td><td>0.731</td><td>0.834</td><td>0.741</td><td>0.885</td><td>0.773</td><td>2.726</td><td>1.575</td><td>1.536</td><td>1.109</td><td>0.851</td><td>0.757</td></tr><tr><td rowspan=\"5\">ECL</td><td>48</td><td>0.344</td><td>0.393</td><td>0.334</td><td>0.399</td><td>0.355</td><td>0.418</td><td>1.404</td><td>0.999</td><td>0.486</td><td>0.572</td><td>0.369</td><td>0.445</td></tr><tr><td>168</td><td>0.368</td><td>0.424</td><td>0.353</td><td>0.420</td><td>0.368</td><td>0.432</td><td>1.515</td><td>1.069</td><td>0.574</td><td>0.602</td><td>0.394</td><td>0.476</td></tr><tr><td>336</td><td>0.381</td><td>0.431</td><td>0.381</td><td>0.439</td><td>0.373</td><td>0.439</td><td>1.601</td><td>1.104</td><td>0.886</td><td>0.795</td><td>0.419</td><td>0.477</td></tr><tr><td>720</td><td>0.406</td><td>0.443</td><td>0.391</td><td>0.438</td><td>0.409</td><td>0.454</td><td>2.009</td><td>1.170</td><td>1.676</td><td>1.095</td><td>0.556</td><td>0.565</td></tr><tr><td>960</td><td>0.460</td><td>0.548</td><td>0.492</td><td>0.550</td><td>0.477</td><td>0.589</td><td>2.141</td><td>1.387</td><td>1.591</td><td>1.128</td><td>0.605</td><td>0.599</td></tr><tr><td colspan=\"2\">Count</td><td colspan=\"2\">33</td><td colspan=\"2\">14</td><td colspan=\"2\">1</td><td colspan=\"2\">0</td><td colspan=\"2\">0</td><td colspan=\"2\">2</td></tr></table>\n\nTable 2: Multivariate long sequence time-series forecasting results on four datasets (five cases).\n\nUnder the LSTF settings, we prolong the prediction windows size  $L_{y}$  progressively, i.e.,  $\\{1\\mathrm{d},2\\mathrm{d},7\\mathrm{d},14\\mathrm{d},30\\mathrm{d},40\\mathrm{d}\\}$  in {ETTh, ECL, Weather},  $\\{6\\mathrm{h},12\\mathrm{h},24\\mathrm{h},72\\mathrm{h},168\\mathrm{h}\\}$  in ETTm. Metrics: We use two evaluation metrics, including  $\\mathrm{MSE} = \\frac{1}{n}\\sum_{i = 1}^{n}(\\mathbf{y} - \\hat{\\mathbf{y}})^2$  and MAE  $= \\frac{1}{n}\\sum_{i = 1}^{n}|\\mathbf{y} - \\hat{\\mathbf{y}} |$  on each prediction window (averaging for multivariate prediction), and roll the whole set with stride  $= 1$ . Platform: All the models were trained/tested on a single Nvidia V100 32GB GPU. The source code is available at https://github.com/zhouhaoyi/Informer2020.\n\n# Results and Analysis\n\nTable 1 and Table 2 summarize the univariate/multivariate evaluation results of all the methods on 4 datasets. We gradually prolong the prediction horizon as a higher requirement of prediction capacity, where the LSTF problem setting is precisely controlled to be tractable on one single GPU for each method. The best results are highlighted in boldface.\n\nUnivariate Time-series Forecasting Under this setting, each method attains predictions as a single variable over time series. From Table 1, we can observe that: (1) The proposed model Informer significantly improves the inference performance (winning-counts in the last column) across all datasets, and their predict error rises smoothly and slowly within the growing prediction horizon, which demonstrates the success of Informer in enhancing the prediction capacity in the LSTF problem. (2) The Informer beats its canonical degradation Informer $^{\\dagger}$  mostly in winning-counts, i.e.,  $32 > 12$\n\nwhich supports the query sparsity assumption in providing a comparable attention feature map. Our proposed method also out-performs the most related work LogTrans and Reformer. We note that the Reformer keeps dynamic decoding and performs poorly in LSTF, while other methods benefit from the generative style decoder as nonautoregressive predictors. (3) The Informer model shows significantly better results than recurrent neural networks LSTMa. Our method has a MSE decrease of  $26.8\\%$  (at 168),  $52.4\\%$  (at 336) and  $60.1\\%$  (at 720). This reveals a shorter network path in the self-attention mechanism acquires better prediction capacity than the RNN-based models. (4) The proposed method outperforms DeepAR, ARIMA and Prophet on MSE by decreasing  $49.3\\%$  (at 168),  $61.1\\%$  (at 336), and  $65.1\\%$  (at 720) in average. On the ECL dataset, DeepAR performs better on shorter horizons  $(\\leq 336)$ , and our method surpasses on longer horizons. We attribute this to a specific example, in which the effectiveness of prediction capacity is reflected with the problem scalability.\n\nMultivariate Time-series Forecasting Within this setting, some univariate methods are inappropriate, and LSTnet is the state-of-art baseline. On the contrary, our proposed Informer is easy to change from univariate prediction to multivariate one by adjusting the final FCN layer. From Table 2, we observe that: (1) The proposed model Informer greatly outperforms other methods and the findings 1 & 2 in the univariate settings still hold for the multivariate time-series. (2) The Informer model shows better results than RNN-based\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-11-26/b330edeb-c0f6-4c52-ae80-35aa5b05ddd9/3cc4a950b930e78d8c0f7ec255724b99697bc93088d4badaa9e3cdbcea56b4ab.jpg)  \n(a) Input length.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-11-26/b330edeb-c0f6-4c52-ae80-35aa5b05ddd9/c082988c5d0d292ab79e311bc3b8d7de7b1b339b1c10a15665552d79bf58dc6d.jpg)  \n(b) Sampling Factor.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-11-26/b330edeb-c0f6-4c52-ae80-35aa5b05ddd9/9e08cc6239b2744bf6514b7ca1ff70cb5f307a0133e6c0dc6463e69377617c29.jpg)  \n(c) Stacking Combination.  \nFigure 4: The parameter sensitivity of three components in Informer.\n\n<table><tr><td colspan=\"2\">Prediction length</td><td></td><td>336</td><td></td><td></td><td>720</td><td></td></tr><tr><td colspan=\"2\">Encoder&#x27;s input</td><td>336</td><td>720</td><td>1440</td><td>720</td><td>1440</td><td>2880</td></tr><tr><td rowspan=\"2\">Informer</td><td>MSE</td><td>0.249</td><td>0.225</td><td>0.216</td><td>0.271</td><td>0.261</td><td>0.257</td></tr><tr><td>MAE</td><td>0.393</td><td>0.384</td><td>0.376</td><td>0.435</td><td>0.431</td><td>0.422</td></tr><tr><td rowspan=\"2\">Informer†</td><td>MSE</td><td>0.241</td><td>0.214</td><td>-</td><td>0.259</td><td>-</td><td>-</td></tr><tr><td>MAE</td><td>0.383</td><td>0.371</td><td>-</td><td>0.423</td><td>-</td><td>-</td></tr><tr><td rowspan=\"2\">LogTrans</td><td>MSE</td><td>0.263</td><td>0.231</td><td>-</td><td>0.273</td><td>-</td><td>-</td></tr><tr><td>MAE</td><td>0.418</td><td>0.398</td><td>-</td><td>0.463</td><td>-</td><td>-</td></tr><tr><td rowspan=\"2\">Reformer</td><td>MSE</td><td>1.875</td><td>1.865</td><td>1.861</td><td>2.243</td><td>2.174</td><td>2.113</td></tr><tr><td>MAE</td><td>1.144</td><td>1.129</td><td>1.125</td><td>1.536</td><td>1.497</td><td>1.434</td></tr></table>\n\n$^{1}$  Informer† uses the canonical self-attention mechanism.  \n2 The '-' indicates failure for the out-of-memory.\n\nTable 3: Ablation study of the ProbSparse self-attention mechanism.  \n\n<table><tr><td rowspan=\"2\">Methods</td><td colspan=\"2\">Training</td><td>Testing</td></tr><tr><td>Time</td><td>Memory</td><td>Steps</td></tr><tr><td>Informer</td><td>O(L log L)</td><td>O(L log L)</td><td>1</td></tr><tr><td>Transformer</td><td>O(L2)</td><td>O(L2)</td><td>L</td></tr><tr><td>LogTrans</td><td>O(L log L)</td><td>O(L2)</td><td>1*</td></tr><tr><td>Reformer</td><td>O(L log L)</td><td>O(L log L)</td><td>L</td></tr><tr><td>LSTM</td><td>O(L)</td><td>O(L)</td><td>L</td></tr></table>\n\n1 The LSTnet is hard to present in a closed form.  \n2 The  $\\star$  denotes applying our proposed decoder.\n\nTable 4:  $L$  -related computation statics of each layer.\n\nLSTMa and CNN-based LSTnet, and the MSE decreases  $26.6\\%$  (at 168),  $28.2\\%$  (at 336),  $34.3\\%$  (at 720) in average. Compared with the univariate results, the overwhelming performance is reduced, and such phenomena can be caused by the anisotropy of feature dimensions' prediction capacity. It is beyond the scope of this paper, and we will explore it in the future work.\n\nLSTF with Granularity Consideration We perform an additional comparison to explore the performance with various granularities. The sequences  $\\{96, 288, 672\\}$  of  $\\mathrm{ETTm}_1$  (minutes-level) are aligned with  $\\{24, 48, 168\\}$  of  $\\mathrm{ETTh}_1$  (hour-level). The Informer outperforms other baselines even if the sequences are at different granularity levels.\n\n# Parameter Sensitivity\n\nWe perform the sensitivity analysis of the proposed Informer model on ETTh1 under the univariate setting. Input Length: In Fig.(4a), when predicting short sequences (like 48), initially increasing input length of encoder/decoder degrades performance, but further increasing causes the MSE to drop because it brings repeat short-term patterns. However, the MSE gets lower with longer inputs in predicting long sequences (like 168). Because the longer encoder input may contain more dependencies, and the longer decoder token has rich local information. Sampling Factor: The sampling factor controls the information bandwidth of\n\nProbSparse self-attention in Eq.(3). We start from the small factor  $(= 3)$  to large ones, and the general performance increases a little and stabilizes at last in Fig.(4b). It verifies our query sparsity assumption that there are redundant dot-product pairs in the self-attention mechanism. We set the sample factor  $c = 5$  (the red line) in practice. The Combination of Layer Stacking: The replica of Layers is complementary for the self-attention distilling, and we investigate each stack  $\\{\\mathrm{L},\\mathrm{L} / 2,\\mathrm{L} / 4\\}$  's behavior in Fig.(4c). The longer stack is more sensitive to the inputs, partly due to receiving more long-term information. Our method's selection (the red line), i.e., joining L and L/4, is the most robust strategy.\n\n# Ablation Study: How well Informer works?\n\nWe also conducted additional experiments on  $\\mathrm{ETTh}_1$  with ablation consideration.\n\nThe performance of ProbSparse self-attention mechanism In the overall results Table 1 & 2, we limited the problem setting to make the memory usage feasible for the canonical self-attention. In this study, we compare our methods with LogTrans and Reformer, and thoroughly explore their extreme performance. To isolate the memory efficient problem, we first reduce settings as {batch size=8, heads=8, dim=64}, and maintain other setups in the univariate case. In Table 3, the ProbSparse self-attention shows better performance than the counterparts. The LogTrans gets OOM\n\n<table><tr><td colspan=\"2\">Prediction length</td><td colspan=\"5\">336</td><td colspan=\"5\">480</td></tr><tr><td colspan=\"2\">Encoder&#x27;s input</td><td>336</td><td>480</td><td>720</td><td>960</td><td>1200</td><td>336</td><td>480</td><td>720</td><td>960</td><td>1200</td></tr><tr><td rowspan=\"2\">Informer†</td><td>MSE</td><td>0.249</td><td>0.208</td><td>0.225</td><td>0.199</td><td>0.186</td><td>0.197</td><td>0.243</td><td>0.213</td><td>0.192</td><td>0.174</td></tr><tr><td>MAE</td><td>0.393</td><td>0.385</td><td>0.384</td><td>0.371</td><td>0.365</td><td>0.388</td><td>0.392</td><td>0.383</td><td>0.377</td><td>0.362</td></tr><tr><td rowspan=\"2\">Informer‡</td><td>MSE</td><td>0.229</td><td>0.215</td><td>0.204</td><td>-</td><td>-</td><td>0.224</td><td>0.208</td><td>0.197</td><td>-</td><td>-</td></tr><tr><td>MAE</td><td>0.391</td><td>0.387</td><td>0.377</td><td>-</td><td>-</td><td>0.381</td><td>0.376</td><td>0.370</td><td>-</td><td>-</td></tr></table>\n\n$^{1}$  Informer $\\ddagger$  removes the self-attention distilling from Informer $\\dagger$ .  \n2 The '-' indicates failure for the out-of-memory.\n\nTable 5: Ablation study of the self-attention distilling.  \n\n<table><tr><td colspan=\"2\">Prediction length</td><td colspan=\"5\">336</td><td colspan=\"5\">480</td></tr><tr><td colspan=\"2\">Prediction offset</td><td>+0</td><td>+12</td><td>+24</td><td>+48</td><td>+72</td><td>+0</td><td>+48</td><td>+96</td><td>+144</td><td>+168</td></tr><tr><td rowspan=\"2\">Informer‡</td><td>MSE</td><td>0.207</td><td>0.209</td><td>0.211</td><td>0.211</td><td>0.216</td><td>0.198</td><td>0.203</td><td>0.203</td><td>0.208</td><td>0.208</td></tr><tr><td>MAE</td><td>0.385</td><td>0.387</td><td>0.391</td><td>0.393</td><td>0.397</td><td>0.390</td><td>0.392</td><td>0.393</td><td>0.401</td><td>0.403</td></tr><tr><td rowspan=\"2\">Informer§</td><td>MSE</td><td>0.201</td><td>-</td><td>-</td><td>-</td><td>-</td><td>0.392</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>MAE</td><td>0.393</td><td>-</td><td>-</td><td>-</td><td>-</td><td>0.484</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></table>\n\n<sup>1</sup> Informer<sup>\\S</sup> replaces our decoder with dynamic decoding one in Informer<sup>\\ddagger</sup>.  \n2 The '-' indicates failure for the unacceptable metric results.\n\nTable 6: Ablation study of the generative style decoder.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-11-26/b330edeb-c0f6-4c52-ae80-35aa5b05ddd9/a2ab1b745b026f983a923d1cb357e62076c282a5aa962e4e28e9f2fb9c177e1d.jpg)  \nFigure 5: The total runtime of training/testing phase.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-11-26/b330edeb-c0f6-4c52-ae80-35aa5b05ddd9/d16e1cdcfda7fb4d8f6b2c560406c0385a1635668c84496c53420336a083f0cf.jpg)\n\nin extreme cases because its public implementation is the mask of the full-attention, which still has  $\\mathcal{O}(L^2)$  memory usage. Our proposed ProbSparse self-attention avoids this from the simplicity brought by the query sparsity assumption in Eq.(4), referring to the pseudo-code in Appendix E.2, and reaches smaller memory usage.\n\nThe performance of self-attention distilling In this study, we use Informer† as the benchmark to eliminate additional effects of ProbSparse self-attention. The other experimental setup is aligned with the settings of univariate Time-series. From Table 5, Informer† has fulfilled all the experiments and achieves better performance after taking advantage of long sequence inputs. The comparison method Informer‡ removes the distilling operation and reaches OOM with longer inputs (>720). Regarding the benefits of long sequence inputs in the LSTF problem, we conclude that the self-attention distilling is worth adopting, especially when a longer prediction is required.\n\nThe performance of generative style decoder In this study, we testify the potential value of our decoder in acquiring a \"generative\" results. Unlike the existing methods, the\n\nlabels and outputs are forced to be aligned in the training and inference, our proposed decoder's predicting relies solely on the time stamp, which can predict with offsets. From Table 6, we can see that the general prediction performance of Informer $\\ddagger$  resists with the offset increasing, while the counterpart fails for the dynamic decoding. It proves the decoder's ability to capture individual long-range dependency between arbitrary outputs and avoid error accumulation.\n\n# Computation Efficiency\n\nWith the multivariate setting and all the methods' current finest implement, we perform a rigorous runtime comparison in Fig.(5). During the training phase, the Informer (red line) achieves the best training efficiency among Transformer-based methods. During the testing phase, our methods are much faster than others with the generative style decoding. The comparisons of theoretical time complexity and memory usage are summarized in Table 4. The performance of Informer is aligned with the runtime experiments. Note that the LogTrans focus on improving the self-attention mechanism, and we apply our proposed decoder in LogTrans for a fair comparison (the  $\\star$  in Table 4).\n",
  "hyperparameter": "Learning rate: 1e-4 (decaying by half every epoch); Total epochs: 8 with early stopping; Batch size: 32; Encoder: 3-layer main stack + 1-layer stack (1/4 input); Decoder: 2-layer; Sampling factor c: 5 for ProbSparse self-attention (u = c·ln(L_Q)); Number of attention heads: 8; Hidden dimension d_model: 64; Conv1d kernel width: 3 for distilling operation; Max-pooling stride: 2; Optimizer: Adam; Input/output lengths vary by dataset: {24, 48, 168, 336, 720} for hourly data (ETTh, ECL, Weather), {96, 288, 672} for 15-minute data (ETTm)"
}