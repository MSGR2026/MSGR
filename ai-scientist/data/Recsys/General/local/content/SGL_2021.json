{
  "id": "SGL_2021",
  "paper_title": "Self-supervised Graph Learning for Recommendation",
  "alias": "SGL",
  "year": 2021,
  "domain": "Recsys",
  "task": "GeneralRecommendation",
  "idea": "SGL (Self-supervised Graph Learning) introduces a self-supervised auxiliary task to enhance graph-based collaborative filtering by creating multiple augmented views of the user-item interaction graph through three operators: Node Dropout (ND), Edge Dropout (ED), and Random Walk (RW). The method uses contrastive learning (InfoNCE loss) to maximize agreement between different views of the same node while minimizing agreement between different nodes, which performs implicit hard negative mining. The self-supervised task is jointly optimized with the main BPR recommendation task in a multi-task learning framework, providing auxiliary supervision signals that improve representation learning, especially for long-tail items, while accelerating convergence and enhancing robustness to noisy interactions.",
  "introduction": "# 1 INTRODUCTION\n\nLearning high-quality user and item representations from interaction data is the theme of collaborative recommendation. Earlier work like matrix factorization (MF) [34] projects single ID of each user (or item) into an embedding vector. Some follow-on studies [20, 25] enrich the single ID with interaction history for learning better representations. More recently, representation learning has evolved to exploiting higher-order connectivity in user-item graph. The technique is inspired from the graph convolution networks (GCNs), which provide an end-to-end way to integrate multi-hop neighbors into node representation learning and achieve state-of-the-art performance for recommendation [19, 38, 46, 50].\n\nDespite effectiveness, current GCN-based recommender models suffer from some limitations:\n\n- Sparse Supervision Signal. Most models approach the recommendation task under a supervised learning paradigm [19, 21, 34], where the supervision signal comes from the observed user-item interactions. However, the observed interactions are extremely sparse [3, 18] compared to the whole interaction space, making it insufficient to learn quality representations.  \n- Skewed Data Distribution. Observed interactions usually exhibit a power-law distribution [9, 30], where the long tail consists of low-degree items that lack supervision signal. In contrast, high-degree items appear more frequently in neighborhood aggregation and supervised loss, thus exert larger impact on representation learning. Hence, the GCNs are easily biased towards high-degree items [5, 36], sacrificing the performance of low-degree (long-tail) items.  \n- Noises in Interactions. Most feedback that a user provides is implicit (e.g., clicks, views), instead of explicit (e.g., ratings, likes/dislikes). As such, observed interactions usually contain noises, e.g., a user is misled to click an item and finds it uninteresting after consuming it [44]. The neighborhood aggregation scheme in GCNs enlarges the impact of interactions on representation learning, making the learning more vulnerable to interaction noises.\n\nIn this work, we focus on exploring self-supervised learning (SSL) in recommendation, to solve the foregoing limitations. Though being prevalent in computer vision (CV) [11, 40] and natural\n\nlanguage processing (NLP) [10, 26], SSL is relatively less explored in recommendation. The idea is to set an auxiliary task that distills additional signal from the input data itself, especially through exploiting the unlabeled data space. For example, BERT [10] randomly masks some tokens in a sentence, setting the prediction of the masked tokens as the auxiliary task that can capture the dependencies among tokens; RotNet [11] randomly rotates labeled images, training the model on the rotated images to get improved representations for the mask task of object recognition or image classification. Compared with supervised learning, SSL allows us to exploit the unlabeled data space via making changes on the input data, achieving remarkable improvements in downstream tasks [6].\n\nHere we wish to bring the SSL's superiority into recommendation representation learning, which differs from CV/NLP tasks since the data are discrete and inter-connected. To address the aforementioned limitations of GCN-based recommendation models, we construct the auxiliary task as discriminating the representation of a node itself. Specifically, it consists of two key components: (1) data augmentation, which generates multiple views for each node, and (2) contrastive learning, which maximizes the agreement between different views of the same node, compared to that of other nodes. For GCNs on user-item graph, the graph structure serves as the input data that plays an essential role for representation learning. From this view, it is natural to construct the \"unlabeled\" data space by changing the graph adjacency matrix, and we develop three operators to this end: node dropout, edge dropout, and random walk, where each operator works with a different rationality. Thereafter, we perform contrastive learning based on the GCNs on the changed structure. As a result, SGL augments the node representation learning by exploring the internal relationship among nodes.\n\nConceptually, our SGL supplements existing GCN-based recommendation models in: (1) node self-discrimination offers auxiliary supervision signal, which is complementary to the classical supervisions from observed interactions only; (2) the augmentation operators, especially edge dropout, helps to mitigate the degree biases by intentionally reducing the influence of high-degree nodes; (3) the multiple views for nodes w.r.t. different local structures and neighborhoods enhance the model robustness against interaction noises. Last but not least, we offer theoretical analyses for the contrastive learning paradigm, finding that it has the side effect of mining hard negative examples, which not only boosts the performance but also accelerates the training process.\n\nIt is worthwhile mentioning that our SGL is model-agnostic and can be applied to any graph-based model that consists of user and/or item embedding. Here we implement it on the simple but effective model, LightGCN [19]. Experimental studies on three benchmark datasets demonstrate the effectiveness of SGL, which significantly improves the recommendation accuracy, especially on long-tail items, and enhance the robustness against interaction noises. We summarize the contributions of this work as follows:\n\n- We devise a new learning paradigm, SGL, which takes node self-discrimination as the self-supervised task to offer auxiliary signal for representation learning.  \n- In addition to mitigating degree bias and increasing robustness to interaction noises, we prove in theory that SGL inherently\n\nencourages learning from hard negatives, controlled by the temperature hyper-parameter in the softmax loss function.\n\n- We conduct extensive experiments on three benchmark datasets to demonstrate the superiority of SGL.\n",
  "method": "# 3 METHODOLOGY\n\nWe present the proposed Self-supervised Graph Learning (SGL) paradigm, which supercharges the main supervised task with self-supervised learning. Figure 1 illustrates the working flow of SGL. Specifically, the self-supervised task (also termed as pretext task or auxiliary task) is to construct supervision signal from the correlation within the input data.\n\nSpecifically, we introduce how to perform data augmentation that generates multiple representation views, followed by the contrastive learning based on the generated representations to build the pretext task. SSL is combined with classical GCN in a multi-task learning manner. Thereafter, we conduct theoretical analyses on SSL from the gradient level, revealing the connection with hard negative mining. Lastly, we analyze the complexity of SGL.\n\n## 3.1 Data Augmentation on Graph Structure\n\nDirectly grafting the data augmentation adopted in CV and NLP tasks [6, 10, 17, 47] is infeasible for graph-based recommendation, due to specific characteristics: (1) The features of users and items are discrete, like one-hot ID and other categorical variables. Hence, the augmentation operators on images, such as random crop, rotation, or blur, are not applicable. (2) More importantly, unlike CV and NLP tasks that treat each data instance as isolated, users and items in the interaction graph are inherently connected and dependent on each others. Thus, we need new augmentation operators tailored for graph-based recommendation.\n\nThe bipartite graph is built upon observed user-item interactions, thus containing the collaborative filtering signal. Specifically, the first-hop neighborhood directly profiles ego user and item nodes - i.e., historical items of a user (or interacted users of an item) can be viewed as the pre-existing features of user (or item). The second-hop neighboring nodes of a user (or an item) exhibit similar users w.r.t. behaviors (or similar items w.r.t. audiences). Furthermore, the higher-order paths from a user to an item reflect potential interests of the user on the item. Undoubtedly, mining the inherent patterns in graph structure is helpful to representation learning. We hence devise three operators on the graph structure, node dropout, edge dropout and random walk, to create different views of nodes. The operators can be uniformly expressed as follows:\n\n\\[\n\\mathbf {Z} _ {1} ^ {(l)} = H (\\mathbf {Z} _ {1} ^ {(l - 1)}, s _ {1} (\\mathcal {G})), \\mathbf {Z} _ {2} ^ {(l)} = H (\\mathbf {Z} _ {2} ^ {(l - 1)}, s _ {2} (\\mathcal {G})), s _ {1}, s _ {2} \\sim \\mathcal {S}, (6)\n\\]\n\n![](images/bd1995f36167e0368752b4d8c59009de8f80cc5cce84c3d27d8e44734a0a9e36.jpg)  \n(a) Edge Dropout\n\n![](images/d369289129bae647ec2bdec307b074f401af12fc3687094b67bb31a5b335987a.jpg)  \n(b) Random Walk  \nFigure 2: A toy example of higher-order connectivity in a three-layer GCN model with Edge Dropout (left) and Random Walk (right). For Random Walk, the graph structure keeps changing across layers as opposed to Edge Dropout. As a result, there exists a three-order path between node  \\(u_{1}\\)  and  \\(i_{1}\\)  that does not exist in Edge Dropout.\n\nwhere two stochastic selections  \\(s_1\\)  and  \\(s_2\\)  are independently applied on graph  \\(\\mathcal{G}\\) , and establish two correlated views of nodes  \\(\\mathbf{Z}_1^{(l)}\\)  and  \\(\\mathbf{Z}_2^{(l)}\\) . We elaborate the augmentation operators as follows:\n\n- Node Dropout (ND). With the probability  \\(\\rho\\) , each node is discarded from the graph, together with its connected edges. In particular,  \\(s_1\\)  and  \\(s_2\\)  can be modeled as:\n\n\\[\ns _ {1} (\\mathcal {G}) = \\left(\\mathbf {M} ^ {\\prime} \\odot \\mathcal {V}, \\mathcal {E}\\right), \\quad s _ {2} (\\mathcal {G}) = \\left(\\mathbf {M} ^ {\\prime \\prime} \\odot \\mathcal {V}, \\mathcal {E}\\right), \\tag {7}\n\\]\n\nwhere  \\(\\mathbf{M}',\\mathbf{M}''\\in \\{0,1\\}^{|\\mathcal{V}|}\\)  are two masking vectors which are applied on the node set  \\(\\mathcal{V}\\)  to generate two subgraphs. As such, this augmentation is expected to identify the influential nodes from differently augmented views, and make the representation learning less sensitive to structure changes.\n\n- Edge Dropout (ED). It drops out the edges in graph with a dropout ratio  \\(\\rho\\) . Two independent processes are represented as:\n\n\\[\ns _ {1} (\\mathcal {G}) = \\left(\\mathcal {V}, \\mathbf {M} _ {1} \\odot \\mathcal {E}\\right), \\quad s _ {2} (\\mathcal {G}) = \\left(\\mathcal {V}, \\mathbf {M} _ {2} \\odot \\mathcal {E}\\right), \\tag {8}\n\\]\n\nwhere  \\(\\mathbf{M}_1, \\mathbf{M}_2 \\in \\{0, 1\\}^{|\\mathcal{E}|}\\)  are two masking vectors on the edge set  \\(\\mathcal{E}\\) . Only partial connections within the neighborhood contribute to the node representations. As such, coupling these two subgraphs together aims to capture the useful patterns of the local structures of a node, and further endows the representations more robustness against noisy interactions.\n\n- Random Walk (RW). The above two operators generate a subgraph shared across all the graph convolution layers. To explore higher capability, we consider assigning different layers with different subgraphs. This can be seen as constructing an individual subgraph for each node with random walk [31] (see Figure 2 as an example). Assuming we choose edge dropout at each layer (with different ratio or random seeds), we can formulate RW by making the masking vector to be layer sensitive:\n\n\\[\ns _ {1} (\\mathcal {G}) = \\left(\\mathcal {V}, \\mathbf {M} _ {1} ^ {(l)} \\odot \\mathcal {E}\\right), \\quad s _ {2} (\\mathcal {G}) = \\left(\\mathcal {V}, \\mathbf {M} _ {2} ^ {(l)} \\odot \\mathcal {E}\\right), \\tag {9}\n\\]\n\nwhere  \\(\\mathbf{M}_1^{(l)},\\mathbf{M}_2^{(l)}\\in \\{0,1\\}^{\\lfloor \\mathcal{E}\\rfloor}\\)  are two masking vectors on the edge set  \\(\\mathcal{E}\\)  at layer  \\(l\\)\n\nWe apply these augmentations on graph structure per epoch for simplicity - that is, we generate two different views of each node at the beginning of a new training epoch (for RW, two different views are generated at each layer). Note that the dropout and masking ratios remain the same for two independent processes (i.e.,  \\(s_1\\)  and  \\(s_2\\) ). We leaving the tuning of different ratios in future work. It is also\n\nworthwhile mentioning that only dropout and masking operations are involved, and no any model parameters are added.\n\n### 3.2 Contrastive Learning\n\nHaving established the augmented views of nodes, we treat the views of the same node as the positive pairs (i.e.,  \\(\\{(\\mathbf{z}_u',\\mathbf{z}_u'')|u\\in \\mathcal{U}\\}\\) ), and the views of any different nodes as the negative pairs (i.e.,  \\(\\{(\\mathbf{z}_u',\\mathbf{z}_v'')|u,v\\in \\mathcal{U},u\\neq v\\}\\) ). The auxiliary supervision of positive pairs encourages the consistency between different views of the same node for prediction, while the supervision of negative pairs enforces the divergence among different nodes. Formally, we follow SimCLR [6] and adopt the contrastive loss, InfoNCE [14], to maximize the agreement of positive pairs and minimize that of negative pairs:\n\n\\[\n\\mathcal {L} _ {s s l} ^ {\\text {u s e r}} = \\sum_ {u \\in \\mathcal {U}} - \\log \\frac {\\exp \\left(s \\left(\\mathbf {z} _ {u} ^ {\\prime} , \\mathbf {z} _ {u} ^ {\\prime \\prime}\\right) / \\tau\\right)}{\\sum_ {v \\in \\mathcal {U}} \\exp \\left(s \\left(\\mathbf {z} _ {u} ^ {\\prime} , \\mathbf {z} _ {v} ^ {\\prime \\prime}\\right) / \\tau\\right)}, \\tag {10}\n\\]\n\nwhere  \\(s(\\cdot)\\)  measures the similarity between two vectors, which is set as cosine similarity function;  \\(\\tau\\)  is the hyper-parameter, known as the temperature in softmax. Analogously, we obtain the contrastive loss of the item side  \\(\\mathcal{L}_{ssl}^{item}\\) . Combining these two losses, we get the objective function of self-supervised task as  \\(\\mathcal{L}_{ssl} = \\mathcal{L}_{ssl}^{user} + \\mathcal{L}_{ssl}^{item}\\) .\n\n### 3.3 Multi-task Training\n\nTo improve recommendation with the SSL task, we leverage a multi-task training strategy to jointly optimize the classic recommendation task (cf. Equation (5)) and the self-supervised learning task (cf. Equation (10))\n\n\\[\n\\mathcal {L} = \\mathcal {L} _ {\\text {m a i n}} + \\lambda_ {1} \\mathcal {L} _ {\\text {s s l}} + \\lambda_ {2} \\| \\Theta \\| _ {2} ^ {2}, \\tag {11}\n\\]\n\nwhere  \\(\\Theta\\)  is the set of model parameters in  \\(L_{main}\\)  since  \\(L_{ssl}\\)  introduces no additional parameters;  \\(\\lambda_1\\)  and  \\(\\lambda_2\\)  are hyperparameters to control the strengths of SSL and  \\(L_2\\)  regularization, respectively. We also consider the alternative optimization - pre-training on  \\(\\mathcal{L}_{ssl}\\)  and fine-tuning on  \\(\\mathcal{L}_{main}\\) . See more details in Section 4.4.2.\n\n### 3.4 Theoretical Analyses of SGL\n\nIn this section, we offer in-depth analyses of SGL, aiming to answer the question: how does the recommender model benefit from the SSL task? Towards this end, we probe the self-supervised loss in Equation (10) and find one reason: it has the intrinsic ability to perform hard negative mining, which contributes large and meaningful gradients to the optimization and guides the node representation learning. In what follows, we present our analyses step by step.\n\nFormally, for node  \\(u \\in \\mathcal{U}\\) , the gradient of the self-supervised loss w.r.t. the representation  \\(z_u'\\)  is as follows:\n\n\\[\n\\frac {\\partial \\mathcal {L} _ {s s l} ^ {u s e r} (u)}{\\partial z _ {u} ^ {\\prime}} = \\frac {1}{\\tau \\| z _ {u} ^ {\\prime} \\|} \\left\\{c (u) + \\sum_ {v \\in \\mathcal {U} \\backslash \\{u \\}} c (v) \\right\\}, \\tag {12}\n\\]\n\nwhere  \\(\\mathcal{L}_{ssl}^{user}(u)\\)  is the individual term for a single node  \\(u\\)  in Equation (10);  \\(v\\in \\mathcal{U}\\setminus \\{u\\}\\)  is another node which serves as the negative view for node  \\(u\\) ;  \\(c(u)\\)  and  \\(c(v)\\)  separately represent the contribution of positive node  \\(u\\)  and negative nodes  \\(\\{v\\}\\)  to the\n\n![](images/6afcb639047637161a80ec3279b128603a6e939f8e12ee77673b72fa95872f35.jpg)\n\n![](images/7db2fa58119145c5d3edb45d9b4f66f43988c2e99a7943244562a5ef81bd8ef5.jpg)\n\n![](images/810989ba70e75ffda226216decb11fbacf2e5e3a399029774100c184b3df9cab.jpg)  \n(a)  \\(g(x),\\tau = 1\\)  \n(c)  \\(x^{*}(\\tau)\\)  \nFigure 3: Function curve of  \\(g(x)\\)  when  \\(\\tau = 1\\)  and  \\(\\tau = 0.1\\) , together with the logarithm of the maximum value of  \\(g(x)\\) . w.r.t.  \\(\\tau\\)  and its optimal position, i.e.,  \\(\\ln g(x^{*})\\)  and  \\(x^{*}(\\tau)\\) .\n\n![](images/09dae4d9656f3163ad00f1102691fb22b64fd990a63163dfc147a9461d24f837.jpg)  \n(b)  \\(g(x),\\tau = 0.1\\)  \n(d)  \\(\\ln g(x^{*})\\)\n\ngradients w.r.t.  \\(z_{u}^{\\prime}\\) :\n\n\\[\nc (u) = \\left(s _ {u} ^ {\\prime \\prime} - \\left(s _ {u} ^ {\\prime T} s _ {u} ^ {\\prime \\prime}\\right) s _ {u} ^ {\\prime}\\right) ^ {T} \\left(P _ {u u} - 1\\right), \\tag {13}\n\\]\n\n\\[\nc (v) = \\left(s _ {v} ^ {\\prime \\prime} - \\left(s _ {u} ^ {\\prime T} s _ {v} ^ {\\prime \\prime}\\right) s _ {u} ^ {\\prime}\\right) ^ {T} P _ {u v}, \\tag {14}\n\\]\n\nwhere  \\(P_{uv} = \\frac{\\exp(s_u'^T s_v'' / \\tau)}{\\sum_{v\\in\\mathcal{U}}\\exp(s_u'^T s_v'' / \\tau)}; s_u' = \\frac{z_u'}{\\|z_u''\\|}\\)  and  \\(s_u'' = \\frac{z_u''}{\\|z_u''\\|}\\)  are the normalized representations of node  \\(u\\)  from different views; similar notations to node  \\(v\\) . Afterwards, we focus on the contribution of negative node  \\(v\\)  (cf. Equation (14)), the  \\(L_2\\)  norm of which is proportional to the following term:\n\n\\[\n\\left\\| c (v) \\right\\| _ {2} \\propto \\sqrt {1 - \\left(s _ {u} ^ {\\prime T} s _ {v} ^ {\\prime \\prime}\\right) ^ {2}} \\exp \\left(s _ {u} ^ {\\prime T} s _ {v} ^ {\\prime \\prime} / \\tau\\right). \\tag {15}\n\\]\n\nAs  \\(s_u'\\)  and  \\(s_v''\\)  are both unit vectors, we can introduce another variable  \\(x = s_u'^T s_v'' \\in [-1, 1]\\)  to simplify Equation (15) as follows:\n\n\\[\ng (x) = \\sqrt {1 - x ^ {2}} \\exp \\left(\\frac {x}{\\tau}\\right), \\tag {16}\n\\]\n\nwhere  \\(x\\)  directly reflects the representation similarity between the positive node  \\(u\\)  and the negative node  \\(v\\) . According to the similarity  \\(x\\) , we can roughly categorize the negative nodes into two groups: (1) Hard negative nodes, whose representations are similar to that of the positive node  \\(u\\)  (i.e.,  \\(0 < x \\leq 1\\) ), thus making it difficult to distinguish  \\(v\\)  from  \\(u\\)  in the latent space; (2) Easy negative nodes, which are dissimilar to the positive node  \\(u\\)  (i.e.,  \\(-1 \\leq x < 0\\) ) and can be easily discriminated. To investigate the contributions of hard and easy negatives, we plot the curves of  \\(g(x)\\)  over the change of the node similarity  \\(x\\)  in Figures 3a and 3b, by setting  \\(\\tau = 1\\)  and  \\(\\tau = 0.1\\)  respectively. Clearly, under different conditions of  \\(\\tau\\) , the contributions of negative nodes differ dramatically with each others. Specifically, as Figure 3a shows, given  \\(\\tau = 1\\) , the values of  \\(g(x)\\)  fall into the range of (0, 1.5) and slightly change in response to  \\(x\\) . This suggests that negative samples, no matter hard or easy, contribute similarly to the gradient. In contrast, as Figure 3b displays, when setting  \\(\\tau = 0.1\\) , the values of  \\(g(x)\\)  at hard negatives could reach 4,000, while the contribution of easy negatives is vanishing. This indicates that hard negative nodes offer much larger gradients to guide the optimization, thus making node representations more discriminative and accelerating the training process [33].\n\nThese findings inspire us to probe the influence of  \\(\\tau\\)  on the maximum value of  \\(g(x)\\) . By approaching  \\(g(x)\\) 's derivative to zero, we can obtain  \\(x^{*} = (\\sqrt{\\tau^{2} + 4} -\\tau) / 2\\)  with maximum value  \\(g(x^{*})\\) . To see how  \\(g(x^{*})\\)  changes with  \\(\\tau\\) , we represent its logarithm as:\n\n\\[\n\\ln g \\left(x ^ {*}\\right) = \\ln \\left(\\sqrt {1 - \\left(\\frac {\\sqrt {\\tau^ {2} + 4} - \\tau}{2}\\right) ^ {2}} \\exp \\left(\\frac {\\sqrt {\\tau^ {2} + 4} - \\tau}{2 \\tau}\\right)\\right). \\tag {17}\n\\]\n\nWe present the curves of  \\(x^{*}\\)  and  \\(\\ln g(x^{*})\\)  in Figures 3c and 3d, respectively. With the decrease of  \\(\\tau\\) , the most influential negative nodes become more similar to the positive node (i.e.,  \\(x^{*}\\)  approaches 0.9), moreover, their contributions are amplified super-exponentially (i.e.,  \\(g^{*}\\)  is close to  \\(e^8\\) ). Hence, properly setting  \\(\\tau\\)  enables SGL to automatically perform hard negative mining.\n\nIt is worth mentioning that, our analyses are inspired by the prior study [24], but there are major differences: (1) [24] defines hard negatives as samples whose similarity are near-to-zero to the positive sample (i.e.,  \\(x \\approx 0\\) ), and easy negatives as obviously dissimilar samples (i.e.,  \\(x \\approx -1\\) ); (2) It leaves the region of  \\(x > 0\\)  untouched, which is however crucial in our case. Innovatively, we provide a more fine-grained view in the region of  \\(x > 0\\)  to highlight the critical role of  \\(\\tau\\) , the temperature hyper-parameter in softmax, in mining hard negatives.\n\n#### 3.5 Complexity Analyses of SGL\n\nIn this subsection, we analyze the complexity of SGL with ED as the strategy and LightGCN as the recommendation model; other choices can be analyzed similarly. Since SGL introduces no trainable parameters, the space complexity remains the same as LightGCN [19]. The time complexity of model inference is also the same, since there is no change on the model structure. In the following part, we will analyze the time complexity of SGL training.\n\nSuppose the number of nodes and edges in the user-item interaction graph are  \\(|V|\\)  and  \\(|E|\\)  respectively. Let  \\(s\\)  denote the number of epochs,  \\(B\\)  denote the size of each training batch,  \\(d\\)  denote the embedding size,  \\(L\\)  denote the number of GCN layers,  \\(\\hat{\\rho} = 1 - \\rho\\)  denote the keep probability of SGL-ED. The complexity mainly comes from two parts:\n\n- Normalization of adjacency matrix. Since we generate two independent sub-graphs per epoch, given the fact that the number of non-zero elements in the adjacency matrices of full training graph and two sub-graph are  \\(2|E|\\) ,  \\(2\\hat{\\rho} |E|\\)  and  \\(2\\hat{\\rho} |E|\\)  respectively, its total complexity is  \\(O(4\\hat{\\rho} |E|s + 2|E|)\\) .  \n- Evaluating self-supervised loss. We only consider the inner product in our analyses. As defined in Equation (10), we treat all other user nodes as negative samples when calculating InfoNCE loss of user side. Within a batch, the complexity of numerator and denominator are  \\(O(Bd)\\)  and  \\(O(BMd)\\) , respectively, where  \\(M\\)  is the number of users. And hence the total complexity of both user and item side per epoch is  \\(O(|E| d(2 + |V|))\\) . Therefore, the time complexity of the whole training phase is  \\(O(|E| d(2 + |V|)s)\\) . An alternative to reduce the time complexity is treating only the users (or the items) within the batch as negative samples [6, 49], resulting in total time complexity of  \\(O(|E| d(2 + 2B)s)\\) .\n\nWe summarize the time complexity in training between LightGCN and SGL-ED in Table 1. The analytical complexity of LightGCN\n\nTable 1: The comparison of analytical time complexity between LightGCN and SGL-ED.  \n\n<table><tr><td>Component</td><td>LightGCN</td><td>SGL-ED</td></tr><tr><td>Adjacency Matrix</td><td>O(2 |E|)</td><td>O(4hat|E|s+2|E|)</td></tr><tr><td>Graph Convolution</td><td>O(2 |E| Lds|E|/B)</td><td>O(2(1+2hat)|E| Lds|E|/B)</td></tr><tr><td>BPR Loss</td><td>O(2 |E| ds)</td><td>O(2 |E| ds)</td></tr><tr><td rowspan=\"2\">Self-supervised Loss</td><td rowspan=\"2\">-</td><td>O(|E| d(2+|V|)s)</td></tr><tr><td>O(|E| d(2+2B)s)</td></tr></table>\n\nTable 2: Statistics of the datasets.  \n\n<table><tr><td>Dataset</td><td>#Users</td><td>#Items</td><td>#Interactions</td><td>Density</td></tr><tr><td>Yelp2018</td><td>31,668</td><td>38,048</td><td>1,561,406</td><td>0.00130</td></tr><tr><td>Amazon-Book</td><td>52,643</td><td>91,599</td><td>2,984,108</td><td>0.00062</td></tr><tr><td>Alibaba-iFashion</td><td>300,000</td><td>81,614</td><td>1,607,813</td><td>0.00007</td></tr></table>\n\nand SGL-ED is actually in the same magnitude, since the increase of LightGCN only scales the complexity of LightGCN. In practice, taking the Yelp2018 data as an example, the time complexity of SGL-ED (alternative) with  \\(\\hat{\\rho}\\)  of 0.8 is about  \\(3.7\\mathrm{x}\\)  larger than LightGCN, which is totally acceptable considering the speedup of convergence speed we will show in Section 4.3.2. The testing platform is Nvidia Titan RTX graphics card equipped with Inter i7-9700K CPU (32GB Memory). The time cost of each epoch on Yelp2018 is 15.2s and 60.6s for LightGCN and SGL-ED (alternative) respectively, which is consistent with the complexity analyses.\n",
  "experiments": "# 4 EXPERIMENTS\n\nTo justify the superiority of SGL and reveal the reasons of its effectiveness, we conduct extensive experiments and answer the following research questions:\n\n- RQ1: How does SGL perform w.r.t. top- \\(K\\)  recommendation as compared with the state-of-the-art CF models?  \n- RQ2: What are the benefits of performing self-supervised learning in collaborative filtering?  \n- RQ3: How do different settings influence the effectiveness of the proposed SGL?\n\n## 4.1 Experimental Settings\n\nWe conduct experiments on three benchmark datasets: Yelp2018[19, 46], Amazon-Book[19, 46], and Alibaba-iFashion [8]'. Following [19, 46], we use the same 10-core setting for Yelp2018 and Amazon-Book. Alibaba-iFashion is more sparse, where we randomly sample 300k users and use all their interactions over the fashion outfits. The statistics of all three datasets are summarized in Table 2.\n\nWe follow the same strategy described in [46] to split the interactions into training, validation, and testing set with a ratio of 7:1:2. For users in the testing set, we follow the all-ranking protocol [46] to evaluate the top- \\(K\\)  recommendation performance and report the average  \\(\\text{Recall}@\\text{K}\\)  and  \\(\\text{NDCG}@\\text{K}\\)  where  \\(K = 20\\) .\n\n4.1.1 Compared Methods. We compare the proposed SGL with the following CF models:\n\nTable 3: Performance comparison with LightGCN at different layers. The performance of LightGCN on Yelp2018 and Amazon-Book are copied from its original paper. The percentage in brackets denote the relative performance improvement over LightGCN. The bold indicates the best result.  \n\n<table><tr><td colspan=\"2\">Dataset</td><td colspan=\"2\">Yelp2018</td><td colspan=\"2\">Amazon-Book</td><td colspan=\"2\">Alibaba-iFashion</td></tr><tr><td>#Layer</td><td>Method</td><td>Recall</td><td>NDCG</td><td>Recall</td><td>NDCG</td><td>Recall</td><td>NDCG</td></tr><tr><td rowspan=\"4\">1 Layer</td><td>LightGCN</td><td>0.0631</td><td>0.0515</td><td>0.0384</td><td>0.0298</td><td>0.0990</td><td>0.0454</td></tr><tr><td>SGL-ND</td><td>0.0643(+1.9%)</td><td>0.0529(+2.7%)</td><td>0.0432(+12.5%)</td><td>0.0334(+12.1%)</td><td>0.1133(+14.4%)</td><td>0.0539(+18.7%)</td></tr><tr><td>SGL-ED</td><td>0.0637(+1.0%)</td><td>0.0526(+2.1%)</td><td>0.0451(+17.4%)</td><td>0.0353(+18.5%)</td><td>0.1125(+13.6%)</td><td>0.0536(+18.1%)</td></tr><tr><td>SGL-RW</td><td>0.0637(+1.0%)</td><td>0.0526(+2.1%)</td><td>0.0451(+17.4%)</td><td>0.0353(+18.5%)</td><td>0.1125(+13.6%)</td><td>0.0536(+18.1%)</td></tr><tr><td rowspan=\"4\">2 Layers</td><td>LightGCN</td><td>0.0622</td><td>0.0504</td><td>0.0411</td><td>0.0315</td><td>0.1066</td><td>0.0505</td></tr><tr><td>SGL-ND</td><td>0.0658(+5.8%)</td><td>0.0538(+6.7%)</td><td>0.0427(+3.9%)</td><td>0.0335(+6.3%)</td><td>0.1106(+3.8%)</td><td>0.0526(+4.2%)</td></tr><tr><td>SGL-ED</td><td>0.0668(+7.4%)</td><td>0.0549(+8.9%)</td><td>0.0468(+13.9%)</td><td>0.0371(+17.8%)</td><td>0.1091(+2.3%)</td><td>0.0520(+3.0%)</td></tr><tr><td>SGL-RW</td><td>0.0644(+3.5%)</td><td>0.0530(+5.2%)</td><td>0.0453(+10.2%)</td><td>0.0358(+13.7%)</td><td>0.1091(+2.3%)</td><td>0.0521(+3.2%)</td></tr><tr><td rowspan=\"4\">3 Layers</td><td>LightGCN</td><td>0.0639</td><td>0.0525</td><td>0.0410</td><td>0.0318</td><td>0.1078</td><td>0.0507</td></tr><tr><td>SGL-ND</td><td>0.0644(+0.8%)</td><td>0.0528(+0.6%)</td><td>0.0440(+7.3%)</td><td>0.0346(+8.8%)</td><td>0.1126(4.5%)</td><td>0.0536(+5.7%)</td></tr><tr><td>SGL-ED</td><td>0.0675(+5.6%)</td><td>0.0555(+5.7%)</td><td>0.0478(+16.6%)</td><td>0.0379(+19.2%)</td><td>0.1126(+4.5%)</td><td>0.0538(+6.1%)</td></tr><tr><td>SGL-RW</td><td>0.0667(+4.4%)</td><td>0.0547(+4.2%)</td><td>0.0457(+11.5%)</td><td>0.0356(+12.0%)</td><td>0.1139(+5.7%)</td><td>0.0539(+6.3%)</td></tr></table>\n\n- NGCF [46]. This is a graph-based CF method largely follows the standard GCN [12]. It additionally encodes the second-order feature interaction into the message during message passing. We tune the regularization coefficient  \\(\\lambda_{2}\\)  and the number of GCN layers within the suggested ranges.  \n- LightGCN [19]. This method devises a light graph convolution for training efficiency and generation ability. Similarly, we tune the  \\(\\lambda_{2}\\)  and the number of GCN layers.  \n- Mult-VAE [28]. This is an item-based CF method based on the variational auto-encoder (VAE). It is optimized with an additional reconstruction objective, which can be seen as a special case of SSL. We follow the suggested model setting and tune the dropout ratio and  \\(\\beta\\) .  \n- DNN+SSL [49]. This is a state-of-the-art SSL-based recommendation method. With DNNs as the encoder of items, it adopts two augmentation operators, feature masking (FM) and feature dropout (FD), on the pre-existing features of items. In our cases where no item feature is available, we apply the augmentations on ID embeddings of items instead. We tune the DNN architecture (i.e., the number of layers and the number of neurons per layer) as suggested in the original paper.\n\nWe discard potential baselines like MF [34], NeuMF [21], GC-MC [38], and PinSage [50] since the previous work [19, 28, 46] has validated the superiority over the compared ones. Upon LightGCN, we implement three variants of the proposed SGL, named SGL-ND, SGL-ED, and SGL-RW, which are equipped with Node Dropout, Edge Dropout, and Random Walk, respectively.\n\n4.1.2 Hyper-parameter Settings. For fair comparison, all models are trained from scratch which are initialized with the Xavier method [13]. The models are optimized by the Adam optimizer with learning rate of 0.001 and mini-batch size of 2048. The early stopping strategy is the same as NGCF and LightGCN. The proposed SGL methods inherit the optimal values of the shared hyperparameters. For the unique ones of SGL, we tune  \\(\\lambda_1\\) ,  \\(\\tau\\) , and  \\(\\rho\\)  within the ranges of  \\(\\{0.005, 0.01, 0.05, 0.1, 0.5, 1.0\\}\\) ,  \\(\\{0.1, 0.2, 0.5, 1.0\\}\\) , and  \\(\\{0, 0.1, 0.2, \\dots, 0.5\\}\\) , respectively.\n\n### 4.2 Performance Comparison (RQ1)\n\n4.2.1 Comparison with LightGCN. Table 3 shows the result comparison between SGL and LightGCN. We find that:\n\n- In most cases, three SGL implementations outperform LightGCN by a large margin, indicating the superiority of supplementing the recommendation task with self-supervised learning.  \n- In SGL family, SGL-ED achieves best performance in 10 over 18 cases, while SGL-RW also performs better than SGL-ND across all three datasets. We ascribe these to the ability of edge dropout-like operators to capture inherent patterns in graph structure. Moreover, the performance of SGL-ED is better than that of SGL-RW in the denser datasets (Yelp2018 and Amazon-Book), while slightly worse in the sparser dataset (Alibaba-iFashion). One possible reason is that, in sparser datasets, ED is more likely to blocks connections of low-degree nodes (inactive users and unpopular items), while RW could restore their connections at different layers, as the case of node  \\(u_{1}\\)  and  \\(i_{1}\\)  shown in Figure 2.  \n- SGL-ND is relatively unstable than SGL-ED and SGL-RW. For example, on Yelp2018 and Amazon-Book, the results of SGL-ED and SGL-RW increases when layers go deeper while SGL-ND exhibits different patterns. Node Dropout can be viewed as a special case of Edge Dropout, which discards edges around a few nodes. Hence, dropping high-degree nodes will dramatically change the graph structure, thus exerts influence on the information aggregation and makes the training unstable.  \n- The improvements on Amazon-Book and Alibaba-iFashion are more significant than that on Yelp2018. This might be caused by the characteristics of datasets. Specifically, in Amazon-Book and Alibaba-iFashion, supervision signal from user-item interactions is too sparse to guide the representation learning in LightGCN. Benefiting from the self-supervised task, SGL obtains auxiliary supervisions to assist the representation learning.  \n- Increasing the model depth from 1 to 3 is able to enhance the performance of SGL. This indicates that exploiting SSL could empower the generalization ability of GCN-based recommender models - that is, the contrastive learning among different nodes is of promise to solving the oversmoothing issue of node representations, further avoiding the overfitting problem.\n\n![](images/0cd6a468b6507ea5ea83db54236c86617270cddce769808c7887397b262ec05d.jpg)  \n(a) Yelp2018\n\n![](images/bc886f19e1c2f2ba70c9c2c20bf1991c8538e81c8140d8e8a6a65548b33dfaf9.jpg)  \n(b) Amazon-Book\n\n![](images/9475404545aa5138ea767d277f2a25748b656df9692fe5676ba1cde2b8fcc1c6.jpg)  \n(c) Alibaba-iFashion  \nFigure 4: Performance comparison over different item groups between SGL-ED and LightGCN. The suffix in the legend indicates the number of GCN layers.\n\nTable 4: Overall Performance Comparison.  \n\n<table><tr><td>Dataset</td><td colspan=\"2\">Yelp2018</td><td colspan=\"2\">Amazon-Book</td><td colspan=\"2\">Alibaba-iFashion</td></tr><tr><td>Method</td><td>Recall</td><td>NDCG</td><td>Recall</td><td>NDCG</td><td>Recall</td><td>NDCG</td></tr><tr><td>NGCF</td><td>0.0579</td><td>0.0477</td><td>0.0344</td><td>0.0263</td><td>0.1043</td><td>0.0486</td></tr><tr><td>LightGCN</td><td>0.0639</td><td>0.0525</td><td>0.0411</td><td>0.0315</td><td>0.1078</td><td>0.0507</td></tr><tr><td>Mult-VAE</td><td>0.0584</td><td>0.0450</td><td>0.0407</td><td>0.0315</td><td>0.1041</td><td>0.0497</td></tr><tr><td>DNN+SSL</td><td>0.0483</td><td>0.0382</td><td>0.0438</td><td>0.0337</td><td>0.0712</td><td>0.0325</td></tr><tr><td>SGL-ED</td><td>0.0675</td><td>0.0555</td><td>0.0478</td><td>0.0379</td><td>0.1126</td><td>0.0538</td></tr><tr><td>%Improv.</td><td>5.63%</td><td>5.71%</td><td>9.13%</td><td>12.46%</td><td>4.45%</td><td>6.11%</td></tr><tr><td>p-value</td><td>5.92e-8</td><td>1.89e-8</td><td>5.07e-10</td><td>3.63e-10</td><td>3.34e-8</td><td>4.68e-10</td></tr></table>\n\n4.2.2 Comparison with the State-of-the-Arts. In Table 4, we summarize the performance comparison with various baselines. We find that: (1) SGL-ED consistently outperforms all baselines across the board. This again verifies the rationality and effectiveness of incorporating the self-supervised learning. (2) LightGCN achieves better performance than NGCF and Mult-VAE, which is consistent to the claim of LightGCN paper. The performance of Mult-VAE is on par with NGCF and LightGCN on Alibaba-iFashion, while outperforms NGCF on Amazon-Book. (3) DNN+SSL is the strongest baseline on Amazon-Book, showing the great potential of SSL in recommendation. Surprisingly, on the other datasets, DNN+SSL performs much worse than SGL-ED. This suggests that directly applying SSL on ID embeddings might be suboptimal and inferior than that on graph representations. (4) Moreover, we conduct the significant test, where  \\(p\\) -value  \\(< 0.05\\)  indicates that the improvements of SGL-ED over the strongest baseline are statistically significant in all six cases.\n\n### 4.3 Benefits of SGL (RQ2)\n\nIn this section, we study the benefits of SGL from three dimensions: (1) long-tail recommendation; (2) training efficiency; and (3) robustness to noises. Due to the limited space, we only report the results of SGL-ED, while having similar observations in others.\n\n4.3.1 Long-tail Recommendation. As Introduction mentions, GNN-based recommender models easily suffer from the long-tail problem. To verify whether SGL is of promise to solving the problem, we split items into ten groups based on the popularity, meanwhile keeping the total number of interactions of each group the same. The larger the GroupID is, the larger degrees the items have. We then decompose the Recall@20 metric of the whole dataset\n\ninto contributions of single groups, as follows:\n\n\\[\nR e c a l l = \\frac {1}{M} \\sum_ {u = 1} ^ {M} \\frac {\\sum_ {g = 1} ^ {1 0} \\left| \\left(l _ {r e c} ^ {u}\\right) ^ {(g)} \\cap l _ {t e s t} ^ {u} \\right|}{\\left| l _ {t e s t} ^ {u} \\right|} = \\sum_ {g = 1} ^ {1 0} R e c a l l ^ {(g)}\n\\]\n\nwhere  \\(M\\)  is the number of users,  \\(l_{rec}^{u}\\)  and  \\(l_{test}^{u}\\)  are the items in the top-  \\(K\\)  recommendation list and relevant items in the testing set for user  \\(u\\) , respectively. As such,  \\(Recall^{(g)}\\)  measures the recommendation performance over the  \\(g\\) -th group. We report the results in Figure 4 and find that:\n\n- LightGCN is inclined to recommend high-degree items, while leaving long-tail items less exposed. Specifically, although only containing  \\(0.83\\%\\) ,  \\(0.83\\%\\)  and  \\(0.22\\%\\)  of item spaces, the 10-th group contributes  \\(39.72\\%\\) ,  \\(39.92\\%\\)  and  \\(51.92\\%\\)  of the total Recall scores in three datasets, respectively. This admits that, LightGCN hardly learns high-quality representations of long-tail items, due to the sparse interaction signal. Our SGL shows potentials in alleviating this issue: the contributions of the 10-group downgrade to  \\(36.27\\%\\) ,  \\(29.15\\%\\)  and  \\(35.07\\%\\)  in three datasets, respectively.  \n- Jointly analyzing Table. 3 and Figure 4, we find the performance improvements of SGL mainly come from accurately recommending the items with sparse interactions. This again verifies that the representation learning benefits greatly from auxiliary supervisions, so as to establish better representations of these items than LightGCN.\n\n4.3.2 Training Efficiency. Self-supervised learning has proved its superiority in pre-training natural language model [10] and graph structure [23, 31]. Thus, we would like to study its influence on training efficiency. Figure 5 shows the training curves of SGL-ED and LightGCN on Yelp2018 and Amazon-Book. As the number of epochs increases, the upper subfigures display the changes of training loss, while the bottoms record the performance changes in the testing set. We have the following observations:\n\n- Obviously, SGL is much faster to converge than LightGCN on Yelp2018 and Amazon-Book. In particular, SGL arrives at the best performance at the 18-th and 16-th epochs, while LightGCN takes 720 and 700 epochs in these two datasets respectively. This suggests that our SGL can greatly reduce the training time, meanwhile achieves remarkable improvements. We ascribe such speedups to two factors: (1) SGL adopts the InfoNCE\n\n![](images/7a8b395cb43a5b4d9f817fc88de225031e1208de865ef19b79dbe2d7f14084ee.jpg)  \n(a) Yelp2018-L3\n\n![](images/8a41f833beb50529f0a56a1b582505def96890e761466410e2959517f71969f5.jpg)  \n(b) Amazon-Book-L3\n\n![](images/3b746e18686ecf42c22326830b1641189f3281c30d209b6511988b7a8433ce06.jpg)  \nFigure 5: Training Curves of SGL-ED and LightGCN on three datasets. The suffix in the legend denotes the layer numbers.  \n(a) Yelp2018  \nFigure 6: Model performance w.r.t. noise ratio. The bar represents Recall, while the line represents the percentage of performance degradation.\n\n![](images/4fa3955b8f5106498b01365a9d1c4dfd72a77e513dc1b299630b92ab0c041c4a.jpg)  \n(b) Amazon-Book\n\nloss as the SSL objective which enables the model to learn representations from multiple negative samples, while the BPR loss in LightGCN only uses one negative sample which limits the model's perception field; (2) As analyzed in Section 3.4, with a proper  \\(\\tau\\) , SGL benefits from dynamic hard negative mining, where the hard negative samples offer meaningful and larger gradients to guide the optimization [54].\n\n- Another observation is that the origin of the rapid-decline period of BPR loss is slightly later than the rapid-rising period of Recall. This indicates the existence of a gap between the BPR loss and ranking task. We will conduct in-depth research on this phenomenon in our future work.\n\n4.3.3 Robustness to Noisy Interactions. We also conduct experiments to check SGL's robustness to noisy interactions. Towards this end, we contaminate the training set by adding a certain proportion of adversarial examples (i.e.,  \\(5\\%\\) ,  \\(10\\%\\) ,  \\(15\\%\\) ,  \\(20\\%\\)  negative user-item interactions), while keeping the testing set unchanged. Figure 6 shows the results on Yelp2018 and Amazon-Book datasets.\n\n- Clearly, adding noise data reduces the performance of SGL and LightGCN. However, the performance degradation of SGL is lower than that of LightGCN; moreover, as the noise ratio increases, the gap between two degradation curves becomes more apparent. This suggests that, by comparing differently augmented views of nodes, SGL is able to figure out useful patterns, especially informative graph structures of nodes, and reduce dependence on certain edges. In a nutshell, SGL offers a different angle to denoise false positive interactions in recommendation.  \n- Focusing on Amazon-Book, the performance of SGL with  \\(20\\%\\)  additional noisy interactions is still superior to LightGCN with noise-free dataset. This further justifies the superiority and robustness of SGL over LightGCN.\n\nTable 5: The comparison of different SSL variants  \n\n<table><tr><td>Dataset</td><td colspan=\"2\">Yelp2018</td><td colspan=\"2\">Amazon-Book</td></tr><tr><td>Method</td><td>Recall</td><td>NDCG</td><td>Recall</td><td>NDCG</td></tr><tr><td>SGL-ED-batch</td><td>0.0670</td><td>0.0549</td><td>0.0472</td><td>0.0374</td></tr><tr><td>SGL-ED-merge</td><td>0.0671</td><td>0.0547</td><td>0.0464</td><td>0.0368</td></tr><tr><td>SGL-pre</td><td>0.0653</td><td>0.0533</td><td>0.0429</td><td>0.0333</td></tr><tr><td>SGL-ED</td><td>0.0675</td><td>0.0555</td><td>0.0478</td><td>0.0379</td></tr></table>\n\n![](images/8e64a0e3915d5a146a69ee8ab300bd6e991b315581a79a163ecb331c39bec617.jpg)  \n(a) Yelp2018  \nFigure 7: Model performance as adjusting  \\(\\tau\\) .\n\n![](images/8870ec536b4261683afcdb5d81fd9b9e57a7e37e92e0cbdbb5af4013bbf98d8a.jpg)  \n(b) Amazon-Book\n\n- We find that SGL is more robust on Yelp2018. The possible reason may be that Amazon-Book is much sparser than Yelp2018, and adding noisy data exerts more influence on graph structure of Amazon-Book than that of Yelp2018.\n\n### 4.4 Study of SGL (RQ3)\n\nWe move on to studying different designs in SGL. We first investigate the impact of hyper-parameter  \\(\\tau\\) . We then explore the potential of adopting SGL as a pretraining for existing graph-based recommendation model. Lastly, we study the influence of negatives in the SSL objective function. Due to the space limitation, we omit the results on iFashion which have a similar trend to that on Yelp2018 and Amazon-Book.\n\n4.4.1 Effect of Temperature  \\(\\tau\\) . As verified in Section 3.4,  \\(\\tau\\)  play a critical role in hard negative mining. Figure 7 shows the curves of model performance w.r.t. different  \\(\\tau\\) .\n\nWe can observe that: (1) Increasing the value of  \\(\\tau\\)  (e.g., 1.0) will lead to poorer performance and take more training epochs to converge, which fall short in the ability to distinguish hard negatives from easy negatives. (2) In contrast, fixing  \\(\\tau\\)  to a too small value (e.g., 0.1) will hurt the model performance, since the gradients of a few negatives dominate the optimization, losing the supremacy of adding multiple negative samples in the SSL objective. In a nutshell, we suggest to tan  \\(\\tau\\)  in the range of  \\(0.1\\sim 1.0\\)  carefully.\n\n4.4.2 Effect of Pre-training. The foregoing experiments have shown the effectiveness of SGL, where the main supervised task and the self-supervised task are jointly optimized. Here we would like to answer the question: Can the recommendation performance benefit from the pre-trained model? Towards this goal, we first pre-train the self-supervised task to obtain the model parameters, use them to initialize LightGCN, and then fine-tune the model via optimizing the main task. We term this variant as SGL-pre and show the comparison with SGL in Table 5. Clearly, although SGL-pre performs worse than SGL-ED on both datasets, the results of SGL-pre are still better than that of LightGCN (cf. Table 3). Our self-supervised task is able to offer a better initialization for LightGCN,\n\nwhich is consistent to the observation in previous studies [6]. However, the better performance of joint training admits that the representations in the main and auxiliary tasks are mutually enhanced with each other.\n\n4.4.3 Effect of Negatives. Moreover, we also study the effect of the choice of negative samples in the auxiliary task. Two variants are considered: (1) SGL-ED-batch, which differentiates node types and treat users and items in a mini-batch as negative views for users and items, separately, and (2) SGL-ED-merge, which treat nodes within a mini-batch as negative, without differentiating the node types. We report the comparison in Table 5. SGL-ED-batch performs better than SGL-ED-merge, which indicates the necessity for distinguishing types of heterogeneous nodes. Moreover, SGL-ED-batch is on a par with SGL-ED that treats the whole spaces of users and items as negative. It suggests that training the SSL task in mini-batching is an efficient alternative.\n",
  "hyperparameter": "Learning rate: 0.001; Batch size: 2048; Embedding dimension (d): tuned; Number of GCN layers (L): 1-3 layers (best at 3 layers for most cases); λ₁ (SSL task weight): tuned in {0.005, 0.01, 0.05, 0.1, 0.5, 1.0}; τ (temperature in InfoNCE): tuned in {0.1, 0.2, 0.5, 1.0}, recommended range 0.1-1.0; ρ (dropout ratio for augmentation): tuned in {0, 0.1, 0.2, ..., 0.5}; λ₂ (L2 regularization): tuned; Keep probability ρ̂ = 1-ρ: 0.8 mentioned for complexity analysis; Optimizer: Adam with Xavier initialization"
}