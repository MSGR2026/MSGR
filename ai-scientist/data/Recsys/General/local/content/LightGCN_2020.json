{
  "id": "LightGCN_2020",
  "paper_title": "LightGCN: Simplifying and Powering Graph Convolution Network for Recommendation",
  "alias": "LightGCN",
  "year": 2020,
  "domain": "Recsys",
  "task": "GeneralRecommendation",
  "idea": "LightGCN simplifies Graph Convolutional Networks for recommendation by removing feature transformation and nonlinear activation, keeping only neighborhood aggregation with symmetric normalization. It combines embeddings from all layers (0 to K) with weighted sum to form final representations, where layer-0 embeddings are the only trainable parameters. This design achieves embedding smoothness through light graph convolution while avoiding oversmoothing, making the model more interpretable, easier to train, and more effective than complex GCN variants like NGCF.",
  "introduction": "# 1 INTRODUCTION\n\nTo alleviate information overload on the web, recommender system has been widely deployed to perform personalized information filtering [7, 45, 46]. The core of recommender system is to predict whether a user will interact with an item, e.g., click, rate, purchase, among other forms of interactions. As such, collaborative filtering (CF), which focuses on exploiting the past user-item interactions to achieve the prediction, remains to be a fundamental task towards effective personalized recommendation [10, 19, 28, 39].\n\nThe most common paradigm for CF is to learn latent features (a.k.a. embedding) to represent a user and an item, and perform prediction based on the embedding vectors [6, 19]. Matrix factorization is an early such model, which directly projects the single ID of a user to her embedding [26]. Later on, several research find that augmenting user ID with the her interaction history as the input can improve the quality of embedding. For example,  $\\mathrm{SVD}++$  [25] demonstrates the benefits of user interaction history in predicting user numerical ratings, and Neural Attentive Item Similarity (NAIS) [18] differentiates the importance of items in the interaction history and shows improvements in predicting item ranking. In view of user-item interaction graph, these improvements can be seen as coming from using the subgraph structure of a user - more specifically, her one-hop neighbors - to improve the embedding learning.\n\nTo deepen the use of subgraph structure with high-hop neighbors, Wang et al. [39] recently proposes NGCF and achieves state-of-the-art performance for CF. It takes inspiration from the Graph Convolution Network (GCN) [14, 23], following the same\n\npropagation rule to refine embeddings: feature transformation, neighborhood aggregation, and nonlinear activation. Although NGCF has shown promising results, we argue that its designs are rather heavy and burdensome — many operations are directly inherited from GCN without justification. As a result, they are not necessarily useful for the CF task. To be specific, GCN is originally proposed for node classification on attributed graph, where each node has rich attributes as input features; whereas in user-item interaction graph for CF, each node (user or item) is only described by a one-hot ID, which has no concrete semantics besides being an identifier. In such a case, given the ID embedding as the input, performing multiple layers of nonlinear feature transformation — which is the key to the success of modern neural networks [16] — will bring no benefits, but negatively increases the difficulty for model training.\n\nTo validate our thoughts, we perform extensive ablation studies on NGCF. With rigorous controlled experiments (on the same data splits and evaluation protocol), we draw the conclusion that the two operations inherited from GCN - feature transformation and nonlinear activation - has no contribution on NGCF's effectiveness. Even more surprising, removing them leads to significant accuracy improvements. This reflects the issues of adding operations that are useless for the target task in graph neural network, which not only brings no benefits, but rather degrades model effectiveness. Motivated by these empirical findings, we present a new model named LightGCN, including the most essential component of GCN - neighborhood aggregation - for collaborative filtering. Specifically, after associating each user (item) with an ID embedding, we propagate the embeddings on the user-item interaction graph to refine them. We then combine the embeddings learned at different propagation layers with a weighted sum to obtain the final embedding for prediction. The whole model is simple and elegant, which not only is easier to train, but also achieves better empirical performance than NGCF and other state-of-the-art methods like Mult-VAE [28].\n\nTo summarize, this work makes the following main contributions:\n\n- We empirically show that two common designs in GCN, feature transformation and nonlinear activation, have no positive effect on the effectiveness of collaborative filtering.  \n- We propose LightGCN, which largely simplifies the model design by including only the most essential components in GCN for recommendation.  \n- We empirically compare LightGCN with NGCF by following the same setting and demonstrate substantial improvements. In-depth analyses are provided towards the rationality of LightGCN from both technical and empirical perspectives.\n",
  "method": "# 3 METHOD\n\nThe former section demonstrates that NGCF is a heavy and burdensome GCN model for collaborative filtering. Driven by these findings, we set the goal of developing a light yet effective model by including the most essential ingredients of GCN for recommendation. The advantages of being simple are severalfold - more interpretable, practically easy to train and maintain, technically easy to analyze the model behavior and revise it towards more effective directions, and so on.\n\nIn this section, we first present our designed Light Graph Convolution Network (LightGCN) model, as illustrated in Figure 2. We then provide an in-depth analysis of LightGCN to show the rationality behind its simple design. Lastly, we describe how to do model training for recommendation.\n\n# 3.1 LightGCN\n\nThe basic idea of GCN is to learning representation for nodes by smoothing features over the graph [23, 40]. To achieve this, it performs graph convolution iteratively, i.e., aggregating the features of neighbors as the new representation of a target node. Such neighborhood aggregation can be abstracted as:\n\n$$\n\\mathbf {e} _ {u} ^ {(k + 1)} = \\operatorname {A G G} \\left(\\mathbf {e} _ {u} ^ {(k)}, \\left\\{\\mathbf {e} _ {i} ^ {(k)}: i \\in \\mathcal {N} _ {u} \\right\\}\\right). \\tag {2}\n$$\n\nThe AGG is an aggregation function - the core of graph convolution - that considers the  $k$ -th layer's representation of the target node and its neighbor nodes. Many work have specified the AGG, such as the weighted sum aggregator in GIN [42], LSTM aggregator in GraphSAGE [14], and bilinear interaction aggregator in BGNN [48] etc. However, most of the work ties feature transformation or nonlinear activation with the AGG function. Although they perform well on node or graph classification tasks that have semantic input features, they could be burdensome for collaborative filtering (see preliminary results in Section 2.2).\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-15/d7d9f54f-ae37-47b6-8c55-ee54b3d808e5/842051563750db36bae80ba8e7b46e6ce43d2cc8637e07c99029d00cf308ea19.jpg)  \nFigure 2: An illustration of LightGCN model architecture. In LGC, only the normalized sum of neighbor embeddings is performed towards next layer; other operations like self-connection, feature transformation, and nonlinear activation are all removed, which largely simplifies GCNs. In Layer Combination, we sum over the embeddings at each layer to obtain the final representations.\n\n3.1.1 Light Graph Convolution (LGC). In LightGCN, we adopt the simple weighted sum aggregator and abandon the use of feature transformation and nonlinear activation. The graph convolution operation (a.k.a., propagation rule [39]) in LightGCN is defined as:\n\n$$\n\\mathbf {e} _ {u} ^ {(k + 1)} = \\sum_ {i \\in \\mathcal {N} _ {u}} \\frac {1}{\\sqrt {| \\mathcal {N} _ {u} |} \\sqrt {| \\mathcal {N} _ {i} |}} \\mathbf {e} _ {i} ^ {(k)},\n$$\n\n$$\n\\mathbf {e} _ {i} ^ {(k + 1)} = \\sum_ {u \\in \\mathcal {N} _ {i}} \\frac {1}{\\sqrt {| \\mathcal {N} _ {i} |} \\sqrt {| \\mathcal {N} _ {u} |}} \\mathbf {e} _ {u} ^ {(k)}. \\tag {3}\n$$\n\nThe symmetric normalization term  $\\frac{1}{\\sqrt{|N_u|}\\sqrt{|N_i|}}$  follows the design of standard GCN [23], which can avoid the scale of embeddings increasing with graph convolution operations; other choices can also be applied here, such as the  $L_{1}$  norm, while empirically we find this symmetric normalization has good performance (see experiment results in Section 4.4.2).\n\nIt is worth noting that in LGC, we aggregate only the connected neighbors and do not integrate the target node itself (i.e., self-connection). This is different from most existing graph convolution operations [14, 23, 36, 39, 48] that typically aggregate extended neighbors and need to handle the self-connection specially. The layer combination operation, to be introduced in the next subsection, essentially captures the same effect as self-connections. Thus, there is no need in LGC to include self-connections.\n\n3.1.2 Layer Combination and Model Prediction. In LightGCN, the only trainable model parameters are the embeddings at the 0-th layer, i.e.,  $\\mathbf{e}_u^{(0)}$  for all users and  $\\mathbf{e}_i^{(0)}$  for all items. When they are given, the embeddings at higher layers can be computed via LGC defined in Equation (3). After  $K$  layers LGC, we further combine the embeddings obtained at each layer to form the final representation\n\nof a user (an item):\n\n$$\n\\mathbf {e} _ {u} = \\sum_ {k = 0} ^ {K} \\alpha_ {k} \\mathbf {e} _ {u} ^ {(k)}; \\quad \\mathbf {e} _ {i} = \\sum_ {k = 0} ^ {K} \\alpha_ {k} \\mathbf {e} _ {i} ^ {(k)}, \\tag {4}\n$$\n\nwhere  $\\alpha_{k} \\geq 0$  denotes the importance of the  $k$ -th layer embedding in constituting the final embedding. It can be treated as a hyperparameter to be tuned manually, or as a model parameter (e.g., output of an attention network [3]) to be optimized automatically. In our experiments, we find that setting  $\\alpha_{k}$  uniformly as  $1/(K + 1)$  leads to good performance in general. Thus we do not design special component to optimize  $\\alpha_{k}$ , to avoid complicating LightGCN unnecessarily and to keep its simplicity. The reasons that we perform layer combination to get final representations are threefold. (1) With the increasing of the number of layers, the embeddings will be over-smoothed [27]. Thus simply using the last layer is problematic. (2) The embeddings at different layers capture different semantics. E.g., the first layer enforces smoothness on users and items that have interactions, the second layer smooths users (items) that have overlap on interacted items (users), and higher-layers capture higher-order proximity [39]. Thus combining them will make the representation more comprehensive. (3) Combining embeddings at different layers with weighted sum captures the effect of graph convolution with self-connections, an important trick in GCNs (proof sees Section 3.2.1).\n\nThe model prediction is defined as the inner product of user and item final representations:\n\n$$\n\\hat {y} _ {u i} = \\mathbf {e} _ {u} ^ {T} \\mathbf {e} _ {i}, \\tag {5}\n$$\n\nwhich is used as the ranking score for recommendation generation.\n\n3.1.3 Matrix Form. We provide the matrix form of LightGCN to facilitate implementation and discussion with existing models. Let the user-item interaction matrix be  $\\mathbf{R} \\in \\mathbb{R}^{M \\times N}$  where  $M$  and  $N$  denote the number of users and items, respectively, and each entry  $R_{ui}$  is 1 if  $u$  has interacted with item  $i$  otherwise 0. We then obtain the adjacency matrix of the user-item graph as\n\n$$\n\\mathbf {A} = \\left( \\begin{array}{c c} \\mathbf {0} & \\mathbf {R} \\\\ \\mathbf {R} ^ {T} & \\mathbf {0} \\end{array} \\right), \\tag {6}\n$$\n\nLet the 0-th layer embedding matrix be  $\\mathbf{E}^{(0)}\\in \\mathbb{R}^{(M + N)\\times T}$ , where  $T$  is the embedding size. Then we can obtain the matrix equivalent form of LGC as:\n\n$$\n\\mathbf {E} ^ {(k + 1)} = \\left(\\mathbf {D} ^ {- \\frac {1}{2}} \\mathbf {A D} ^ {- \\frac {1}{2}}\\right) \\mathbf {E} ^ {(k)}, \\tag {7}\n$$\n\nwhere  $\\mathbf{D}$  is a  $(M + N)\\times (M + N)$  diagonal matrix, in which each entry  $D_{ii}$  denotes the number of nonzero entries in the  $i$ -th row vector of the adjacency matrix  $\\mathbf{A}$  (also named as degree matrix). Lastly, we get the final embedding matrix used for model prediction as:\n\n$$\n\\begin{array}{l} \\mathbf {E} = \\alpha_ {0} \\mathbf {E} ^ {(0)} + \\alpha_ {1} \\mathbf {E} ^ {(1)} + \\alpha_ {2} \\mathbf {E} ^ {(2)} + \\dots + \\alpha_ {K} \\mathbf {E} ^ {(K)} \\\\ = \\alpha_ {0} \\mathbf {E} ^ {(0)} + \\alpha_ {1} \\tilde {\\mathbf {A}} \\mathbf {E} ^ {(0)} + \\alpha_ {2} \\tilde {\\mathbf {A}} ^ {2} \\mathbf {E} ^ {(0)} + \\ldots + \\alpha_ {K} \\tilde {\\mathbf {A}} ^ {K} \\mathbf {E} ^ {(0)}, \\\\ \\end{array}\n$$\n\nwhere  $\\tilde{\\mathbf{A}} = \\mathbf{D}^{-\\frac{1}{2}}\\mathbf{A}\\mathbf{D}^{-\\frac{1}{2}}$  is the symmetrically normalized matrix.\n\n# 3.2 Model Analysis\n\nWe conduct model analysis to demonstrate the rationality behind the simple design of LightGCN. First we discuss the connection with the Simplified GCN (SGCN) [40], which is a recent linear\n\nGCN model that integrates self-connection into graph convolution; this analysis shows that by doing layer combination, LightGCN subsumes the effect of self-connection thus there is no need for LightGCN to add self-connection in adjacency matrix. Then we discuss the relation with the Approximate Personalized Propagation of Neural Predictions (APPNP) [24], which is recent GCN variant that addresses oversmoothing by inspiring from Personalized PageRank [15]; this analysis shows the underlying equivalence between LightGCN and APPNP, thus our LightGCN enjoys the same benefits in propagating long-range with controllable oversmoothing. Lastly we analyze the second-layer LGC to show how it smoothes a user with her second-order neighbors, providing more insights into the working mechanism of LightGCN.\n\n3.2.1 Relation with SGCN. In [40], the authors argue the unnecessary complexity of GCN for node classification and propose SGCN, which simplifies GCN by removing nonlinearities and collapsing the weight matrices to one weight matrix. The graph convolution in SGCN is defined as<sup>4</sup>:\n\n$$\n\\mathbf {E} ^ {(k + 1)} = (\\mathbf {D} + \\mathbf {I}) ^ {- \\frac {1}{2}} (\\mathbf {A} + \\mathbf {I}) (\\mathbf {D} + \\mathbf {I}) ^ {- \\frac {1}{2}} \\mathbf {E} ^ {(k)}, \\tag {9}\n$$\n\nwhere  $\\mathbf{I} \\in \\mathbb{R}^{(M + N) \\times (M + N)}$  is an identity matrix, which is added on  $\\mathbf{A}$  to include self-connections. In the following analysis, we omit the  $(\\mathbf{D} + \\mathbf{I})^{-\\frac{1}{2}}$  terms for simplicity, since they only re-scale embeddings. In SGCN, the embeddings obtained at the last layer are used for downstream prediction task, which can be expressed as:\n\n$$\n\\begin{array}{l} \\mathbf {E} ^ {(K)} = (\\mathbf {A} + \\mathbf {I}) \\mathbf {E} ^ {(K - 1)} = (\\mathbf {A} + \\mathbf {I}) ^ {K} \\mathbf {E} ^ {(0)} \\\\ = \\binom {K} {0} \\mathbf {E} ^ {(0)} + \\binom {K} {1} \\mathbf {A} \\mathbf {E} ^ {(0)} + \\binom {K} {2} \\mathbf {A} ^ {2} \\mathbf {E} ^ {(0)} + \\dots + \\binom {K} {K} \\mathbf {A} ^ {K} \\mathbf {E} ^ {(0)}. \\tag {10} \\\\ \\end{array}\n$$\n\nThe above derivation shows that, inserting self-connection into  $\\mathbf{A}$  and propagating embeddings on it, is essentially equivalent to a weighted sum of the embeddings propagated at each LGC layer.\n\n3.2.2 Relation with APPNP. In a recent work [24], the authors connect GCN with Personalized PageRank [15], inspiring from which they propose a GCN variant named APPNP that can propagate long range without the risk of oversmoothing. Inspired by the teleport design in Personalized PageRank, APPNP complements each propagation layer with the starting features (i.e., the 0-th layer embeddings), which can balance the need of preserving locality (i.e., staying close to the root node to alleviate oversmoothing) and leveraging the information from a large neighborhood. The propagation layer in APPNP is defined as:\n\n$$\n\\mathbf {E} ^ {(k + 1)} = \\beta \\mathbf {E} ^ {(0)} + (1 - \\beta) \\tilde {\\mathbf {A}} \\mathbf {E} ^ {(k)}, \\tag {11}\n$$\n\nwhere  $\\beta$  is the teleport probability to control the retaining of starting features in the propagation, and  $\\tilde{\\mathbf{A}}$  denotes the normalized adjacency matrix. In APPNP, the last layer is used for final prediction, i.e.,\n\n$$\n\\begin{array}{l} \\mathbf {E} ^ {(K)} = \\beta \\mathbf {E} ^ {(0)} + (1 - \\beta) \\tilde {\\mathbf {A}} \\mathbf {E} ^ {(K - 1)}, \\\\ = \\beta \\mathbf {E} ^ {(0)} + \\beta (1 - \\beta) \\tilde {\\mathbf {A}} \\mathbf {E} ^ {(0)} + (1 - \\beta) ^ {2} \\tilde {\\mathbf {A}} ^ {2} \\mathbf {E} ^ {(K - 2)} \\\\ = \\beta \\mathbf {E} ^ {(0)} + \\beta (1 - \\beta) \\tilde {\\mathbf {A}} \\mathbf {E} ^ {(0)} + \\beta (1 - \\beta) ^ {2} \\tilde {\\mathbf {A}} ^ {2} \\mathbf {E} ^ {(0)} + \\dots + (1 - \\beta) ^ {K} \\tilde {\\mathbf {A}} ^ {K} \\mathbf {E} ^ {(0)}. \\tag {12} \\\\ \\end{array}\n$$\n\nAligning with Equation (8), we can see that by setting  $\\alpha_{k}$  accordingly, LightGCN can fully recover the prediction embedding used by APPNP. As such, LightGCN shares the strength of APPNP in combating oversmoothing - by setting the  $\\alpha$  properly, we allow using a large  $K$  for long-range modeling with controllable oversmoothing.\n\nAnother minor difference is that APPNP adds self-connection into the adjacency matrix. However, as we have shown before, this is redundant due to the weighted sum of different layers.\n\n3.2.3 Second-Order Embedding Smoothness. Owing to the linearity and simplicity of LightGCN, we can draw more insights into how does it smooth embeddings. Here we analyze a 2-layer LightGCN to demonstrate its rationality. Taking the user side as an example, intuitively, the second layer smooths users that have overlap on the interacted items. More concretely, we have:\n\n$$\n\\mathbf {e} _ {u} ^ {(2)} = \\sum_ {i \\in \\mathcal {N} _ {u}} \\frac {1}{\\sqrt {\\left| \\mathcal {N} _ {u} \\right|} \\sqrt {\\left| \\mathcal {N} _ {i} \\right|}} \\mathbf {e} _ {i} ^ {(1)} = \\sum_ {i \\in \\mathcal {N} _ {u}} \\frac {1}{\\left| \\mathcal {N} _ {i} \\right|} \\sum_ {v \\in \\mathcal {N} _ {i}} \\frac {1}{\\sqrt {\\left| \\mathcal {N} _ {u} \\right|} \\sqrt {\\left| \\mathcal {N} _ {v} \\right|}} \\mathbf {e} _ {v} ^ {(0)}. \\tag {13}\n$$\n\nWe can see that, if another user  $v$  has co-interacted with the target user  $u$ , the smoothness strength of  $v$  on  $u$  is measured by the coefficient (otherwise 0):\n\n$$\nc _ {v - > u} = \\frac {1}{\\sqrt {\\left| \\mathcal {N} _ {u} \\right|} \\sqrt {\\left| \\mathcal {N} _ {v} \\right|}} \\sum_ {i \\in \\mathcal {N} _ {u} \\cap \\mathcal {N} _ {v}} \\frac {1}{\\left| \\mathcal {N} _ {i} \\right|}. \\tag {14}\n$$\n\nThis coefficient is rather interpretable: the influence of a second-order neighbor  $v$  on  $u$  is determined by 1) the number of co-interacted items, the more the larger; 2) the popularity of the co-interacted items, the less popularity (i.e., more indicative of user personalized preference) the larger; and 3) the activity of  $v$ , the less active the larger. Such interpretability well caters for the assumption of CF in measuring user similarity [2, 37] and evidences the reasonability of LightGCN. Due to the symmetric formulation of LightGCN, we can get similar analysis on the item side.\n\n# 3.3 Model Training\n\nThe trainable parameters of LightGCN are only the embeddings of the 0-th layer, i.e.,  $\\Theta = \\{\\mathbf{E}^{(0)}\\}$ ; in other words, the model complexity is same as the standard matrix factorization (MF). We employ the Bayesian Personalized Ranking (BPR) loss [32], which is a pairwise loss that encourages the prediction of an observed entry to be higher than its unobserved counterparts:\n\n$$\nL _ {B P R} = - \\sum_ {u = 1} ^ {M} \\sum_ {i \\in \\mathcal {N} _ {u}} \\sum_ {j \\notin \\mathcal {N} _ {u}} \\ln \\sigma \\left(\\hat {y} _ {u i} - \\hat {y} _ {u j}\\right) + \\lambda \\left\\| \\mathbf {E} ^ {(0)} \\right\\| ^ {2} \\tag {15}\n$$\n\nwhere  $\\lambda$  controls the  $L_{2}$  regularization strength. We employ the Adam [22] optimizer and use it in a mini-batch manner. We are aware of other advanced negative sampling strategies which might improve the LightGCN training, such as the hard negative sampling [31] and adversarial sampling [9]. We leave this extension in the future since it is not the focus of this work.\n\nNote that we do not introduce dropout mechanisms, which are commonly used in GCNs and NGCF. The reason is that we do not have feature transformation weight matrices in LightGCN, thus enforcing  $L_{2}$  regularization on the embedding layer is sufficient to prevent overfitting. This showcases LightGCN's advantages of being simple - it is easier to train and tune than NGCF which\n\nTable 2: Statistics of the experimented data.  \n\n<table><tr><td>Dataset</td><td>User #</td><td>Item #</td><td>Interaction #</td><td>Density</td></tr><tr><td>Gowalla</td><td>29,858</td><td>40,981</td><td>1,027,370</td><td>0.00084</td></tr><tr><td>Yelp2018</td><td>31,668</td><td>38,048</td><td>1,561,406</td><td>0.00130</td></tr><tr><td>Amazon-Book</td><td>52,643</td><td>91,599</td><td>2,984,108</td><td>0.00062</td></tr></table>\n\nadditionally requires to tune two dropout ratios (node dropout and message dropout) and normalize the embedding of each layer to unit length.\n\nMoreover, it is technically viable to also learn the layer combination coefficients  $\\{\\alpha_{k}\\}_{k = 0}^{K}$ , or parameterize them with an attention network. However, we find that learning  $\\alpha$  on training data does not lead improvement. This is probably because the training data does not contain sufficient signal to learn good  $\\alpha$  that can generalize to unknown data. We have also tried to learn  $\\alpha$  from validation data, as inspired by [5] that learns hyper-parameters on validation data. The performance is slightly improved (less than  $1\\%$ ). We leave the exploration of optimal settings of  $\\alpha$  (e.g., personalizing it for different users and items) as future work.\n",
  "experiments": "# 4 EXPERIMENTS\n\nWe first describe experimental settings, and then conduct detailed comparison with NGCF [39], the method that is most relevant with LightGCN but more complicated (Section 4.2). We next compare with other state-of-the-art methods in Section 4.3. To justify the designs in LightGCN and reveal the reasons of its effectiveness, we perform ablation studies and embedding analyses in Section 4.4. The hyper-parameter study is finally presented in Section 4.5.\n\n# 4.1 Experimental Settings\n\nTo reduce the experiment workload and keep the comparison fair, we closely follow the settings of the NGCF work [39]. We request the experimented datasets (including train/test splits) from the authors, for which the statistics are shown in Table 2. The Gowalla and Amazon-Book are exactly the same as the NGCF paper used, so we directly use the results in the NGCF paper. The only exception is the Yelp2018 data, which is a revised version. According to the authors, the previous version did not filter out cold-start items in the testing set, and they shared us the revised version only. Thus we re-run NGCF on the Yelp2018 data. The evaluation metrics are recall@20 and ndcg@20 computed by the all-ranking protocol — all items that are not interacted by a user are the candidates.\n\n4.1.1 Compared Methods. The main competing method is NGCF, which has shown to outperform several methods including GCN-based models GC-MC [35] and PinSage [45], neural network-based models NeuMF [19] and CMN [10], and factorization-based models MF [32] and HOP-Rec [43]. As the comparison is done on the same datasets under the same evaluation protocol, we do not further compare with these methods. In addition to NGCF, we further compare with two relevant and competitive CF methods:\n\n- Mult-VAE [28]. This is an item-based CF method based on the variational autoencoder (VAE). It assumes the data is generated from a multinomial distribution and using variational inference for parameter estimation. We run the codes released by the\n\nauthors $^5$ , tuning the dropout ratio in  $[0, 0.2, 0.5]$ , and the  $\\beta$  in  $[0.2, 0.4, 0.6, 0.8]$ . The model architecture is the suggested one in the paper:  $600 \\rightarrow 200 \\rightarrow 600$ .\n\n- GRMF [30]. This method smooths matrix factorization by adding the graph Laplacian regularizer. For fair comparison on item recommendation, we change the rating prediction loss to BPR loss. The objective function of GRMF is:\n\n$$\nL = - \\sum_ {u = 1} ^ {M} \\sum_ {i \\in \\mathcal {N} _ {u}} \\left(\\sum_ {j \\notin \\mathcal {N} _ {u}} \\ln \\sigma \\left(\\mathbf {e} _ {u} ^ {T} \\mathbf {e} _ {i} - \\mathbf {e} _ {u} ^ {T} \\mathbf {e} _ {j}\\right) + \\lambda_ {g} \\| \\mathbf {e} _ {u} - \\mathbf {e} _ {i} \\| ^ {2}\\right) + \\lambda \\| \\mathbf {E} \\| ^ {2}, \\tag {16}\n$$\n\nwhere  $\\lambda_{g}$  is searched in the range of  $[1e^{-5}, 1e^{-4}, \\dots, 1e^{-1}]$ . Moreover, we compare with a variant that adds normalization to graph Laplacian:  $\\lambda_{g}||\\frac{\\mathbf{e}_{u}}{\\sqrt{|N_{u}|}} - \\frac{\\mathbf{e}_{i}}{\\sqrt{|N_{i}|}}||^{2}$ , which is termed as GRMF-norm. Other hyper-parameter settings are same as LightGCN. The two GRMF methods benchmark the performance of smoothing embeddings via Laplacian regularizer, while our LightGCN achieves embedding smoothing in the predictive model.\n\n4.1.2 Hyper-parameter Settings. Same as NGCF, the embedding size is fixed to 64 for all models and the embedding parameters are initialized with the Xavier method [12]. We optimize LightGCN with Adam [22] and use the default learning rate of 0.001 and default mini-batch size of 1024 (on Amazon-Book, we increase the minibatch size to 2048 for speed). The  $L_{2}$  regularization coefficient  $\\lambda$  is searched in the range of  $\\{1e^{-6}, 1e^{-5}, \\dots, 1e^{-2}\\}$ , and in most cases the optimal value is  $1e^{-4}$ . The layer combination coefficient  $\\alpha_{k}$  is uniformly set to  $\\frac{1}{1 + K}$  where  $K$  is the number of layers. We test  $K$  in the range of 1 to 4, and satisfactory performance can be achieved when  $K$  equals to 3. The early stopping and validation strategies are the same as NGCF. Typically, 1000 epochs are sufficient for LightGCN to converge. Our implementations are available in both TensorFlow $^{6}$  and PyTorch $^{7}$ .\n\n# 4.2 Performance Comparison with NGCF\n\nWe perform detailed comparison with NGCF, recording the performance at different layers (1 to 4) in Table 4, which also shows the percentage of relative improvement on each metric. We further plot the training curves of training loss and testing recall in Figure 3 to reveal the advantages of LightGCN and to be clear of the training process. The main observations are as follows:\n\n- In all cases, LightGCN outperforms NGCF by a large margin. For example, on Gowalla the highest recall reported in the NGCF paper is 0.1570, while our LightGCN can reach 0.1830 under the 4-layer setting, which is  $16.56\\%$  higher. On average, the recall improvement on the three datasets is  $16.52\\%$  and the ndcg improvement is  $16.87\\%$ , which are rather significant.  \n- Aligning Table 4 with Table 1 in Section 2, we can see that LightGCN performs better than NGCF-fn, the variant of NGCF that removes feature transformation and nonlinear activation. As NGCF-fn still contains more operations than LightGCN (e.g., self-connection, the interaction between user embedding and item\n\nTable 3: Performance comparison between NGCF and LightGCN at different layers.  \n\n<table><tr><td colspan=\"2\">Dataset</td><td colspan=\"2\">Gowalla</td><td colspan=\"2\">Yelp2018</td><td colspan=\"2\">Amazon-Book</td></tr><tr><td>Layer #</td><td>Method</td><td>recall</td><td>ndcg</td><td>recall</td><td>ndcg</td><td>recall</td><td>ndcg</td></tr><tr><td rowspan=\"2\">1 Layer</td><td>NGCF</td><td>0.1556</td><td>0.1315</td><td>0.0543</td><td>0.0442</td><td>0.0313</td><td>0.0241</td></tr><tr><td>LightGCN</td><td>0.1755(+12.79%)</td><td>0.1492(+13.46%)</td><td>0.0631(+16.20%)</td><td>0.0515(+16.51%)</td><td>0.0384(+22.68%)</td><td>0.0298(+23.65%)</td></tr><tr><td rowspan=\"2\">2 Layers</td><td>NGCF</td><td>0.1547</td><td>0.1307</td><td>0.0566</td><td>0.0465</td><td>0.0330</td><td>0.0254</td></tr><tr><td>LightGCN</td><td>0.1777(+14.84%)</td><td>0.1524(+16.60%)</td><td>0.0622(+9.89%)</td><td>0.0504(+8.38%)</td><td>0.0411(+24.54%)</td><td>0.0315(+24.02%)</td></tr><tr><td rowspan=\"2\">3 Layers</td><td>NGCF</td><td>0.1569</td><td>0.1327</td><td>0.0579</td><td>0.0477</td><td>0.0337</td><td>0.0261</td></tr><tr><td>LightGCN</td><td>0.1823(+16.19%)</td><td>0.1555(+17.18%)</td><td>0.0639(+10.38%)</td><td>0.0525(+10.06%)</td><td>0.0410(+21.66%)</td><td>0.0318(+21.84%)</td></tr><tr><td rowspan=\"2\">4 Layers</td><td>NGCF</td><td>0.1570</td><td>0.1327</td><td>0.0566</td><td>0.0461</td><td>0.0344</td><td>0.0263</td></tr><tr><td>LightGCN</td><td>0.1830(+16.56%)</td><td>0.1550(+16.80%)</td><td>0.0649(+14.58%)</td><td>0.0530(+15.02%)</td><td>0.0406(+17.92%)</td><td>0.0313(+18.92%)</td></tr></table>\n\n*The scores of NGCF on Gowalla and Amazon-Book are directly copied from Table 3 of the NGCF paper (https://arxiv.org/abs/1905.08108)\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-15/d7d9f54f-ae37-47b6-8c55-ee54b3d808e5/01c1c0b08bfabb7729234590dfbbf5b2f64577fba738e1500e50d5980c5c410f.jpg)  \nFigure 3: Training curves of LightGCN and NGCF, which are evaluated by training loss and testing recall per 20 epochs on Gowalla and Amazon-Book (results on Yelp2018 show exactly the same trend which are omitted for space).\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-15/d7d9f54f-ae37-47b6-8c55-ee54b3d808e5/46b4dcc014d97b2d929bd66914e468cbb310c248e2682ccfad0d28f10d9f389a.jpg)\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-15/d7d9f54f-ae37-47b6-8c55-ee54b3d808e5/a791c271444b3bf3658c89a9b49329fb3ff37697decf8c8287a023af0d0dcf6f.jpg)\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-15/d7d9f54f-ae37-47b6-8c55-ee54b3d808e5/21604e10f588fe57e93ed2f9333142c1efe976ea75563f552fc2604a5bcf7d17.jpg)\n\nembedding in graph convolution, and dropout), this suggests that these operations might also be useless for NGCF-fn.\n\n- Increasing the number of layers can improve the performance, but the benefits diminish. The general observation is that increasing the layer number from 0 (i.e., the matrix factorization model, results see [39]) to 1 leads to the largest performance gain, and using a layer number of 3 leads to satisfactory performance in most cases. This observation is consistent with NGCF's finding.  \n- Along the training process, LightGCN consistently obtains lower training loss, which indicates that LightGCN fits the training data better than NGCF. Moreover, the lower training loss successfully transfers to better testing accuracy, indicating the strong generalization power of LightGCN. In contrast, the higher training loss and lower testing accuracy of NGCF reflect the practical difficulty to train such a heavy model it well. Note that in the figures we show the training process under the optimal hyper-parameter setting for both methods. Although increasing the learning rate of NGCF can decrease its training loss (even lower than that of LightGCN), the testing recall could not be improved, as lowering training loss in this way only finds trivial solution for NGCF.\n\n# 4.3 Performance Comparison with State-of-the-Arts\n\nTable 4 shows the performance comparison with competing methods. We show the best score we can obtain for each method. We can see that LightGCN consistently outperforms other methods on all three datasets, demonstrating its high effectiveness with simple yet reasonable designs. Note that LightGCN can be further improved by tuning the  $\\alpha_{k}$  (see Figure 4 for an evidence), while here we only use a uniform setting of  $\\frac{1}{K + 1}$  to avoid over-tuning it. Among the baselines, Mult-VAE exhibits the strongest performance,\n\nwhich is better than GRMF and NGCF. The performance of GRMF is on a par with NGCF, being better than MF, which admits the utility of enforcing embedding smoothness with Laplacian regularizer. By adding normalization into the Laplacian regularizer, GRM-fnorm betters than GRMF on Gowalla, while brings no benefits on Yelp2018 and Amazon-Book.\n\nTable 4: The comparison of overall performance among LightGCN and competing methods.  \n\n<table><tr><td>Dataset</td><td colspan=\"2\">Gowalla</td><td colspan=\"2\">Yelp2018</td><td colspan=\"2\">Amazon-Book</td></tr><tr><td>Method</td><td>recall</td><td>ndcg</td><td>recall</td><td>ndcg</td><td>recall</td><td>ndcg</td></tr><tr><td>NGCF</td><td>0.1570</td><td>0.1327</td><td>0.0579</td><td>0.0477</td><td>0.0344</td><td>0.0263</td></tr><tr><td>Mult-VAE</td><td>0.1641</td><td>0.1335</td><td>0.0584</td><td>0.0450</td><td>0.0407</td><td>0.0315</td></tr><tr><td>GRMF</td><td>0.1477</td><td>0.1205</td><td>0.0571</td><td>0.0462</td><td>0.0354</td><td>0.0270</td></tr><tr><td>GRMF-norm</td><td>0.1557</td><td>0.1261</td><td>0.0561</td><td>0.0454</td><td>0.0352</td><td>0.0269</td></tr><tr><td>LightGCN</td><td>0.1830</td><td>0.1554</td><td>0.0649</td><td>0.0530</td><td>0.0411</td><td>0.0315</td></tr></table>\n\n# 4.4 Ablation and Effectiveness Analyses\n\nWe perform ablation studies on LightGCN by showing how layer combination and symmetric sqrt normalization affect its performance. To justify the rationality of LightGCN as analyzed in Section 3.2.3, we further investigate the effect of embedding smoothness - the key reason of LightGCN's effectiveness.\n\n4.4.1 Impact of Layer Combination. Figure 4 shows the results of LightGCN and its variant LightGCN-single that does not use layer combination (i.e.,  $\\mathbf{E}^{(K)}$  is used for final prediction for a  $K$ -layer LightGCN). We omit the results on Yelp2018 due to space limitation, which show similar trend with Amazon-Book. We have three main observations:\n\n- Focusing on LightGCN-single, we find that its performance first improves and then drops when the layer number increases from\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-15/d7d9f54f-ae37-47b6-8c55-ee54b3d808e5/72d8591b8dee9a78d841a153d31c0becbc7d42bab56b2e92bdd83f6e9ce1bd87.jpg)  \nFigure 4: Results of LightGCN and the variant that does not use layer combination (i.e., LightGCN-single) at different layers on Gowalla and Amazon-Book (results on Yelp2018 shows the same trend with Amazon-Book which are omitted for space).\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-15/d7d9f54f-ae37-47b6-8c55-ee54b3d808e5/57a6fb565cdfa3ed38f7d736b679f06449856c236ff23e9441496ff7639938fd.jpg)\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-15/d7d9f54f-ae37-47b6-8c55-ee54b3d808e5/df0ca31a6af6b014d5354ac64834da8759894565be9a96539cdf641b0598a9ed.jpg)\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-15/d7d9f54f-ae37-47b6-8c55-ee54b3d808e5/51c093d4f8824a82536fa8b90324ade387bdb611436ea48721e5ab0456b6350a.jpg)\n\nTable 5: Performance of the 3-layer LightGCN with different choices of normalization schemes in graph convolution.  \n\n<table><tr><td>Dataset</td><td colspan=\"2\">Gowalla</td><td colspan=\"2\">Yelp2018</td><td colspan=\"2\">Amazon-Book</td></tr><tr><td>Method</td><td>recall</td><td>ndcg</td><td>recall</td><td>ndcg</td><td>recall</td><td>ndcg</td></tr><tr><td>LightGCN-L1-L</td><td>0.1724</td><td>0.1414</td><td>0.0630</td><td>0.0511</td><td>0.0419</td><td>0.0320</td></tr><tr><td>LightGCN-L1-R</td><td>0.1578</td><td>0.1348</td><td>0.0587</td><td>0.0477</td><td>0.0334</td><td>0.0259</td></tr><tr><td>LightGCN-L1</td><td>0.159</td><td>0.1319</td><td>0.0573</td><td>0.0465</td><td>0.0361</td><td>0.0275</td></tr><tr><td>LightGCN-L</td><td>0.1589</td><td>0.1317</td><td>0.0619</td><td>0.0509</td><td>0.0383</td><td>0.0299</td></tr><tr><td>LightGCN-R</td><td>0.1420</td><td>0.1156</td><td>0.0521</td><td>0.0401</td><td>0.0252</td><td>0.0196</td></tr><tr><td>LightGCN</td><td>0.1830</td><td>0.1554</td><td>0.0649</td><td>0.0530</td><td>0.0411</td><td>0.0315</td></tr></table>\n\nMethod notation: -L means only the left-side norm is used, -R means only the right-side norm is used, and - $L_{1}$  means the  $L_{1}$  norm is used.\n\n1 to 4. The peak point is on layer 2 in most cases, while after that it drops quickly to the worst point of layer 4. This indicates that smoothing a node's embedding with its first-order and second-order neighbors is very useful for CF, but will suffer from oversmoothing issues when higher-order neighbors are used.\n\n- Focusing on LightGCN, we find that its performance gradually improves with the increasing of layers. Even using 4 layers, LightGCN's performance is not degraded. This justifies the effectiveness of layer combination for addressing over-smoothing, as we have technically analyzed in Section 3.2.2 (relation with APPNP).  \n- Comparing the two methods, we find that LightGCN consistently outperforms LightGCN-single on Gowalla, but not on Amazon-Book and Yelp2018 (where the 2-layer LightGCN-single performs the best). Regarding this phenomenon, two points need to be noted before we draw conclusion: 1) LightGCN-single is special case of LightGCN that sets  $\\alpha_{K}$  to 1 and other  $\\alpha_{k}$  to 0; 2) we do not tune the  $\\alpha_{k}$  and simply set it as  $\\frac{1}{K + 1}$  uniformly for LightGCN. As such, we can see the potential of further enhancing the performance of LightGCN by tuning  $\\alpha_{k}$ .\n\n4.4.2 Impact of Symmetric Squr Normalization. In LightGCN, we employ symmetric sqrt normalization  $\\frac{1}{\\sqrt{|N_u|}\\sqrt{|N_i|}}$  on each neighbor embedding when performing neighborhood aggregation (cf. Equation (3)). To study its rationality, we explore different choices here. We test the use of normalization only at the left side (i.e., the target node's coefficient) and the right side (i.e., the neighbor node's coefficient). We also test  $L_{1}$  normalization, i.e., removing the square root. Note that if removing normalization, the training becomes numerically unstable and suffers from nota-value (NAN) issues, so we do not show this setting. Table 5\n\nTable 6: Smoothness loss of the embeddings learned by LightGCN and MF (the lower the smoother).  \n\n<table><tr><td>Dataset</td><td>Gowalla</td><td>Yelp2018</td><td>Amazon-book</td></tr><tr><td></td><td colspan=\"3\">Smoothness of User Embeddings</td></tr><tr><td>MF</td><td>15449.3</td><td>16258.2</td><td>38034.2</td></tr><tr><td>LightGCN-single</td><td>12872.7</td><td>10091.7</td><td>32191.1</td></tr><tr><td></td><td colspan=\"3\">Smoothness of Item Embeddings</td></tr><tr><td>MF</td><td>12106.7</td><td>16632.1</td><td>28307.9</td></tr><tr><td>LightGCN-single</td><td>5829.0</td><td>6459.8</td><td>16866.0</td></tr></table>\n\nshows the results of the 3-layer LightGCN. We have the following observations:\n\n- The best setting in general is using sqrt normalization at both sides (i.e., the current design of LightGCN). Removing either side will drop the performance largely.  \n- The second best setting is using  $L_{1}$  normalization at the left side only (i.e., LightGCN- $L_{1}$ -L). This is equivalent to normalize the adjacency matrix as a stochastic matrix by the in-degree.  \n- Normalizing symmetrically on two sides is helpful for the sqrt normalization, but will degrade the performance of  $L_{1}$  normalization.\n\n4.4.3 Analysis of Embedding Smoothness. As we have analyzed in Section 3.2.3, a 2-layer LightGCN smooths a user's embedding based on the users that have overlap on her interacted items, and the smoothing strength between two users  $c_{v \\to u}$  is measured in Equation (14). We speculate that such smoothing of embeddings is the key reason of LightGCN's effectiveness. To verify this, we first define the smoothness of user embeddings as:\n\n$$\nS _ {U} = \\sum_ {u = 1} ^ {M} \\sum_ {v = 1} ^ {M} c _ {v \\rightarrow u} \\left(\\frac {\\mathbf {e} _ {u}}{| | \\mathbf {e} _ {u} | | ^ {2}} - \\frac {\\mathbf {e} _ {v}}{| | \\mathbf {e} _ {v} | | ^ {2}}\\right) ^ {2}, \\tag {17}\n$$\n\nwhere the  $L_{2}$  norm on embeddings is used to eliminate the impact of the embedding's scale. Similarly we can obtain the definition for item embeddings. Table 6 shows the smoothness of two models, matrix factorization (i.e., using the  $\\mathbf{E}^{(0)}$  for model prediction) and the 2-layer LightGCN-single (i.e., using the  $\\mathbf{E}^{(2)}$  for prediction). Note that the 2-layer LightGCN-single outperforms MF in recommendation accuracy by a large margin. As can be seen, the smoothness loss of LightGCN-single is much lower than that of MF. This indicates that by conducting light graph convolution, the embeddings become smoother and more suitable for recommendation.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-15/d7d9f54f-ae37-47b6-8c55-ee54b3d808e5/fece702dc2a46383912128e854d00cd19502074fce732173e353658dc30a858a.jpg)  \nFigure 5: Performance of 2-layer LightGCN w.r.t. different regularization coefficient  $\\lambda$  on Yelp and Amazon-Book.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-15/d7d9f54f-ae37-47b6-8c55-ee54b3d808e5/d1ddb6b471e171d4087c749304f8553790489053b9592e3748b68e0b678aebef.jpg)\n\n# 4.5 Hyper-parameter Studies\n\nWhen applying LightGCN to a new dataset, besides the standard hyper-parameter learning rate, the most important hyper-parameter to tune is the  $L_{2}$  regularization coefficient  $\\lambda$ . Here we investigate the performance change of LightGCN w.r.t.  $\\lambda$ .\n\nAs shown in Figure 5, LightGCN is relatively insensitive to  $\\lambda$  even when  $\\lambda$  sets to 0, LightGCN is better than NGCF, which additionally uses dropout to prevent overfitting. This shows that LightGCN is less prone to overfitting since the only trainable parameters in LightGCN are ID embeddings of the 0-th layer, the whole model is easy to train and to regularize. The optimal value for Yelp2018, Amazon-Book, and Gowalla is  $1e^{-3}$ ,  $1e^{-4}$ , and  $1e^{-4}$ , respectively. When  $\\lambda$  is larger than  $1e^{-3}$ , the performance drops quickly, which indicates that too strong regularization will negatively affect model normal training and is not encouraged.\n",
  "hyperparameter": "Embedding size: 64; Learning rate: 0.001 (Adam optimizer); Mini-batch size: 1024 (2048 for Amazon-Book); L2 regularization coefficient λ: searched in [1e-6, 1e-5, ..., 1e-2], optimal typically 1e-4 (1e-3 for Yelp2018); Number of layers K: 1-4, optimal typically 3; Layer combination coefficient αk: uniformly set to 1/(K+1); Training epochs: typically 1000 for convergence; Symmetric sqrt normalization: 1/√(|Nu|·|Ni|) for neighborhood aggregation"
}