{
  "id": "GCMC_2018",
  "paper_title": "Graph Convolutional Matrix Completion",
  "alias": "GCMC",
  "year": 2018,
  "domain": "Recsys",
  "task": "GeneralRecommendation",
  "idea": "The paper proposes Graph Convolutional Matrix Completion (GC-MC), which reformulates matrix completion/recommendation as link prediction on bipartite user-item interaction graphs using an end-to-end trainable graph auto-encoder. The core innovation is a graph convolutional encoder that performs edge-type specific message passing (separate processing channels for each rating level) followed by a bilinear decoder that treats rating levels as separate classes. The model efficiently uses weight sharing across graph locations and incorporates side information through a separate processing channel to avoid information bottlenecks.",
  "introduction": "# 1 Introduction\n\nWith the explosive growth of e-commerce and social media platforms, recommendation algorithms have become indispensable tools for many businesses. Two main branches of recommender algorithms are often distinguished: content-based recommender systems [24] and collaborative filtering models [9]. Content-based recommender systems use content information of users and items, such as their respective occupation and genre, to predict the next purchase of a user or rating of an item. Collaborative filtering models solve the matrix completion task by taking into account the collective interaction data to predict future ratings or purchases.\n\nIn this work, we view matrix completion as a link prediction problem on graphs: the interaction data in collaborative filtering can be represented by a bipartite graph between user and item nodes, with observed ratings/purchases represented by links. Content information can naturally be included in this framework\n\nin the form of node features. Predicting ratings then reduces to predicting labeled links in the bipartite user-item graph.\n\nWe propose graph convolutional matrix completion (GC-MC): a graph-based auto-encoder framework for matrix completion, which builds on recent progress in deep learning on graphs [2, 6, 19, 5, 15, 30, 14]. The auto-encoder produces latent features of user and item nodes through a form of message passing on the bipartite interaction graph. These latent user and item representations are used to reconstruct the rating links through a bilinear decoder.\n\nThe benefit of formulating matrix completion as a link prediction task on a bipartite graph becomes especially apparent when recommender graphs are accompanied with structured external information such as social networks. Combining such external information with interaction data can alleviate performance bottlenecks related to the cold start problem. We demonstrate that our graph auto-encoder model efficiently combines interaction data with side information, without resorting to recurrent frameworks as in [22].\n\nThe paper is structured as follows: in Section 2 we introduce our graph auto-encoder model for matrix completion. Section 3 discusses related work. Experimental results are shown in Section 4, and conclusion and future research directions are discussed in Section 5.",
  "method": "# 2 Matrix completion as link prediction in bipartite graphs\n\nConsider a rating matrix  $M$  of shape  $N_{u} \\times N_{v}$ , where  $N_{u}$  is the number of users and  $N_{v}$  is the number of items. Entries  $M_{ij}$  in this matrix encode either an observed rating (user  $i$  rated item  $j$ ) from a set of discrete possible rating values, or the fact that the rating is unobserved (encoded by the value 0). See Figure 1 for an illustration. The task of matrix completion or recommendation can be seen as predicting the value of unobserved entries in  $M$ .\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-15/3b58f52b-f3b2-4d6b-b67e-cfa8026fc2c7/abfe28790fe8429717f5bd873e093c6d4f89b697398854e25fec8b68eb85dd02.jpg)  \nFigure 1: Left: Rating matrix  $M$  with entries that correspond to user-item interactions (ratings between 1-5) or missing observations (0). Right: User-item interaction graph with bipartite structure. Edges correspond to interaction events, numbers on edges denote the rating a user has given to a particular item. The matrix completion task (i.e. predictions for unobserved interactions) can be cast as a link prediction problem and modeled using an end-to-end trainable graph auto-encoder.\n\nIn an equivalent picture, matrix completion or recommendation can be cast as a link prediction problem on a bipartite user-item interaction graph. More precisely, the interaction data can be represented by an undirected graph  $G = (\\mathcal{W}, \\mathcal{E}, \\mathcal{R})$  with entities consisting of a collection of user nodes  $u_i \\in \\mathcal{U}$  with  $i \\in \\{1, \\dots, N_u\\}$ , and item nodes  $v_j \\in \\mathcal{V}$  with  $j \\in \\{1, \\dots, N_v\\}$ , such that  $\\mathcal{U} \\cup \\mathcal{V} = \\mathcal{W}$ . The edges  $(u_i, r, v_j) \\in \\mathcal{E}$  carry labels that represent ordinal rating levels, such as  $r \\in \\{1, \\dots, R\\} = \\mathcal{R}$ . This connection was previously explored in [18] and led to the development of graph-based methods for recommendation.\n\nPrevious graph-based approaches for recommender systems (see [18] for an overview) typically employ a multi-stage pipeline, consisting of a graph feature extraction model and a link prediction model, all of which are trained separately. Recent results, however, have shown that results can often be significantly improved by modeling graph-structured data with end-to-end learning techniques [2, 6, 19, 23, 5, 15, 21] and specifically with graph auto-encoders [30, 14] for unsupervised learning and link prediction. In what follows, we introduce a specific variant of graph auto-encoders for the task of recommendation.\n\n# 2.1 Graph auto-encoders\n\nWe revisit graph auto-encoders which were originally introduced in [30, 14] as an end-to-end model for unsupervised learning [30] and link prediction [14] on undirected graphs. We specifically consider the setup introduced in [14], as it makes efficient use of (convolutional) weight sharing and allows for inclusion of side information in the form of node features. Graph auto-encoders are comprised of 1) a graph encoder model  $Z = f(X,A)$ , which take as input an  $N\\times D$  feature matrix  $X$  and a graph adjacency matrix  $A$ , and produce an  $N\\times E$  node embedding matrix  $Z = [z_1^T,\\dots,z_N^T ]^T$\n\nand 2) a pairwise decoder model  $\\check{A} = g(Z)$ , which takes pairs of node embeddings  $(z_i, z_j)$  and predicts respective entries  $\\check{A}_{ij}$  in the adjacency matrix. Note that  $N$  denotes the number of nodes,  $D$  the number of input features, and  $E$  the embedding size.\n\nFor bipartite recommender graphs  $G = (\\mathcal{W}, \\mathcal{E}, \\mathcal{R})$ , we can reformulate the encoder as  $[U, V] = f(X, M_1, \\ldots, M_R)$ , where  $M_r \\in \\{0, 1\\}^{N_u \\times N_v}$  is the adjacency matrix associated with rating type  $r \\in \\mathcal{R}$ , such that  $M_r$  contains 1's for those elements for which the original rating matrix  $M$  contains observed ratings with value  $r$ .  $U$  and  $V$  are now matrices of user and item embeddings with shape  $N_u \\times E$  and  $N_v \\times E$ , respectively. A single user (item) embedding takes the form of a real-valued vector  $U_{i,:}$  ( $V_{j,:}$ ) for user  $i$  (item  $j$ ).\n\nAnalogously, we can reformulate the decoder as  $\\check{M} = g(U,V)$ , i.e. as a function acting on the user and item embeddings and returning a (reconstructed) rating matrix  $\\check{M}$  of shape  $N_u\\times N_v$ . We can train this graph auto-encoder by minimizing the reconstruction error between the predicted ratings in  $\\check{M}$  and the observed ground-truth ratings in  $M$ . Examples of metrics for the reconstruction error are the root mean square error, or the cross entropy when treating the rating levels as different classes.\n\nWe shall note at this point that several recent state-of-the-art models for matrix completion [17, 27, 7, 32] can be cast into this framework and understood as a special case of our model. An overview of these models is provided in Section 3.\n\n# 2.2 Graph convolutional encoder\n\nIn what follows, we propose a particular choice of encoder model that makes efficient use of weight sharing across locations in the graph and that assigns separate processing channels for each edge type (or rating type)\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-15/3b58f52b-f3b2-4d6b-b67e-cfa8026fc2c7/609b29ed8fc87bbee3931b1f1af7e53f1a2cff1ae51290dbe3717a899b0bd493.jpg)  \nFigure 2: Schematic of a forward-pass through the GC-MC model, which is comprised of a graph convolutional encoder  $[U,V] = f(X,M_1,\\dots ,M_R)$  that passes and transforms messages from user to item nodes, and vice versa, followed by a bilinear decoder model that predicts entries of the (reconstructed) rating matrix  $\\tilde{M} = g(U,V)$ , based on pairs of user and item embeddings.\n\n$r \\in \\mathcal{R}$ . The form of weight sharing is inspired by a recent class of convolutional neural networks that operate directly on graph-structured data [2, 6, 5, 15], in the sense that the graph convolutional layer performs local operations that only take the first-order neighborhood of a node into account, whereby the same transformation is applied across all locations in the graph.\n\nThis type of local graph convolution can be seen as a form of message passing [4, 8], where vector-valued messages are being passed and transformed across edges of the graph. In our case, we can assign a specific transformation for each rating level, resulting in edge-type specific messages  $\\mu_{j\\rightarrow i,r}$  from items  $j$  to users  $i$  of the following form:\n\n$$\n\\mu_ {j \\rightarrow i, r} = \\frac {1}{c _ {i j}} W _ {r} x _ {j}. \\tag {1}\n$$\n\nHere,  $c_{ij}$  is a normalization constant, which we choose to either be  $|\\mathcal{N}_i|$  (left normalization) or  $\\sqrt{|\\mathcal{N}_i||\\mathcal{N}_j|}$  (symmetric normalization) with  $\\mathcal{N}_i$  denoting the set of neighbors of node  $i$ .  $W_r$  is an edge-type specific parameter matrix and  $x_j$  is the (initial) feature vector of node  $j$ . Messages  $\\mu_{i\\rightarrow j,r}$  from users to items are processed in an analogous way. After the message passing step, we accumulate incoming messages at every node by summing over all neighbors  $\\mathcal{N}_{i,r}$  under a specific edge-type  $r$ , and by subsequently accumulating them into a single vector representation:\n\n$$\nh _ {i} = \\sigma \\left[ \\operatorname {a c c u m} \\left(\\sum_ {j \\in \\mathcal {N} _ {i, 1}} \\mu_ {j \\rightarrow i, 1}, \\dots , \\sum_ {j \\in \\mathcal {N} _ {i, R}} \\mu_ {j \\rightarrow i, R}\\right)\\right], \\tag {2}\n$$\n\nwhere  $\\mathrm{accum}(\\cdot)$  denotes an accumulation operation, such as stack  $(\\cdot)$ , i.e. a concatenation of vectors (or matrices along their first dimension), or sum  $(\\cdot)$ , i.e. summation of all messages.  $\\sigma (\\cdot)$  denotes an element-wise activation function such as the  $\\mathrm{ReLU}(\\cdot) = \\max (0,\\cdot)$ . To arrive at the final embedding of user node  $i$ , we\n\ntransform the intermediate output  $h_i$  as follows:\n\n$$\nu _ {i} = \\sigma \\left(W h _ {i}\\right). \\tag {3}\n$$\n\nThe item embedding  $v_{i}$  is calculated analogously with the same parameter matrix  $W$ . In the presence of user- and item-specific side information we use separate parameter matrices for user and item embeddings. We will refer to (2) as a graph convolution layer and to (3) as a dense layer. Note that deeper models can be built by stacking several layers (in arbitrary combinations) with appropriate activation functions. In initial experiments, we found that stacking multiple convolutional layers did not improve performance and a simple combination of a convolutional layer followed by a dense layer worked best.\n\nIt is worth mentioning that the model demonstrated here is only one particular possible, yet relatively simple choice of an encoder, and other variations are potentially worth exploring. Instead of a simple linear message transformation, one could explore variations where  $\\mu_{j\\rightarrow i,r} = nn(x_i,x_j,r)$  is a neural network in itself. Instead of choosing a specific normalization constant for individual messages, such as done here, one could employ some form of attention mechanism, where the individual contribution of each message is learned and determined by the model.\n\n# 2.3 Bilinear decoder\n\nFor reconstructing links in the bipartite interaction graph we consider a bilinear decoder, and treat each rating level as a separate class. Indicating the reconstructed rating between user  $i$  and item  $j$  with  $\\tilde{M}_{ij}$ , the decoder produces a probability distribution over possible rating levels through a bilinear operation followed by the application of a softmax function:\n\n$$\np \\left(\\check {M} _ {i j} = r\\right) = \\frac {e ^ {u _ {i} ^ {T} Q _ {r} v _ {j}}}{\\sum_ {s \\in R} e ^ {u _ {i} ^ {T} Q _ {s} v _ {j}}}, \\tag {4}\n$$\n\nwith  $Q_{r}$  a trainable parameter matrix of shape  $E\\times E$  and  $E$  the dimensionality of hidden user (item) repre\n\nsentations  $u_{i}(v_{j})$ . The predicted rating is computed as\n\n$$\n\\check {M} _ {i j} = g \\left(u _ {i}, v _ {j}\\right) = \\mathbb {E} _ {p \\left(\\check {M} _ {i j} = r\\right)} [ r ] = \\sum_ {r \\in R} r p \\left(\\check {M} _ {i j} = r\\right). \\tag {5}\n$$\n\n# 2.4 Model training\n\nLoss function During model training, we minimize the following negative log likelihood of the predicted ratings  $\\check{M}_{ij}$ :\n\n$$\n\\mathcal {L} = - \\sum_ {i, j; \\boldsymbol {\\Omega} _ {i j} = 1} \\sum_ {r = 1} ^ {R} I [ r = M _ {i j} ] \\log p (\\check {M} _ {i j} = r), \\tag {6}\n$$\n\nwith  $I[k = l] = 1$  when  $k = l$  and zero otherwise. The matrix  $\\Omega \\in \\{0,1\\}^{N_u\\times N_i}$  serves as a mask for unobserved ratings, such that ones occur for elements corresponding to observed ratings in  $M$ , and zeros for unobserved ratings. Hence, we only optimize over observed ratings.\n\nNode dropout In order for the model to generalize well to unobserved ratings, it is trained in a denoising setup by randomly dropping out all outgoing messages of a particular node, with a probability  $p_{\\text{dropout}}$ , which we will refer to as node dropout. Messages are rescaled after dropout as in [28]. In initial experiments we found that node dropout was more efficient in regularizing than message dropout. In the latter case individual outgoing messages are dropped out independently, making embeddings more robust against the presence or absence of single edges. In contrast, node dropout also causes embeddings to be more independent of particular user or item influences. We furthermore also apply regular dropout [28] to the hidden layer units (3).\n\nMini-batching We introduce mini-batching by sampling contributions to the loss function in Eq. (6) from different observed ratings. That is, we sample only a fixed number of contributions from the sum over user and item pairs. By only considering a fixed number of contributions to the loss function, we can remove respective rows of users and items in  $M_{1}, \\ldots, M_{R}$  in Eq. (7) that do not appear in the current batch. This serves both as an effective means of regularization, and reduces the memory requirement to train the model, which is necessary to fit the full model for MovieLens-10M into GPU memory. We experimentally verified that training with mini-batches and full batches leads to comparable results for the MovieLens-1M dataset while adjusting for regularization parameters. For all datasets except for the MovieLens-10M, we opt for full-batch training since it leads to faster convergence than training with mini-batches in this particular setting.\n\n# 2.5 Vectorized implementation\n\nIn practice, we can use efficient sparse matrix multiplications, with complexity linear in the number of edges, i.e.  $\\mathcal{O}(|\\mathcal{E}|)$ , to implement the graph auto-encoder model. The graph convolutional encoder (Eq. 3), for example in the case of left normalization, can be vectorized as follows:\n\n$$\n\\left[ \\begin{array}{c} U \\\\ V \\end{array} \\right] = f (X, M _ {1}, \\dots , M _ {R}) = \\sigma \\left(\\left[ \\begin{array}{c} H _ {u} \\\\ H _ {v} \\end{array} \\right] W ^ {T}\\right), \\tag {7}\n$$\n\n$$\n\\text {w i t h} \\quad \\left[ \\begin{array}{l} H _ {u} \\\\ H _ {v} \\end{array} \\right] = \\sigma \\left(\\sum_ {r = 1} ^ {R} D ^ {- 1} \\mathcal {M} _ {r} X W _ {r} ^ {T}\\right), \\tag {8}\n$$\n\n$$\n\\text {a n d} \\quad \\mathcal {M} _ {r} = \\left( \\begin{array}{c c} 0 & M _ {r} \\\\ M _ {r} ^ {T} & 0 \\end{array} \\right). \\tag {9}\n$$\n\nThe summation in (8) can be replaced with concatenation, similar to (2). In this case  $D$  denotes the diagonal node degree matrix with nonzero elements  $D_{ii} = |\\mathcal{N}_i|$ . Vectorization for an encoder with a symmetric normalization, as well as vectorization of the bilinear decoder, follows in an analogous manner. Note that it is only necessary to evaluate observed elements in  $\\check{M}$ , given by the mask  $\\Omega$  in Eq. 6.\n\n# 2.6 Input feature representation and side information\n\nFeatures containing information for each node, such as content information, can in principle be injected into the graph encoder directly at the input-level (i.e. in the form of an input feature matrix  $X$ ). However, when the content information does not contain enough information to distinguish different users (or items) and their interests, feeding the content information directly into the graph convolution layer leads to a severe bottleneck of information flow. In such cases, one can include side information in the form of user and item feature vectors  $x_{i}^{f}$  (for node  $i$ ) via a separate processing channel directly into the the dense hidden layer:\n\n$$\nu _ {i} = \\sigma \\left(W h _ {i} + W _ {2} ^ {f} f _ {i}\\right) \\quad \\text {w i t h} \\quad f _ {i} = \\sigma \\left(W _ {1} ^ {f} x _ {i} ^ {f} + b\\right), \\tag {10}\n$$\n\nwhere  $W_1^f$  and  $W_2^f$  are trainable weight matrices, and  $b$  is a bias. The weight matrices and bias vector are different for users and items. The input feature matrix  $X = [x_1^T, \\ldots, x_N^T]^T$  containing the node features for the graph convolution layer is then chosen as an identity matrix, with a unique one-hot vector for every node in the graph. For the datasets considered in this paper, the user (item) content information is of limited size, and we thus opt to include this as side information while using Eq. (10).\n\nIn [29], Strub et al. propose to include content information along similar lines, although in their case the proposed model is strictly user- or item-based, and thus only supports side information for either users or items.\n\nNote that side information does not necessarily need to come in the form of per-node feature vectors, but can also be provided in the form of, e.g., graph-structured, natural language, or image data. In this case, the dense layer in (10) is replaced by an appropriate differentiable module, such as a recurrent neural network, a convolutional neural network, or another graph convolutional network.\n\n# 2.7 Weight sharing\n\nIn the collaborative filtering setting with one-hot vectors as input, the columns of the weight matrices  $W_{r}$  play the role of latent factors for each separate node for one specific rating value  $r$ . These latent factors are passed onto connected user or item nodes through message passing. However, not all users and items necessarily have an equal number of ratings for each rating level. This results in certain columns of  $W_{r}$  to be optimized significantly less frequently than others. Therefore, some form of weight sharing between the matrices  $W_{r}$  for different  $r$  is desirable to alleviate this optimization problem. Following [32], we therefore implement the following weight sharing setup:\n\n$$\nW _ {r} = \\sum_ {s = 1} ^ {r} T _ {s}. \\tag {11}\n$$\n\nWe will refer to this type of weight sharing as ordinal weight sharing due to the increasing number of weight matrices included for higher rating levels.\n\nAs an effective means of regularization of the pairwise bilinear decoder, we resort to weight sharing in the form of a linear combination of a set of basis weight matrices  $P_{s}$ :\n\n$$\nQ _ {r} = \\sum_ {s = 1} ^ {n _ {b}} a _ {r s} P _ {s}, \\tag {12}\n$$\n\nwith  $s \\in (1, \\dots, n_b)$  and  $n_b$  being the number of basis weight matrices. Here,  $a_{rs}$  are the learnable coefficients that determine the linear combination for each decoder weight matrix  $Q_r$ . Note that in order to avoid overfitting and to reduce the number of parameters, the number of basis weight matrices  $n_b$  should naturally be lower than the number of rating levels.",
  "experiments": "# 4 Experiments\n\nWe evaluate our model on a number of common collaborative filtering benchmark datasets: MovieLens $^2$  (100K, 1M, and 10M), Flixster, Douban, and YahooMusic. The datasets consist of user ratings for items (such as movies) and optionally incorporate additional user/item information in the form of features. For Flixster, Douban, and YahooMusic we use preprocessed subsets of these datasets provided by  $[22]^3$ . These datasets contain sub-graphs of 3000 users and 3000 items and their respective user-user and item-item interaction graphs (if available). Dataset statistics are summarized in Table 1.\n\nFor all experiments, we choose from the following settings based on validation performance: accumulation function (stack vs. sum), whether to use ordinal weight sharing in the encoder, left vs. symmetric normalization, and dropout rate  $p_{\\mathrm{dropout}} \\in \\{0.3, 0.4, 0.5, 0.6, 0.7, 0.8\\}$ . Unless otherwise noted, we use a Adam [13] with a learning rate of 0.01, weight sharing in the decoder with 2 basis weight matrices, and layer sizes of 500 and 75 for the graph convolution (with ReLU) and dense layer (no activation function), respectively. We evaluate our model on the held out test sets using an exponential moving average of the learned model parameters with a decay factor set to 0.995.\n\nMovieLens 100K For this task, we compare against matrix completion baselines that make use of side information in the form of user/item features. We report performance on the canonical u1.base/u1.test train/test split. Hyperparameters are optimized on a 80/20 train/validation split of the original training set. Side information is present both for users (e.g. age, gender, and occupation) and movies (genres). Following Rao et al. [25], we map the additional information onto feature vectors for users and movies, and compare the performance of our model with (GC-MC+Feat) and without the inclusion of these features (GC-MC). Note that GMC [12], GRALS [25] and sRGCNN [22] represent user/item features via a k-nearest-neighbor graph. We use stacking as an accumulation function in the graph convolution layer in Eq. (2), set dropout equal to 0.7, and use left normalization. GC-MC+Feat uses 10 hidden units for the dense side information layer (with ReLU activation) as described in Eq. 10. We train both models for 1,000 full-batch epochs. We report RMSE scores averaged over 5 runs with random initializations<sup>4</sup>. Results are summarized in Table 2.\n\nMovieLens 1M and 10M We compare against current state-of-the-art collaborative filtering algorithms, such as AutoRec [27], Llorma [17], and CF-NADE [32]. Results are reported as averages over the same five  $90/10$  training/test set splits as in [32] and summarized in Table 4. Model choices are validated on an internal  $95/5$  split of the training set. For ML-1M we use accumulate messages through summation in Eq. (2), use a dropout rate of 0.7, and symmetric normalization. As ML-10M has twice the number of rating classes, we use twice the number of basis function matrices in the decoder. Furthermore, we use stacking accumulation, a dropout of 0.3 and symmetric normalization. We train for 3,500 full-batch epochs, and 18,000 mini-batch iterations (20 epochs with batch size 10,000) on the ML-1M and ML-10M dataset, respectively.\n\nFlixster, Douban and YahooMusic These datasets contain user and item side information in the form of graphs. We integrate this graph-based side information into our framework by using the adjacency vector (normalized by degree) as a feature vector for the respective user/item. For a single dense feature embedding layer, this is equivalent to performing a graph convolution akin to [15] on the user-user or item-item graph. We use a dropout rate of 0.7, and 64 hidden units for the dense side information layer (with\n\n<table><tr><td>Dataset</td><td>Users</td><td>Items</td><td>Features</td><td>Ratings</td><td>Density</td><td>Rating levels</td></tr><tr><td>Flixster</td><td>3,000</td><td>3,000</td><td>Users/Items</td><td>26,173</td><td>0.0029</td><td>0.5, 1, ..., 5</td></tr><tr><td>Douban</td><td>3,000</td><td>3,000</td><td>Users</td><td>136,891</td><td>0.0152</td><td>1, 2, ..., 5</td></tr><tr><td>YahooMusic</td><td>3,000</td><td>3,000</td><td>Items</td><td>5,335</td><td>0.0006</td><td>1, 2, ..., 100</td></tr><tr><td>MovieLens 100K (ML-100K)</td><td>943</td><td>1,682</td><td>Users/Items</td><td>100,000</td><td>0.0630</td><td>1, 2, ..., 5</td></tr><tr><td>MovieLens 1M (ML-1M)</td><td>6,040</td><td>3,706</td><td>—</td><td>1,000,209</td><td>0.0447</td><td>1, 2, ..., 5</td></tr><tr><td>MovieLens 10M (ML-10M)</td><td>69,878</td><td>10,677</td><td>—</td><td>10,000,054</td><td>0.0134</td><td>0.5, 1, ..., 5</td></tr></table>\n\nReLU activation) as described in Eq. 10. We use a left normalization, and messages in the graph convolution layer are accumulated by concatenation (as opposed to summation). All models are trained for 200 epochs. For hyperparameter selection, we set aside a separate  $80/20$  train/validation split from the original training set in [22]. For final model evaluation, we train on the full original training set from [22] and report test set performance. Results are summarized in Table 3.\n\nTable 1: Number of users, items and ratings for each of the MovieLens datasets used in our experiments. We further indicate rating density and rating levels.  \n\n<table><tr><td>Model</td><td>ML-100K + Feat</td></tr><tr><td>MC [3]</td><td>0.973</td></tr><tr><td>IMC [11, 31]</td><td>1.653</td></tr><tr><td>GMC [12]</td><td>0.996</td></tr><tr><td>GRALS [25]</td><td>0.945</td></tr><tr><td>sRGCNN [22]</td><td>0.929</td></tr><tr><td>GC-MC (Ours)</td><td>0.910</td></tr><tr><td>GC-MC+Feat</td><td>0.905</td></tr></table>\n\nCold-start analysis To gain insight into how the GC-MC model makes use of side information, we study the performance of our model in the presence of users with only very few ratings (cold-start users). We adapt the ML-100K benchmark dataset, so that for a fixed number of cold-start users  $N_{c}$  all ratings except for a minimum number  $N_{r}$  are removed from the training set (chosen at random with a fixed seed across experiments). Note that ML-100K in its original form contains only users with at least 20 ratings.\n\nWe analyze model performance for  $N_{r}\\in \\{1,5,10\\}$  and\n\nTable 2: RMSE scores<sup>6</sup> for the MovieLens 100K task with side information on a canonical 80/20 training/test set split. Side information is either presented as a nearest-neighbor graph in user/item feature space or as raw feature vectors. Baseline numbers are taken from [22].  \n\n<table><tr><td>Model</td><td>Flixster</td><td>Douban</td><td>YahooMusic</td></tr><tr><td>GRALS</td><td>1.313/1.245</td><td>0.833</td><td>38.0</td></tr><tr><td>sRGCNN</td><td>1.179/0.926</td><td>0.801</td><td>22.4</td></tr><tr><td>GC-MC</td><td>0.941/0.917</td><td>0.734</td><td>20.5</td></tr></table>\n\nTable 3: Average RMSE test set scores for 5 runs on Flixster, Douban, and YahooMusic, all of which include side information in the form of user and/or item graphs. We replicate the benchmark setting as in [22]. For Flixster, we show results for both user/item graphs (right number) and user graph only (left number). Baseline numbers are taken from [22].  \n\n<table><tr><td>Model</td><td>ML-1M</td><td>ML-10M</td></tr><tr><td>PMF [20]</td><td>0.883</td><td>-</td></tr><tr><td>I-RBM [26]</td><td>0.854</td><td>0.825</td></tr><tr><td>BiasMF [16]</td><td>0.845</td><td>0.803</td></tr><tr><td>NNMF [7]</td><td>0.843</td><td>-</td></tr><tr><td>LLORMA-Local [17]</td><td>0.833</td><td>0.782</td></tr><tr><td>I-AUTOREC [27]</td><td>0.831</td><td>0.782</td></tr><tr><td>CF-NADE [32]</td><td>0.829</td><td>0.771</td></tr><tr><td>GC-MC (Ours)</td><td>0.832</td><td>0.777</td></tr></table>\n\nTable 4: Comparison of average test RMSE scores on five 90/10 training/test set splits (as in [32]) without the use of side information. Baseline scores are taken from [32]. For CF-NADE, we report the best-performing model variant.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-15/3b58f52b-f3b2-4d6b-b67e-cfa8026fc2c7/e6400a4014927213b7b5b31a8521f6ebbd75cf5701e5a946d1f02ef46c937ce6.jpg)  \nFigure 3: Cold-start analysis for ML-100K. Test set RMSE (average over 5 runs with random initialization) for various settings, where only a small number of ratings  $N_{r}$  is kept for a certain number of cold-start users  $N_{c}$  during training. Standard error is below 0.001 and therefore not shown. Dashed and solid lines denote experiments without and with side information, respectively.\n\n$N_{c} \\in \\{0, 50, 100, 150\\}$ , both with and without using user/item features as side information (see Figure 3). Hyperparameters and test set are chosen as before, i.e. we report RMSE on the complete canonical test set split. The benefit of incorporating side information, such as user and item features, is especially pronounced in the presence of many users with only a single rating\n\nDiscussion On the ML-100K task with side information, our model outperforms related methods by a significant margin. Remarkably, this is even the case without the use of side information. Most related to our method is sRGCNN by Monti et al. [22] that uses graph convolutions on the nearest-neighbor graphs of users and items, and learns representations in an iterative manner using recurrent neural networks. Our results demonstrate that a direct estimation of the rating matrix from learned user/item representations using a simple decoder model can be more effective, while being computationally more efficient.\n\nOur results on ML-1M and ML-10M demonstrate that it is possible to scale our method to larger datasets, putting it into the vicinity of recent state-of-the-art collaborative filtering user- or item-based methods in terms of predictive performance. At this point, it is important to note that several techniques introduced in CF-NADE [32], such as layer-specific learning rates, a special ordinal loss function, and the auto-regressive modeling of ratings, can be seen as orthogonal to our approach and can be used in conjunction with our framework.\n\nFor the Flixster, Douban, and YahooMusic datasets our\n\nmodel achieves state-of-the-art results, while using a single hyperparameter setting across all three datasets.\n",
  "hyperparameter": "Learning rate: 0.01 (Adam optimizer); Graph convolution layer size: 500 (with ReLU activation); Dense layer size: 75 (no activation); Number of basis weight matrices in decoder: 2; Exponential moving average decay factor: 0.995; Node dropout rate: 0.3-0.8 (dataset-dependent: 0.7 for ML-100K and ML-1M, 0.3 for ML-10M); Side information dense layer hidden units: 10 for ML-100K, 64 for Flixster/Douban/YahooMusic; Training epochs: 1,000 for ML-100K, 3,500 for ML-1M, 200 for Flixster/Douban/YahooMusic; Mini-batch size: 10,000 for ML-10M (20 epochs = 18,000 iterations); Normalization: left or symmetric normalization (dataset-dependent); Accumulation function: stack or sum (dataset-dependent)"
}