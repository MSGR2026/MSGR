{
  "id": "SimpleX_2021",
  "paper_title": "SimpleX: A Simple and Strong Baseline for Collaborative Filtering",
  "alias": "SimpleX",
  "year": 2021,
  "domain": "Recsys",
  "task": "GeneralRecommendation",
  "idea": "SimpleX proposes a cosine contrastive loss (CCL) that uses cosine similarity instead of dot product, incorporates a margin mechanism to filter uninformative negative samples, and balances positive/negative losses with a weight parameter. Combined with a simple architecture that aggregates user behavior sequences (via average pooling, self-attention, or user-attention), SimpleX demonstrates that proper loss function design and negative sampling are more important than complex encoders for collaborative filtering, achieving state-of-the-art performance with a much simpler model than GNN-based approaches.",
  "introduction": "# 1 INTRODUCTION\n\nNowadays, personalized recommendation is ubiquitous in various applications, such as video recommendation in YouTube [5], product recommendation in Amazon [24], and news recommendation in Bing [34]. The goal of recommendation is to predict whether a user will interact (e.g., click or purchase) with an item and thus help users discover potential items of interests. Collaborative filtering (CF) [27] is a fundamental task in recommendation that leverages the collaborative information among users and items to predict users' preferences on candidate items. The simplicity and effectiveness make it one of the most popular techniques in recommender systems.\n\nGenerally, the learning process of a CF model can be separated to three major components, including interaction encoder, loss function, and the negative sampling strategy used when only positive (i.e., implicit) feedbacks are available. Most existing studies focus on the design of more powerful interaction encoders to capture collaborative signals among users and items. Especially, the prevalence of deep learning motivates a rich line of work that applies various neural networks to CF, including multi-layer perceptrons (MLPs) [5, 11], auto-encoders [16], attention networks [3], transformers [28], graph neural networks (GNNs) [10], and so on. Nevertheless, these models tend to become more and more complex to show performance improvements. This somehow limits their practical applicability in industrial recommender systems that demand high efficiency.\n\nOn the contrary, few research efforts have been devoted to investigating the impacts of the latter two components. Specifically, while multiple loss functions have been used in CF, such as Bayesian personalized ranking (BPR) loss [22], binary cross-entropy loss [11], softmax cross-entropy loss [5], pairwise hinge loss [12], and mean square error loss [2], there is still a lack of systematic evaluation and comparisons among different loss functions. Furthermore, many recent GNN-based studies [10, 29, 30, 32, 33] experiment with the BPR loss [22] and simply set the negative sampling ratio to a small value (i.e., sampling 1 or 10 negative samples per positive user-item pair). In this way, they can justify the superiority of their\n\nproposed interaction encoders, but they neglect the importance of loss functions and negative sampling in the learning of CF models.\n\nIn fact, we empirically observed that training with the BPR loss and a small negative sampling ratio results in inferior results for many CF models. In this paper, we show that choosing a suitable loss function and a proper number of negative samples plays an equal or more important role than an interaction encoder. Towards this goal, we systematically compare multiple commonly-used loss functions and also investigate the impact of negative sampling ratio on each loss function. Moreover, inspired by the widely used contrastive loss [8, 38] in computer vision, we propose a cosine contrastive loss (CCL) tailored for CF. Our CCL loss optimizes the embedding by maximizing the cosine similarity of a positive user-item pair, while minimizing the similarity of a negative pair to a certain margin. Surprisingly, we found that even a simple model (e.g., MF), if paired with our proposed CCL loss, is sufficient to surpass many sophisticated state-of-the-art models.\n\nThese findings raise questions about whether the current baselines are strong enough to verify the performance improvements of the state-of-the-art CF models, and how much these sophisticated models have really improved. Our work aims to answer these questions. We argue that the current baselines might not be strong enough, which could mislead us to overestimate the real improvements of many new CF models. Instead of criticizing the contributions of any existing work, the main goal of our work is to build a simple and strong baseline model to foster future research on CF.\n\nIn the design of SimpleX, we keep simplicity in mind and borrow ideas from several existing studies (e.g., average pooling in YouTubeNet [5], attention in ACF [3]). We build Simplex as a unified model that integrates matrix factorization and user behaviour modeling. Specifically, it comprises a behavior aggregation layer (e.g., average pooling) to obtain a user's preference vector from the historically interacted items, and then fuses with the user embedding vector via a weighted sum. More importantly, SimpleX is optimized with our CCL loss and a large negative sampling ratio. Although the interaction encoder of SimpleX seems quite simple and might not be novel at all, we show that it could serve as a super-strong baseline model and have great potential for industrial applications because of its high efficiency.\n\nFor evaluation, we conduct comprehensive experiments on 11 benchmark datasets in total and compare with a total of 29 popular CF models of different types. The results show that SimpleX outperforms most sophisticated state-of-the-art methods by a large margin (up to  \\(48.5\\%\\)  improvement in NDCG@20 over LightGCN [10] on Amazon-Books). We also empirically compare the performance of six representative loss functions and investigate the impact of different negative sampling ratios on each loss function, which demonstrates the superiority of our proposed CCL loss for CF tasks. Furthermore, we evaluate the efficiency of SimpleX, which shows more than 10x speedup over the simplified GNN-based CF model, LightGCN [10]. We hope that our work could not only serve as a simple and strong baseline to foster future research on CF, but also attract more research efforts towards the co-design of interaction encoders, loss functions, and negative sampling strategies.\n\nThe main contributions of our work are summarized as follows:\n\n- We highlight the importances of loss functions and negative sampling in CF, and propose the cosine contrastive loss accordingly.  \n- We present a simple and strong baseline model, SimpleX, which could even attain much better performance than most sophisticated state-of-the-art models.  \n- We perform experiments on 11 benchmark datasets and compare SimpleX with 29 existing CF models to show its superiority in terms of both effectiveness and efficiency.\n",
  "method": "# 3 SIMPLEX\n\nIn this section, we first present our cosine contrastive loss and the SimpleX model architecture for CF. We then analyze its connections to other existing models.\n\n## 3.1 Cosine Contrastive Loss\n\nIn the CF literature, many different loss functions have been employed, including BPR loss [22], binary cross-entropy [11], softmax\n\ncross-entropy [5], pairwise hinge loss [12], etc. However, there is still a lack of a systematic comparison among them, leaving their effects on model performance not well understood. In this work, we not only make such a comparison, but also propose a new loss function for CF, namely cosine contrastive loss (CCL). Given a positive user-item pair  \\((u,i)\\)  and a set of randomly sampled negative samples (i.e.,  \\(\\mathcal{N}\\) ), the CCL loss is expressed as follows:\n\n\\[\n\\mathcal {L} _ {C C L} (u, i) = \\left(1 - \\hat {y} _ {u i}\\right) + \\frac {w}{| \\mathcal {N} |} \\sum_ {j \\in \\mathcal {N}} \\max  (0, \\hat {y} _ {u j} - m) \\tag {1}\n\\]\n\nwhere  \\(\\hat{y}_{ui}\\)  calculates the cosine similarity between the representation vectors of user  \\(u\\)  and item  \\(i\\) .  \\(|\\mathcal{N}|\\)  denotes the number of negative samples.  \\(m\\)  is the margin to filter negative samples, which is usually set to  \\(0\\sim 1\\) . Intuitively, CCL is optimized to maximize the similarity between positive pairs and minimize the similarity of negative pairs below the margin  \\(m\\) .  \\(w\\)  is a hyper-parameter to control the relative weights of positive-sample loss and negative-sample loss.\n\nDesign Choices. The formulation of CCL is simple and largely inspired by the widely used contrastive loss [8, 38] in the computer vision tasks, such as face recognition and image retrieval. But we make several design choices that differ from most widely-used loss functions in CF and greatly facilitate model training. First, instead of applying dot product (e.g., in LightGCN [10]) or Euclidean distance (e.g., in CML [12]) to measure the similarity (or distance) between a user-item pair, we choose to compute the cosine similarity between them. By applying L2 normalization on both representation vectors, cosine similarity only calculates the angle difference and thus avoid the effect of representation magnitude. This is favorable since the magnitude of a user/item representation could be strongly biased by its popularity in CF tasks. This is also similar to the calculation of word similarity in Word2Vec [20], where cosine similarity is usually used.\n\nSecond, when the number of negative samples becomes large, there usually exist many redundant yet uninformative samples. But existing loss functions (e.g., BPR [22]) treat every negative sample equivalently. As such, model training could be overwhelmed by these uninformative samples, which significantly degrade the model performance and also slows the convergence. In contrast, CCL alleviates this problem by using a proper margin  \\(m\\)  to filter uninformative negative samples. Intuitively, uninformative negative samples will get zero loss in CCL when they have a small cosine similarity below the margin  \\(m\\) . As a result, it helps automatically identify those hard negative samples with cosine similarity larger than  \\(m\\) , and thus facilitates better training of the model.\n\nThird, we found that directly summing or averaging the loss terms of all negative samples could degrade the model performance, especially when the number of negative samples is large. This is partially due to the high imbalance between positive and negative samples (e.g., 1:1000 when  \\(|\\mathcal{N}| = 1000\\) ). We thus introduce a data-dependent weight  \\(w\\)  to control the balance between positive loss and negative loss. We emphasize that it also achieves a similar effect to the confidence weight imposed on negative samples in weighted matrix factorization [13].\n\n## 3.2 Model Architecture\n\nTo leverage the advantages of CCL, we further propose a simple CF model, dubbed SimpleX. In the design of SimpleX, we keep\n\n![](images/38f1363436642e5d96a6193d5f3cf49c525950690543d8fba22f1614b163d69a.jpg)  \nFigure 1: The Simple Model Architecture of SimpleX.\n\nsimplicity in mind and borrow ideas from several successful models such as YouTubeNet [5], ACF [3], and PinSage [39].\n\nFigure 1 illustrates the overall architecture of SimpleX. It largely follows the mechanism of MF, which factorizes users and items into a common latent space. Yet, SimpleX also takes the interacted item sequence of each user as additional input to better model user behaviors. This also has been shown effective in many existing studies, such as YouTubeNet [5] and ACF [3]. The key part of SimpleX lies in its aggregation layer for behavior sequence aggregation. Here we introduce three common aggregation choices, including average pooling, self-attention, and user-attention, but Simplex is a unified architecture that any other aggregation method should also be applicable.\n\nSuppose the historically interacted item set of user  \\(u\\)  as  \\(\\mathcal{H}_u\\) , and we set its maximal size to  \\(K\\) . For users with a different size of interacted items, either padding or chunking can be applied accordingly. As such, the aggregated vector can be obtained as follows:\n\n\\[\np _ {u} = \\sum_ {k \\in \\mathcal {H} _ {u}} I _ {k} \\cdot \\alpha_ {k} \\boldsymbol {e} _ {k}, \\tag {2}\n\\]\n\nwhere  \\(e_k \\in \\mathbb{R}^{d \\times 1}\\)  is the  \\(d\\) -dimensional embedding vector of item  \\(k\\) .  \\(I_k\\)  denotes the mask indices to  \\(\\mathcal{H}_u\\)  during padding, where  \\(I_k = 0\\)  indicates a padding token; otherwise  \\(I_k = 1\\) .  \\(\\alpha_k\\)  denotes the aggregation weight, which can be computed according to different aggregation types as follows.\n\n\\[\n\\alpha_ {k} = \\left\\{ \\begin{array}{l l} \\frac {I _ {k}}{\\sum_ {k \\in \\mathcal {H} _ {u}} I _ {k}}, & \\text {i f a v e r a g e p o o l i n g ,} \\\\ \\frac {I _ {k} \\cdot \\exp (\\beta_ {k})}{\\sum_ {j \\in \\mathcal {H} _ {u}} I _ {k} \\cdot \\exp (\\beta_ {j})}, & \\text {i f s e l f - a t t e n t i o n o r u s e r - a t t e n t i o n .} \\end{array} \\right. \\tag {3}\n\\]\n\nAverage pooling provides a straightforward way to aggregate the interacted items, which has been successfully applied in YouTubeNet [5]. But it treats each item equally and fails to account for the relative importances of different items as well as a user's preference on each item. The attention mechanism, such as self-attention and user-attention, can be applied in such cases as calculated in the lower part of Equation 3. The difference between them lies in the computation of  \\(\\beta_{k}\\) , which is:\n\n\\[\n\\beta_ {k} = \\left\\{ \\begin{array}{l l} q ^ {T} \\operatorname {t a n h} \\left(\\boldsymbol {W} _ {1} e _ {k} + b _ {1}\\right), & \\text {i f s e l f - a t t e n t i o n ,} \\\\ e _ {u} ^ {T} \\operatorname {t a n h} \\left(\\boldsymbol {W} _ {2} \\times e _ {k} + b _ {2}\\right), & \\text {i f u s e r - a t t e n t i o n .} \\end{array} \\right. \\tag {4}\n\\]\n\nwhere  \\(q \\in \\mathbb{R}^{d \\times 1}\\)  is a learnable global query vector for self-attention and  \\(e_{u}\\)  is the user-specific query vector for user  \\(u\\)  in user-attention.  \\(W_{1}, W_{2} \\in \\mathbb{R}^{d \\times d}\\)  and  \\(b_{1}, b_{2} \\in \\mathbb{R}^{d \\times 1}\\)  are learnable parameters. Note that similar attention mechanisms can be found in some existing work [3, 34].\n\nHowever, after behavior aggregation via Equation 2, the pooling vector  \\(p_u\\)  may lie in a different latent space with user vector  \\(e_u\\) . We further fuse both parts to get the final user representation  \\(h_u\\) :\n\n\\[\nh _ {u} = g \\cdot e _ {u} + (1 - g) \\cdot V p _ {u} \\tag {5}\n\\]\n\nwhere  \\(V \\in \\mathbb{R}^{d \\times d}\\)  is a learnable parameter and  \\(g\\)  is a hyperparameter weight. Finally, we measure the cosine similarity  \\(\\hat{y}_u i\\)  between user  \\(u\\)  and item  \\(i\\)  as the input to our CCL loss.\n\n\\[\n\\hat {y} _ {u i} = \\cos \\left(h _ {u}, e _ {i}\\right) \\tag {6}\n\\]\n\nThe above three aggregation layers provide different views for aggregation, including global-average view, global-weighed view and user-specific weighted view. The choice among them is quite data-dependent. In our experiment, we show that average-pooling is a robust aggregation method that always demands a first attempt when applying SimpleX. The other two usually needs more efforts to tune and in some cases brings marginal improvements.\n\n## 3.3 Relationships to Existing Models\n\nSimpleX is also related to multiple popular CF models.\n\n- MF. MF is the most common model for CF. SimpleX follows the similar mechanism of MF. When setting  \\(\\mathrm{g} = 1\\)  in SimpleX, it reduces to a MF model trained with CCL (i.e., MF-CCL).  \n- YouTubeNet. YouTubeNet is a successful model that has been widely used in industry. SimpleX can be also seen as a simplified YouTubeNet model (without using side features) when average pooling is employed. The only difference is that YouTubeNet employs concatenation instead of weighted sum to fuse  \\(e_{u}\\)  and  \\(p_{u}\\) . But the latter performs better in our experiments.  \n- GNN-based models. Simplex is also similar to GNN-based models. For instance, when choosing the user-attention aggregation layer, it almost equals to a graph attention (GAT) layer applied on user nodes only. If using the self-attention aggregation layer, it works like the neighbor interaction in NIA-GCN [30] as well.\n\nWe emphasize that although the design of SimpleX is simple and might not be novel to some extent, it unifies several key components in existing CF models. Surprisingly, such a simple model is sufficient to surpass most state-of-the-art CF models by a large margin, which could serve as simple and strong baseline for future research.\n",
  "experiments": "# 4 EXPERIMENTS\n\nIn this section, we conduct comprehensive experiments to evaluate SimpleX, including: 1) studying the impacts of loss functions and negative sampling ratios, 2) making performance comparisons to existing models on three main datasets, 3) incorporating CCL to other models, 4) performing parameter analysis and efficiency evaluation, 5) further validating SimpleX on some other datasets.\n\nTable 1: Performance of MF under different loss functions. The best result in each column is marked in bold.  \n\n<table><tr><td rowspan=\"2\">Loss</td><td colspan=\"2\">AmazonBooks</td><td colspan=\"2\">Yelp18</td><td colspan=\"2\">Gowalla</td></tr><tr><td>Recall@20</td><td>NDCG@20</td><td>Recall@20</td><td>NDCG@20</td><td>Recall@20</td><td>NDCG@20</td></tr><tr><td>BPR Loss</td><td>0.0338</td><td>0.0261</td><td>0.0549</td><td>0.0445</td><td>0.1616</td><td>0.1366</td></tr><tr><td>Pairwise Hinge Loss</td><td>0.0352</td><td>0.0267</td><td>0.0562</td><td>0.0453</td><td>0.1318</td><td>0.0996</td></tr><tr><td>Binary Cross-Entropy</td><td>0.0479</td><td>0.0371</td><td>0.0617</td><td>0.0503</td><td>0.1321</td><td>0.1159</td></tr><tr><td>Softmax Cross-Entropy</td><td>0.0478</td><td>0.0367</td><td>0.0639</td><td>0.0522</td><td>0.1545</td><td>0.1276</td></tr><tr><td>Mean Square Error</td><td>0.0337</td><td>0.0267</td><td>0.0624</td><td>0.0513</td><td>0.1528</td><td>0.1315</td></tr><tr><td>Cosine Contrastive Loss</td><td>0.0559</td><td>0.0447</td><td>0.0698</td><td>0.0572</td><td>0.1837</td><td>0.1493</td></tr></table>\n\n## 4.1 Experimental Setup\n\n4.1.1 Dataset. We use 11 benchmark datasets in our study. For fairness and ease of comparison, we choose those open datasets that have been already split and preprocessed. Specifically:\n\n(1) We employ three main datasets Amazon-Books, Yelp2018, and Gowalla, which are commonly used in recent GNN-based CF models [4, 10, 25, 32, 33, 35]. We perform most of our experiments on them and further make comparisons to these GNN-based models.\n\n(2) To demonstrate the universality of SimpleX, we further test SimpleX on some other datasets adopted by studies published in top-tier conferences. Three of them, Amazon-CDs, Amazon-Movies, Amazon-Beauty, are adopted by the work NIA-GCN [30] and BGCF [29]. The other three, Amazon-Electronics, CiteUlike-A, and Movielens-1M, are provided by NBPO [41], DHCF [14], and LCFN [40], respectively. Specifically, we compare SimpleX with the corresponding models on the corresponding datasets that adopted in their original papers. For example, we will compare with DHCF [14] on CiteUlike-A dataset because DHCF adopts this dataset in their original paper.\n\n(3) The last two are Movielens-20M and MillionSongData, which are commonly used by autoencoder-based CF models, such as Mult-VAE [16] and RecVAE [23]. We follow the strong generalization setting, which split train/validation/test sets with different sets of users, and specially make comparison with those autoencoder-based CF models to further demonstrate the effectiveness of SimpleX.\n\n4.1.2 Compared Methods. We compare SimpleX with 29 existing CF models of different types:\n\n- Five methods based on MF and its variants, including MF-BPR [15], GRMF [19], HOP-Rec [37], NeuMF [11], and ENMF [2];  \n- Four autoencoder-based methods, including Mult-VAE [16], MacridVAE [18], EASER [26], and RecVAE [23];  \n- Fourteen GNN-based methods, including GC-MC [1], Pinspace [39], GAT [31], NGCF [32], DisenGCN [17], LR-GCCF [4], NIA-GCN [30], LightGCN [10], DGCF [33], NGAT4Rec [25], SGL-ED [35], BGCF [29], DHCF [14], and LCFN [40];  \n- Six methods of other types, including ItemPop, SLIM [21], CML [12], YouTubeNet [5], CMN [7], and NBPO [41].\n\n4.1.3 Implementation Details. We implement SimpleX in PyTorch. Specifically, we set the batch size to 1024 by default. We use the Adam optimizer and tune the learning rate among [1e-3, 5e-4, 1e-4]. We also employ  \\(L_{2}\\)  regularization on the embedding parameters and search the regularization weight between 1e-9~1e-2 with an\n\nincrease ratio of 5. For cosine contrastive loss, we search the number of negative samples from 1 to 2000. In many cases, we pick 100, 500, or 1000. The margin  \\(m\\)  is tuned among  \\(0\\sim 1\\)  at an interval of 0.1, for example, we set 0.4, 0.9, and 0.9 on Amazon-Books, Yelp2018, and Gowalla, respectively. Meanwhile, we use the same embedding size with the compared model, for example, 64 in LightGCN and 128 in LCFN. For fairness of comparison with existing models, we report the results using the same evaluation metrics (e.g., Recall@20 and NDCG@20) and duplicate the reported results on their papers for consistency. To facilitate reproducible research in the community, we have contributed our source code and detailed benchmark settings to the public Open-CF-Benchmark<sup>1</sup>.\n\n### 4.2 Impact of Different Loss Functions\n\nWhile most studies focus on the interaction encoder design, they neglect the importance of loss functions in the learning of a CF model. We make a systematic comparison on the impacts of different loss functions. For this purpose, we choose one of the simplest baseline CF models, i.e., MF, as the backbone to perform the experiments, since simple models tend to be more illustrative. In addition to our CCL loss, we evaluate MF on the following representative loss functions:\n\n- Bayesian personalized ranking (BPR) loss encourages the similarity of a positive user-item pair to be higher than that of each negative user-item pair. It is one of the most commonly used loss function for CF research [10, 22, 32, 33]  \n- Pairwise hinge loss (PHL), is also known as max-margin objective, which has been used in CML [12]. PHL forces the distance of a negative user-item pair to be larger than a positive one by at least the marginal distance.  \n- Binary cross-entropy (BCE) loss is commonly used for binary classification, which has been adopted in the early work NeuMF [11].  \n- Softmax cross-entropy (SCE) loss is widely used for multiclass classification. YouTubeNet [5] cast item prediction as a multi-class classification task through the SCE loss.  \n- Mean square error (MSE) has been widely used for CF, such as WMF [13] and ENMF [2].\n\nTable 1 shows the results of training MF with different loss functions on Amazon-Books, Yelp2018, and Gowalla. Note that every model has been trained with enough epochs to reach convergence and the best results are reported. From the results, we have the following observations:\n\n![](images/d8cc583c1a961da1f8797ae37efcb1f12b6b5dd8a1e114f150c225b4f6612d4f.jpg)  \nFigure 2: The effect of number of negative samples across different loss functions on Amazon-Books.\n\n1) CCL consistently achieves the best performance on all the three datasets, outperforming the other loss functions by at least  \\(16.7\\%\\) ,  \\(9.2\\%\\)  and  \\(13.7\\%\\)  w.r.t. Recall@20 on Amazon-Books, Yelp2018 and Gowalla, respectively.  \n2) BPR only appears to be strong on Gowalla and performs not well on both Amazon-Books and Yelp2018. This demonstrates that using BPR for training is probably sub-optimal, and thus the results reported by many previous papers may need careful re-examination and are likely to be further improved with our CCL loss.\n\nWhy CCL performs better than the other loss functions? In addition to the design choices analyzed in Section 3.1, we further highlight the advantages of CCL with some concrete comparisons. First, in contrast to BPR, BCE, SCE, and MSE, CCL can automatically filter out hard negative samples that are hard to distinguish (i.e., large cosine similarity) by the model via its margin mechanism. For example, if we set  \\(m = 0.8\\) , only those negative pairs with  \\(\\hat{y}_{ui} > 0.8\\)  will contribute to the loss. Different from the above loss functions that treat each negative sample equally, CCL allows the model to emphasize on the learning of hard negative samples and thus generate more discriminative representations. Second, compared with PHL that also applies a margin mechanism, CCL is more effective for CF. The PHL loss is determined by the relative distance between positive samples and negative samples. Even if a negative sample is actually hard to be distinguished (e.g.,  \\(\\hat{y}_{ui}^{\\text{neg}} = 0.8\\) ), it will not contribute to learning if the corresponding positive sample has  \\(\\hat{y}_{ui}^{\\text{pos}} = 0.9\\) . CCL avoids such ambiguity by penalizing the absolute similarity  \\(\\hat{y}_{ui}\\)  of each negative sample.\n\n### 4.3 Impact of Negative Sampling Ratio\n\nWe argue that negative sampling ratio is also important in the learning of CF models, which has been largely ignored by existing studies. To support our claims, we compare the performance of MF trained with  \\(1\\sim 2000\\)  negative samples on Amazon-Books. We also repeat the experiment on different loss functions. We train each model until convergence and report the best results, as shown in Figure 2. We have the following observations from the results:\n\n1) The number of negative samples does matter for CF model training. Generally, increasing it within a certain range leads to improvements. This suggests that we should carefully consider the impact of the number of negative samples in the evaluation.  \n2) MF trained with CCL is consistently better than training with the other loss functions under different negative sampling ratios, further demonstrating the superiority of our CCL.\n\n3) The performances of PHL, MSE, and BPR become stable when the number of negative samples increases to 50. In contrast, CCL, BCE, and SCE can keep performance gains with the increase of number of negative samples, even when it reaches to 1000.\n\nIn summary, our experimental results show that both loss functions and negative sampling ratios can have a large impact on model performance. Training with the CCL loss and a large negative sampling ratio appears to be a promising setting for CF methods to gain higher performance. We therefore call for more future research towards this direction.\n\n### 4.4 Performance Comparison to SOTA Models\n\nIn this section, we provide a comprehensive comparison results of SimpleX and other 23 CF models on three main datasets, i.e., Amazon-Books, Yelp2018, and Gowalla, which are very commonly adopted in CF studies (especially in GNN-based CF), to demonstrate the superiority of SimpleX. Table 2 shows our performance comparisons on Amazon-Books, Yelp2018, and Gowalla under the same evaluation protocol, and we have the following observations:  \n1) Our SimpleX achieves the best overall performance on all the three datasets. In particular, compared with the most recent LightGCN, SimpleX makes  \\(41.9\\%\\) ,  \\(8.0\\%\\) , and  \\(2.3\\%\\)  performance improvements on Recall@20 for Amazon-Books, Yelp2018, and Gowalla, respectively, demonstrating the high effectiveness of SimpleX. Besides, note that we do not report the results of SGL-ED [35] and NGAT4Rec [25] on Gowalla since they are not evaluated on Gowalla but only evaluated on the other two datasets in their original papers too, and the authors have not released their code. As the experimental settings of SGL-ED and NGAT4Rec are exactly same as us, we just report their results on Amazon-Books and Yelp2018.  \n2) The performance of MF-CCL is surprising. When using CCL as the loss function, the performance of MF is not only much better than the results of MF-BPR reported in the previous paper, but also reaches a new state-of-the-art performance (if leaving out our SimpleX) on Amazon-Books and Yelp2018. On Gowalla, it also achieves comparable performance compared to the previous best model DGCF. Such results strongly suggest that loss functions can make a big difference and should be carefully chosen and studied.  \n3) YouTubeNet, CML, and SLIM are three models that we added and have not been tested on these three datasets before by the existing work. We found that they achieve pretty good performance. Specifically, these three models can averagely outperform a representative GNN-based CF model - NGCF, by more than  \\(24\\%\\)  and  \\(28\\%\\)  w.r.t. Recall@20 and NDCG@20, respectively. This implies that the current baselines are relatively weak, which may lead us to overestimate how much real progress we have made in CF.  \n4) In CF tasks, more complex models not always lead to better performance. The designs of SLIM, YouTubeNet, CML, MF-CCL, and our SimpleX are all much more concise than most of autoencoder-based (e.g., Mult-VAE and MacridVAE) and GNN-based models (e.g., NGCF, NIA-GCN, and DGCF), but they can achieve better performance. This also reveals that the current trend in CF research, which pays too much attention to the design of sophisticated interaction encoders while ignoring the impacts of loss functions and negative sampling, needs to be improved.\n\nTable 2: Performance comparison to popular CF models. We highlight the top-5 best results in each column. RI stands for relative improvement. We also report the average RI over NGCF for each model if applicable. For models marked with *, part of the results are duplicated from existing papers for consistency.  \n\n<table><tr><td rowspan=\"2\">Publication</td><td rowspan=\"2\">Model</td><td colspan=\"2\">Amazon-Books</td><td colspan=\"2\">Yelp2018</td><td colspan=\"2\">Gowalla</td><td colspan=\"2\">Avg RI over NGCF</td></tr><tr><td>Recall@20</td><td>NDCG@20</td><td>Recall@20</td><td>NDCG@20</td><td>Recall@20</td><td>NDCG@20</td><td>Recall@20</td><td>NDCG@20</td></tr><tr><td>-</td><td>ItemPop</td><td>0.0051</td><td>0.0044</td><td>0.0124</td><td>0.0101</td><td>0.0416</td><td>0.0317</td><td>-</td><td>-</td></tr><tr><td>UAI&#x27;2009</td><td>MF-BPR</td><td>0.0338</td><td>0.0261</td><td>0.0576</td><td>0.0468</td><td>0.1627</td><td>0.1378</td><td>-</td><td>-</td></tr><tr><td>NIPS&#x27;2015</td><td>GRMF*</td><td>0.0354</td><td>0.0270</td><td>0.0571</td><td>0.0462</td><td>0.1477</td><td>0.1205</td><td>-</td><td>-</td></tr><tr><td>RecSys&#x27;2016</td><td>YouTubeNet</td><td>0.0502(4)</td><td>0.0388(4)</td><td>0.0686(3)</td><td>0.0567(3)</td><td>0.1754(5)</td><td>0.1473(5)</td><td>32.2%</td><td>33.3%</td></tr><tr><td>WWW&#x27;2017</td><td>NeuMF*</td><td>0.0258</td><td>0.0200</td><td>0.0451</td><td>0.0363</td><td>0.1399</td><td>0.1212</td><td>-</td><td>-</td></tr><tr><td>WWW&#x27;2017</td><td>CML</td><td>0.0522(3)</td><td>0.0428(3)</td><td>0.0622</td><td>0.0536</td><td>0.1670</td><td>0.1292</td><td>29.6%</td><td>37.6%</td></tr><tr><td>SIGIR&#x27;2018</td><td>CMN*</td><td>0.0267</td><td>0.0218</td><td>0.0457</td><td>0.0369</td><td>0.1405</td><td>0.1221</td><td>-</td><td>-</td></tr><tr><td>RecSys&#x27;2018</td><td>HOP-Rec*</td><td>0.0309</td><td>0.0232</td><td>0.0517</td><td>0.0428</td><td>0.1399</td><td>0.1214</td><td>-</td><td>-</td></tr><tr><td>WWW&#x27;2018</td><td>Mult-VAE*</td><td>0.0407</td><td>0.0315</td><td>0.0584</td><td>0.0450</td><td>0.1641</td><td>0.1335</td><td>9.6%</td><td>7.1%</td></tr><tr><td>NeurIPS&#x27;2019</td><td>MacridVAE*</td><td>0.0383</td><td>0.0295</td><td>0.0612</td><td>0.0495</td><td>0.1618</td><td>0.1202</td><td>8.5%</td><td>8.0%</td></tr><tr><td>TOIS&#x27;2020</td><td>ENMF</td><td>0.0359</td><td>0.0281</td><td>0.0624</td><td>0.0515</td><td>0.1523</td><td>0.1315</td><td>6.1%</td><td>7.4%</td></tr><tr><td colspan=\"10\">GNN-based Models</td></tr><tr><td>KDDW&#x27;2018</td><td>GC-MC*</td><td>0.0288</td><td>0.0224</td><td>0.0462</td><td>0.0379</td><td>0.1395</td><td>0.1204</td><td>-</td><td>-</td></tr><tr><td>KDD&#x27;2018</td><td>PinSage*</td><td>0.0282</td><td>0.0219</td><td>0.0471</td><td>0.0393</td><td>0.1380</td><td>0.1196</td><td>-</td><td>-</td></tr><tr><td>ICLR&#x27;2018</td><td>GAT*</td><td>0.0326</td><td>0.0235</td><td>0.0543</td><td>0.0431</td><td>0.1401</td><td>0.1236</td><td>-</td><td>-</td></tr><tr><td>SIGIR&#x27;2019</td><td>NGCF*</td><td>0.0344</td><td>0.0263</td><td>0.0579</td><td>0.0477</td><td>0.1570</td><td>0.1327</td><td>-</td><td>-</td></tr><tr><td>ICML&#x27;2019</td><td>DisenGCN*</td><td>0.0329</td><td>0.0254</td><td>0.0558</td><td>0.0454</td><td>0.1356</td><td>0.1174</td><td>-</td><td>-</td></tr><tr><td>AAAI&#x27;2020</td><td>LR-GCCF</td><td>0.0335</td><td>0.0265</td><td>0.0561</td><td>0.0343</td><td>0.1519</td><td>0.1285</td><td>-</td><td>-</td></tr><tr><td>SIGIR&#x27;2020</td><td>NIA-GCN*</td><td>0.0369</td><td>0.0287</td><td>0.0599</td><td>0.0491</td><td>0.1359</td><td>0.1106</td><td>6.9%</td><td>4.8%</td></tr><tr><td>SIGIR&#x27;2020</td><td>LightGCN*</td><td>0.0411</td><td>0.0315</td><td>0.0649</td><td>0.0530</td><td>0.1830(4)</td><td>0.1554(3)</td><td>15.8%</td><td>15.4%</td></tr><tr><td>SIGIR&#x27;2020</td><td>DGCF*</td><td>0.0422</td><td>0.0324</td><td>0.0654</td><td>0.0534</td><td>0.1842(2)</td><td>0.1561(1)</td><td>17.8%</td><td>17.6%</td></tr><tr><td>Arxiv&#x27;2020</td><td>NGAT4Rec*</td><td>0.0457</td><td>0.0358</td><td>0.0675(4)</td><td>0.0554(5)</td><td>-</td><td>-</td><td>24.7%</td><td>26.1%</td></tr><tr><td>SIGIR&#x27;2021</td><td>SGL-ED*</td><td>0.0478(5)</td><td>0.0379(5)</td><td>0.0675(4)</td><td>0.0555(4)</td><td>-</td><td>-</td><td>27.8%</td><td>30.2%</td></tr></table>\n\nOurs  \n\n<table><tr><td>CIKM&#x27;2021</td><td>MF-CCL</td><td>0.0559(2)</td><td>0.0447(2)</td><td>0.0698(2)</td><td>0.0572(2)</td><td>0.1837(3)</td><td>0.1493(4)</td><td>41.6%</td><td>45.0%</td></tr><tr><td>CIKM&#x27;2021</td><td>SimpleX</td><td>0.0583(1)</td><td>0.0468(1)</td><td>0.0701(1)</td><td>0.0575(1)</td><td>0.1872(1)</td><td>0.1557(2)</td><td>45.3%</td><td>49.2%</td></tr><tr><td colspan=\"2\">RI over NGCF</td><td>69.6%</td><td>77.9%</td><td>21.1%</td><td>20.6%</td><td>19.2%</td><td>17.3%</td><td></td><td></td></tr><tr><td colspan=\"2\">RI over LighGCN</td><td>41.9%</td><td>48.5%</td><td>8.0%</td><td>8.5%</td><td>2.3%</td><td>0.2%</td><td></td><td></td></tr></table>\n\n### 4.5 Incorporating CCL to Other Models\n\nIn Table 2, we have shown that one of the simplest models, i.e., MF, can even largely outperforms most of state-of-the-art models if training with CCL. We are curious about how other models will perform if incorporated with CCL instead of their original losses. Therefore, in this part, we take experiments with two effective CF models in addition, i.e., YouTubeNet and LightGCN with CCL, and report the results on Amazon-Books and Yelp2018 in Table 3.\n\nFrom the results, we find that training YouTubeNet and LightGCN with CCL instead of their original loss functions, i.e., SCE and BPR respectively, can bring good improvements. This demonstrates that CCL is likely to be a more promising loss function to help CF models achieve better performance. Besides, we observe that the improvements brought by CCL on YouTubeNet and LightGCN are not as significant as those on MF. CCL seems to improve these models to a similar level of performance. This may be because of the following reason: Generally, valuable collaborative information can be captured by both the interaction encoder and the loss function. As the encoders of YouTubeNet and LightGCN are sophisticated\n\nand stronger to learn biased collaborative signals, by contrast, the impact of the loss function to them appears relatively small.\n\nIn addition, it is worth noting that our main focus is to question the value of sophisticated encoders and provide a simple strong baseline, but not to improve current state-of-the-art CF models by exhaustingly trying of various loss functions. Based on the experiments with MF, YouTubeNet, and LightGCN, we demonstrate and highlight that the loss function is a large bottleneck in CF models. We expect our work could inspire more research to study the co-design of the interaction encoder, loss function, and negative sampling.\n\n### 4.6 Parameter Analysis on SimpleX\n\nWe investigate the performance of three different behavior aggregation layers, the fusing weight  \\(g\\) , and the negative loss weight  \\(w\\) . Results on Amazon-Books and Yelp2018 are shown in Table 4. We can make the following observations: 1) Average pooling, self-attention, and user-attention obtain very similar results on Amazon-Books and Yelp2018, respectively. This shows the robustness of apply average pooling for behavior aggregation in practice. SimpleX with\n\nTable 3: Performance of different models trained with CCL v.s. their original losses.  \n\n<table><tr><td rowspan=\"2\">Model</td><td colspan=\"2\">Amazon-Books</td><td colspan=\"2\">Yelp2018</td></tr><tr><td>Recall@20</td><td>NDCG@20</td><td>Recall@20</td><td>NDCG@20</td></tr><tr><td>MF-BPR</td><td>0.0338</td><td>0.0261</td><td>0.0549</td><td>0.0445</td></tr><tr><td>MF-CCL</td><td>0.0559</td><td>0.0447</td><td>0.0698</td><td>0.0572</td></tr><tr><td>YouTubeNet</td><td>0.0502</td><td>0.0388</td><td>0.0655</td><td>0.0537</td></tr><tr><td>YouTubeNet-CCL</td><td>0.0544</td><td>0.0430</td><td>0.0685</td><td>0.0563</td></tr><tr><td>LightGCN</td><td>0.0411</td><td>0.0315</td><td>0.0649</td><td>0.0530</td></tr><tr><td>LightGCN-CCL</td><td>0.0528</td><td>0.0416</td><td>0.0669</td><td>0.0554</td></tr></table>\n\nTable 4: Parameter analysis results on SimpleX.  \n\n<table><tr><td rowspan=\"2\">Ablations</td><td colspan=\"2\">Amazon-Books</td><td colspan=\"2\">Yelp2018</td></tr><tr><td>Recall@20</td><td>NDCG@20</td><td>Recall@20</td><td>NDCG@20</td></tr><tr><td>avg_pooling</td><td>0.0583</td><td>0.0468</td><td>0.0701</td><td>0.0575</td></tr><tr><td>self_attn.</td><td>0.0580</td><td>0.0462</td><td>0.0698</td><td>0.0576</td></tr><tr><td>user_attn.</td><td>0.0551</td><td>0.0436</td><td>0.0698</td><td>0.0574</td></tr><tr><td>g = 0</td><td>0.0534</td><td>0.0429</td><td>0.0679</td><td>0.0555</td></tr><tr><td>g = 0.5</td><td>0.0583</td><td>0.0468</td><td>0.0688</td><td>0.0565</td></tr><tr><td>g = 1</td><td>0.0540</td><td>0.0432</td><td>0.0701</td><td>0.0575</td></tr><tr><td>w = 1</td><td>0.0163</td><td>0.0128</td><td>0.0238</td><td>0.0189</td></tr><tr><td>w = 150</td><td>0.0542</td><td>0.0429</td><td>0.0701</td><td>0.0575</td></tr><tr><td>w = 300</td><td>0.0583</td><td>0.0468</td><td>0.0666</td><td>0.0549</td></tr><tr><td>w = 1000</td><td>0.0481</td><td>0.0379</td><td>0.0568</td><td>0.0463</td></tr></table>\n\nTable 5: Efficiency comparison on Amazon-Books, w.r.t. the average training time per epoch, the number of epochs to converge, and the total training time.  \n\n<table><tr><td>Model</td><td>Time/EPOCH</td><td>#Epochs</td><td>Training Time</td></tr><tr><td>ENMF</td><td>129s</td><td>81</td><td>2h54m</td></tr><tr><td>LightGCN</td><td>51s</td><td>780</td><td>11h3m</td></tr><tr><td>SimpleX (|N|=100)</td><td>40s</td><td>28</td><td>19m</td></tr><tr><td>SimpleX (|N|=1000)</td><td>131s</td><td>35</td><td>1h16m</td></tr></table>\n\n\\(g = 0.5\\)  reaches higher performance compared with the other two settings on Amazon-Books, which shows that importance of fusing user embedding with user behavior aggregation. 2) The negative weight  \\(w\\)  which adjusts the ratio of positive and negative losses is vital to model's performance. In general, too small ( \\(w = 1\\) ) or too large ( \\(w = 1000\\) ) difference between positive and negative losses leads to performance reduction.\n\n### 4.7 Efficiency Comparison\n\nOur SimpleX has high efficiency due to its simple design. We numerically compare the training time of SimpleX with two state-of-the-art CF models, i.e., ENMF and LightGCN, which are relatively efficient in their respective categories, on Amazon-Books. The efficiency experiments are conducted on the same Intel(R) Xeon(R) Silver 4210 CPU @2.20GHz machine with one GeForce RTX 2080 GPU. We compare them under the same implementation framework, using the same acceleration methods (e.g., implementing the sampling with  \\(\\mathrm{C + + }\\) ) to ensure fairness. Specifically, we present the averaged\n\ntraining time per epoch, the number of epochs that the model needs to reach the level of performance reported in the original paper, and the total training time (test time is not included), in Table 5.\n\nIt turns out that SimpleX is much more efficient than ENMF and LightGCN overall. Specifically, SimpleX only needs around 30 epochs to converge in training, which is more convenient for real application. The total training time of SimpleX with a 1000:1 negative sampling ratio has around 2x and 10x speedup compared with ENMF and LightGCN respectively. Moreover, if we decrease the negative sampling ratio to 100:1, the training time for one epoch of SimpleX can be optimized to 40s, finally resulting in only 19 minutes total training time. Certainly, the performance slightly drops compared with using a 1000:1 negative sampling ratio, but it still maintains a pretty good level (much better than ENMF and LightGCN). Such high efficiency makes our model promising to be applied in large-scale real recommender systems.\n\n### 4.8 Evaluating SimpleX on More Datasets\n\nIn addition to the three main datasets used in the above sub-sections, we additionally evaluate SimpleX on 8 more datasets to further demonstrate the generability of SimpleX.\n\nTable 6 shows the comparison results to some state-of-the-art CF models published in 2020. For fairness of comparison, we use the same data preprocessing and experimental settings (embedding dimensions and evaluation metrics) provided by the corresponding papers. We observed that SimpleX consistently outperforms all the compared models on different datasets. The performance improvements are especially large (12.8% to 33.6% improvement in NDCG@20) on Amazon-CDs, Amazon-Movies and Amazon-Beauty compared to BGCF, a recent GNN-based model. This again strongly verifies the effectiveness and robustness of SimpleX to serve as a strong baseline in future work.\n\nMoreover, we also make a comparison to some autoencoder-based models, including SLIM, Mult-VAE, EASER, and RecVAE. It is worth noting that our experiment also follows the same setting with them. In particular, we adopt the strong generalization protocol, where the training, validation and test sets are disjoint in terms of users. This requires the model to perform inductive learning during inference. That is, only item embeddings can be learned during training and then transferred to the validation and test sets for prediction. To achieve this, we simplify SimpleX by setting  \\(g = 0\\)  in this experiment and only learn user representations from their historically interacted items.\n\nTable 7 presents the evaluation results on Movielens-20M and MillionSongData. We can see that SimpleX obtains better performance than SLIM, which is a well-known strong baseline for CF. But it does not surpass Mult-VAE,  \\(\\mathrm{EASE}^{\\mathrm{R}}\\)  and RecVAE given their complete forms. This is reasonable because all of them use many more parameters  \\((O(|I|*600)\\)  for Mult-VAE and RecVAE,  \\(O(|I|*|I|)\\)  for  \\(\\mathrm{EASE}^{\\mathrm{R}}\\) ) than SimpleX, as shown in the \"Params\" columns. Note that both Mult-VAE and RecVAE use 600 as the dimension of the first hidden layer. As the number of items  \\((|I|)\\)  easily reaches millions to billions in industrial recommender systems, we choose a small embedding dimension (i.e., 64) and results in parameters in the scale of  \\(O(|I|*64)\\) . To make the comparison more fair, we reduce the embedding dimensions of baseline models accordingly.\n\nTable 6: Performance comparison to some more models published in 2020. We use the same dataset settings and report the same metrics with the original papers. We also duplicate their reported results for consistency.  \n\n<table><tr><td colspan=\"3\">Amazon-CDs</td><td colspan=\"3\">Amazon-Movies</td><td colspan=\"3\">Amazon-Beauty</td></tr><tr><td>Model</td><td>Recall@20</td><td>NDCG@20</td><td>Model</td><td>Recall@20</td><td>NDCG@20</td><td>Model</td><td>Recall@20</td><td>NDCG@20</td></tr><tr><td>NGCF</td><td>0.1258</td><td>0.0792</td><td>NGCF</td><td>0.0866</td><td>0.0555</td><td>MF-BPR</td><td>0.1312</td><td>0.0778</td></tr><tr><td>NIA-GCN</td><td>0.1487</td><td>0.0932</td><td>NIA-GCN</td><td>0.1058</td><td>0.0683</td><td>NGCF</td><td>0.1513</td><td>0.0917</td></tr><tr><td>BGCF</td><td>0.1506</td><td>0.0948</td><td>BGCF</td><td>0.1066</td><td>0.0693</td><td>BGCF</td><td>0.1534</td><td>0.0912</td></tr><tr><td>SimpleX</td><td>0.1763</td><td>0.1145</td><td>SimpleX</td><td>0.1342</td><td>0.0926</td><td>SimpleX</td><td>0.1721</td><td>0.1028</td></tr><tr><td>RI over NIA-GCN</td><td>18.6%</td><td>22.9%</td><td>RI over NIA-GCN</td><td>26.8%</td><td>35.5%</td><td>-</td><td>-</td><td>-</td></tr><tr><td>RI over BGCF</td><td>17.1%</td><td>20.8%</td><td>RI over BGCF</td><td>25.9%</td><td>33.6%</td><td>RI over BGCF</td><td>12.2%</td><td>12.8%</td></tr></table>\n\n<table><tr><td colspan=\"3\">Amazon-Electronics</td><td colspan=\"3\">CiteUlike-A</td><td colspan=\"3\">Movielens-1M</td></tr><tr><td>Model</td><td>F1@20</td><td>NDCG@20</td><td>Model</td><td>Precision@20</td><td>Recall@20</td><td>Model</td><td>F1@20</td><td>NDCG@20</td></tr><tr><td>MF-BPR</td><td>0.0275</td><td>0.0680</td><td>NGCF</td><td>0.0517</td><td>0.0193</td><td>NGCF</td><td>0.1582</td><td>0.2511</td></tr><tr><td>NBPO</td><td>0.0313</td><td>0.0810</td><td>DHCF</td><td>0.0635</td><td>0.0249</td><td>LCFN</td><td>0.1625</td><td>0.2603</td></tr><tr><td>SimpleX</td><td>0.0338</td><td>0.0842</td><td>SimpleX</td><td>0.0754</td><td>0.0269</td><td>SimpleX</td><td>0.1658</td><td>0.2670</td></tr><tr><td>RI over NBPO</td><td>8.0%</td><td>4.0%</td><td>RI over DHCF</td><td>18.7%</td><td>8.2%</td><td>RI over LCFN</td><td>2.0%</td><td>2.6%</td></tr></table>\n\nTable 7: Performance comparison to autoenoder-based models on Movielens-20M and MillionSongData.  \n\n<table><tr><td rowspan=\"2\">Model</td><td colspan=\"4\">Movielens-20M</td><td colspan=\"4\">MillionSongData</td></tr><tr><td>Recall@20</td><td>Recall@50</td><td>NDCG@100</td><td>#Params</td><td>Recall@20</td><td>Recall@50</td><td>NDCG@100</td><td>#Params</td></tr><tr><td>SLIM</td><td>0.370</td><td>0.495</td><td>0.401</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>Mult-VAE</td><td>0.395</td><td>0.537</td><td>0.426</td><td>24.5M</td><td>0.266</td><td>0.363</td><td>0.313</td><td>49.7M</td></tr><tr><td>EASER</td><td>0.391</td><td>0.521</td><td>0.420</td><td>404.3M</td><td>0.333</td><td>0.428</td><td>0.389</td><td>1,692M</td></tr><tr><td>RecVAE</td><td>0.414</td><td>0.553</td><td>0.442</td><td>16.5 M</td><td>0.276</td><td>0.374</td><td>0.326</td><td>33.3M</td></tr><tr><td>Mult-VAE (d=64)</td><td>0.375</td><td>0.514</td><td>0.407</td><td>2.6M</td><td>0.230</td><td>0.319</td><td>0.280</td><td>5.3M</td></tr><tr><td>EASER (d=64)</td><td>0.361</td><td>0.487</td><td>0.392</td><td>2.6M</td><td>0.170</td><td>0.235</td><td>0.205</td><td>5.3M</td></tr><tr><td>RecVAE (d=64)</td><td>0.385</td><td>0.520</td><td>0.412</td><td>2.6M</td><td>0.232</td><td>0.319</td><td>0.280</td><td>5.3M</td></tr><tr><td>SimpleX (d=64)</td><td>0.389</td><td>0.523</td><td>0.416</td><td>1.3M</td><td>0.245</td><td>0.329</td><td>0.293</td><td>2.6M</td></tr><tr><td>RI over Mult-VAE</td><td>3.8%</td><td>1.7%</td><td>2.3%</td><td></td><td>6.5%</td><td>3.2%</td><td>4.7%</td><td></td></tr><tr><td>RI over EASER</td><td>7.8%</td><td>7.4%</td><td>6.2%</td><td></td><td>44.0%</td><td>40.3%</td><td>43.3%</td><td></td></tr><tr><td>RI over RecVAE</td><td>1.1%</td><td>0.6%</td><td>1.1%</td><td></td><td>5.8%</td><td>3.2%</td><td>4.8%</td><td></td></tr></table>\n\nSpecifically, for Mult-VAE and RecVAE, we set its encoder and decoder as a single  \\((|I|*64)\\) -dimensional dense layer. For EASE \\(^{\\text{R}}\\) , we decompose its item similarity matrix (denoted as B) to two  \\((|I|*64)\\) -dimensional sub-matrices by truncated SVD, and multiply the two sub-matrices to approximate the item similarity matrix to perform predictions. In this setting, SimpleX clearly outperform these autoencoder based CF models.\n\nOverall, our comprehensive experimental results on various datasets show that our SimpleX is simple and strong to serve as a new baseline model to facilitate future research on CF. The availability of this baseline would allow for more solid experimental evaluations and more fair comparisons among CF models.\n",
  "hyperparameter": "Learning rate: tuned among [1e-3, 5e-4, 1e-4]; Batch size: 1024; L2 regularization weight: searched between 1e-9~1e-2 with increase ratio of 5; Number of negative samples: searched from 1 to 2000, commonly picked 100, 500, or 1000; Margin m in CCL: tuned among 0~1 at interval of 0.1 (e.g., 0.4 for Amazon-Books, 0.9 for Yelp2018 and Gowalla); Embedding dimension: 64 (matching LightGCN) or 128 (matching LCFN); Fusing weight g: 0.5 works best on Amazon-Books; Negative loss weight w: searched among [1, 150, 300, 1000], with 300 performing well on Amazon-Books; Maximum behavior sequence length K: dataset-dependent with padding/chunking"
}