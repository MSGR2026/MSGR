{
  "id": "EASE_2019",
  "paper_title": "Embarrassingly Shallow Autoencoders for Sparse Data",
  "alias": "EASE",
  "year": 2019,
  "domain": "Recsys",
  "task": "GeneralRecommendation",
  "idea": "EASE^R is a linear autoencoder for collaborative filtering that learns an item-item weight matrix B with a crucial zero-diagonal constraint (diag(B)=0) to prevent trivial self-similarity. The model admits a closed-form solution by solving a constrained convex optimization problem using Lagrangian multipliers, requiring only matrix inversion of the Gram matrix X^T X. Remarkably, about 60% of learned weights are negative, indicating that learning item dissimilarity (negative weights) alongside similarity is crucial for recommendation accuracy, which explains why it significantly outperforms SLIM and other methods that enforce non-negativity constraints.",
  "introduction": "# 1 INTRODUCTION\n\nMany recent improvements in collaborative filtering can be attributed to deep learning approaches, e.g., [5, 7-9, 13, 21, 25, 26]. Unlike in areas like computer vision, however, it was found that a small number of hidden layers achieved the best recommendation accuracy. In this paper, we take this to the extreme, and define a linear model without a hidden layer (see Figure 1). The (binary) input vector indicates which items a user has interacted with, and the model's objective (in its output layer) is to predict the best items to recommend to the user. This is done by reproducing the input as its output, as is typical for autoencoders. We hence named it Embarrassingly Shallow AutoEncoder (in Reverse order:  $\\mathrm{EASE}^{\\mathrm{R}}$ ).\n\nThis paper is organized as follows: we define  $\\mathrm{EASE}^{\\mathrm{R}}$  in the next section, using simple elements from the literature. In Section 3.1, we derive the closed-form solution of its convex training objective. This has several implications: (1) it reveals that the neighborhood-based approaches used in collaborative filtering are based on conceptually incorrect item-item similarity-matrices, while  $\\mathrm{EASE}^{\\mathrm{R}}$  may be considered a principled neighborhood model, see Sections 3.2 and 4.3; (2) the code for training  $\\mathrm{EASE}^{\\mathrm{R}}$  is comprised of only a few lines, see Section 3.3 and Algorithm 1; (3) if the model fits into memory, the wall-clock time for training  $\\mathrm{EASE}^{\\mathrm{R}}$  can be several orders of magnitude less than for training a SLIM [16] model (see Section 3.4), which is the most similar model to  $\\mathrm{EASE}^{\\mathrm{R}}$ . Apart from that, we surprisingly found that  $\\mathrm{EASE}^{\\mathrm{R}}$  achieved competitive ranking accuracy, and even outperformed various deep, non-linear, or probabilistic models as well as neighborhood-based approaches on most of the publicly available data-sets used in our experiments (see Section 5).\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-15/48780de5-5b48-4baf-828d-0ce1f8dffba0/a71591c08d5db88fa27a6470ce717bb462c4a797d0f7ff9c4e31ab4a97de137b.jpg)  \nFigure 1: The self-similarity of each item is constrained to zero between the input and output layers.\n",
  "method": "# 2 MODEL DEFINITION\n\nLike in many recommender papers that use implicit feedback data, we assume that the data are given in terms of a sparse (typically binary $^2$ ) matrix  $X \\in \\mathbb{R}^{|\\mathcal{U}| \\times |\\bar{I}|}$ , regarding the sets of users  $\\mathcal{U}$  and items  $\\bar{I}$ , where  $|\\cdot|$  denotes the size of a set. A positive value (typically 1) in  $X$  indicates that the user interacted with an item, while a value of 0 indicates that no interaction has been observed.\n\nThe parameters of the  $\\mathrm{EASE}^{\\mathrm{R}}$  model are given by the item-item weight-matrix  $B\\in \\mathbb{R}^{|\\mathcal{I}|\\times |\\mathcal{I}|}$ . Note that this is also similar to neighborhood-based approaches, see Section 4.3. In this weight matrix, self-similarity of an item in the input-layer with itself in the output layer is forbidden as to force the model to generalize when reproducing the input as its output (see Figure 1): hence the diagonal of the weight-matrix is constrained to zero,  $\\mathrm{diag}(B) = 0$ . This constraint is crucial, and is discussed in detail in the remainder of this paper. This constraint was first introduced in the SLIM model [16].\n\nThe predicted score  $S_{u,j}$  for an item  $j \\in I$  given a user  $u \\in \\mathcal{U}$  is defined by the dot product\n\n$$\nS _ {u j} = X _ {u, \\cdot} \\cdot B _ {\\cdot , j}, \\tag {1}\n$$\n\nwhere  $X_{u}$  . refers to row  $u$  , and  $B_{\\cdot ,j}$  to column  $j$\n\n# 3 MODEL TRAINING\n\nWe use the following convex objective for learning the weights  $B$ :\n\n$$\n\\min  _ {B} \\quad | | X - X B | | _ {F} ^ {2} + \\lambda \\cdot | | B | | _ {F} ^ {2} \\tag {2}\n$$\n\n$$\ns. t. \\quad \\operatorname {d i a g} (B) = 0 \\tag {3}\n$$\n\nSeveral comments are in order:\n\n- We choose the square loss  $(\\| \\cdot \\|_F$  denotes the Frobenius norm) between the data  $X$  and the predicted scores  $S = XB$  over other loss functions because it allows for a closed-form solution (see next section). Training with other loss functions, however, might result in improved ranking-accuracy: in [13], it was observed that the multinomial likelihood resulted in better ranking-accuracy than training with the logistic likelihood (log loss) or the Gaussian likelihood (square loss). Directly optimizing a (surrogate) ranking\n\nloss might result in further accuracy gains—however, at possibly increased computational costs.\n\n- We use L2-norm regularization of the weights  $B$  to be learned. The training objective hence has a single hyperparameter  $\\lambda$ , to be optimized on a validation set.  \n- The constraint of a zero diagonal,  $\\mathrm{diag}(B) = 0$ , is crucial as to avoid the trivial solution  $B = I$  (self-similarity of items), where  $I$  is the identity matrix. It was introduced in SLIM [16].\n\n# 3.1 Closed-Form Solution\n\nIn this section, we show that the constrained convex optimization problem for learning the weight matrix  $B$  in Eqs. 2 and 3 can be solved in closed form.\n\nWe start by including the equality constraint in Eq. 3 into the objective function in Eq. 2 by forming the Lagrangian\n\n$$\nL = \\left\\| X - X B \\right\\| _ {F} ^ {2} + \\lambda \\cdot \\left\\| B \\right\\| _ {F} ^ {2} + 2 \\cdot \\gamma^ {\\top} \\cdot \\operatorname {d i a g} (B),\n$$\n\nwhere  $\\gamma = (\\gamma_{1},\\dots,\\gamma_{|\\mathcal{I}|})^{\\top}$  is the vector of Lagrangian multipliers. Its values will be chosen in Eq. 6 such that the constraint in Eq. 3 is fulfilled.\n\nThe constrained optimization problem in Eqs. 2 and 3 is solved by minimizing this Lagrangian. As a necessary condition, we hence set its derivative to zero, which yields the estimate  $\\hat{B}$  of the weight matrix after re-arranging terms:\n\n$$\n\\hat {B} = \\left(X ^ {\\top} X + \\lambda I\\right) ^ {- 1} \\cdot \\left(X ^ {\\top} X - \\operatorname {d i a g M a t} (\\gamma)\\right),\n$$\n\nwhere diagMat(\\cdot) denotes the diagonal matrix and  $I$  the identity matrix. Defining (for sufficiently large  $\\lambda$ )\n\n$$\n\\hat {P} \\triangleq \\left(X ^ {\\top} X + \\lambda I\\right) ^ {- 1}, \\tag {4}\n$$\n\nthis can be substituted into the previous equation:\n\n$$\n\\begin{array}{l} \\hat {B} = \\left(X ^ {\\top} X + \\lambda I\\right) ^ {- 1} \\cdot \\left(X ^ {\\top} X - \\operatorname {d i a g M a t} (\\gamma)\\right) \\\\ = \\hat {P} \\cdot (\\hat {P} ^ {- 1} - \\lambda I - \\operatorname {d i a g} \\operatorname {M a t} (\\gamma)) \\\\ = I - \\hat {P} \\cdot (\\lambda I + \\operatorname {d i a g M a t} (\\gamma)) \\\\ = I - \\hat {P} \\cdot \\operatorname {d i a g M a t} (\\tilde {\\gamma}) \\tag {5} \\\\ \\end{array}\n$$\n\nwhere we defined the vector  $\\tilde{\\gamma} \\triangleq \\lambda \\vec{1} + \\gamma$  in the last line, with  $\\vec{1}$  denoting a vector of ones. The values of the Lagrangian multipliers  $\\gamma$ , and hence  $\\tilde{\\gamma}$ , are determined by the constraint  $\\mathrm{diag}(\\hat{B}) = 0$ . It follows from Eq. 5:\n\n$$\n0 = \\operatorname {d i a g} (\\hat {B}) = \\vec {1} - \\operatorname {d i a g} (\\hat {P}) \\odot \\tilde {\\gamma} \\tag {6}\n$$\n\nwhere  $\\odot$  denotes the elementwise product, and hence:\n\n$$\n\\tilde {\\gamma} = \\vec {1} \\oslash \\operatorname {d i a g} (\\hat {P}),\n$$\n\nwhere  $\\varnothing$  denotes the elementwise division (which is well-defined given that  $\\hat{P}$  is invertible). Substituting this into Eq. 5 immediately results in the closed-form solution:\n\n$$\n\\hat {B} = I - \\hat {P} \\cdot \\operatorname {d i a g} \\operatorname {M a t} (\\vec {1} \\oslash \\operatorname {d i a g} (\\hat {P})). \\tag {7}\n$$\n\nIn other words, the learned weights are given by:\n\n$$\n\\hat {B} _ {i, j} = \\left\\{ \\begin{array}{l l} 0 & \\text {i f} i = j \\\\ - \\frac {\\hat {P} _ {i j}}{\\hat {P} _ {j j}} & \\text {o t h e r w i s e .} \\end{array} \\right. \\tag {8}\n$$\n\nThis solution obviously obeys the constraint of a zero diagonal. The off-diagonal elements are determined by the matrix  $\\hat{P}$  (see Eq. 4),\n\nwhere the  $j^{\\mathrm{th}}$  column is divided by its diagonal element  $\\hat{P}_{jj}$ . Note that  $\\hat{B}$  is an asymmetric matrix in general, while  $\\hat{P}$  is symmetric (see Eq. 4).\n\nEqs. 4 and 8 show that the sufficient statistics for estimating  $B$  is given by the data Gram-matrix  $G \\triangleq X^{\\top}X$ , which is an item-item matrix. This is a consequence of using the square loss in Eq. 2, and is helpful for estimating  $B$  from sparse data  $X$ : if  $X$  is a sparse binary matrix, then  $G = X^{\\top}X$  is a co-occurrence matrix. The uncertainty of a co-occurrence count  $G_{ij}$  is (approximately) determined by the standard deviation of the Poisson distribution, which is  $\\sqrt{G_{ij}}$ . As long as the co-occurrence counts  $G_{ij}$  are 'sufficiently large',  $G$  and hence  $B$  can be estimated with small error. An interesting fact is that the entries of  $G = X^{\\top}X$  can be increased by two different mechanisms: (1) a denser  $X$  (due to users with increased activity), or (2) an increased number of users in  $X$ . The latter is particularly useful, as an increased sparsity of  $X$  can be compensated by an increased number of users. In other words, the problem that there possibly is only a small amount of data available for each user (i.e., data sparsity), does not affect the uncertainty in estimating  $B$  if the number of users in the data matrix  $X$  is sufficiently large.\n\n# 3.2 Interpretation\n\nIn this section, we outline that the closed-form solution in Eq. 8 does not come as a complete surprise. To this end, let us consider the following special case throughout this section: let the training data  $X$  be an i.i.d. sample of  $|\\mathcal{U}|$  data points regarding a vector of  $|I|$  random variables  $x \\sim \\mathcal{N}(0, \\Sigma)$  that follows a Gaussian distribution with zero mean and covariance matrix  $\\Sigma \\in \\mathbb{R}^{|\\mathcal{I}| \\times |\\mathcal{I}|}$ .\n\nThen the estimate of the covariance matrix is  $\\hat{\\Sigma} = X^{\\top}X / |\\mathcal{U}|$ . If we further drop the L2-norm regularization in Eq. 4 and assume invertibility, then  $\\hat{P} = \\hat{\\Sigma}^{-1}$  is the estimate of the so-called precision (or concentration) matrix. Estimating the precision matrix from given data is a main objective in the area of graphical models (e.g., see [11]).\n\nIt is well known [4, 11] that the (univariate) conditional distribution of the random variable  $x_{j}$  given the vector of all the other variables, denoted by  $x_{-j} \\triangleq (x_k)_{k \\in \\mathcal{I} \\setminus \\{j\\}}$ , is a Gaussian distribution with variance  $\\text{var}(x_j | x_{-j}) = 1 / P_{j,j}$  and mean\n\n$$\n\\begin{array}{l} \\mu_ {j | - j} \\triangleq \\mathbb {E} [ x _ {j} | x _ {- j} ] = - x _ {- j} \\cdot P _ {- j, j} / P _ {j, j} \\\\ = x _ {- j} \\cdot B _ {- j, j} \\\\ = x \\cdot B _ {., j} \\\\ \\end{array}\n$$\n\nwhere the dot in the first line denotes the dot-product between the (row) vector  $x_{-j}$  and the  $j^{\\mathrm{th}}$  column of the precision matrix  $P = \\Sigma^{-1}$ , omitting the  $j^{\\mathrm{th}}$  element. The second line follows from Eq. 8, and the last line from  $B_{jj} = 0$ . Note that this is identical to the prediction rule of the EASER model in Eq. 1. This shows that EASER makes a principled point-prediction that user  $u$  will like item  $j$  conditional on the fact that the user's past interactions with all items are given by  $X_{u,..} = x$ .\n\nA more well-known fact (e.g., see [15]) is that the absence of an edge between the random variables  $x_{i}$  and  $x_{j}$  in a Markov network corresponds to the conditional independence of the random variables  $x_{i}$  and  $x_{j}$  given the vector of all the other variables  $(x_{k})_{k\\in I\\setminus \\{i,j\\}}$ , which is also equivalent to a zero entry in the precision matrix. Note that this is different from a zero entry in the covariance matrix  $\\Sigma$ ,\n\nwhich signifies marginal independence of  $x_{i}$  and  $x_{j}$ . This shows that the precision matrix is the conceptually correct similarity-matrix to be used, rather than the covariance matrix, which (or some rescaled variant thereof) is typically used in state-of-the-art neighborhood-based approaches (see Section 4.3).\n\nLearning the graph structure in Markov networks corresponds to learning a sparse precision matrix from data. Approaches developed in that field (e.g., see [19] and references therein) might be useful for improved learning of a sparse matrix  $\\hat{B}$ . This is beyond the scope of this paper.\n\nWhile the interpretation we outlined in this section is limited to the special case of normally distributed variables with zero mean, note that the derivation of Eq. 8 does not require that each column of the data matrix  $X$  has zero mean. In other words, in  $\\mathrm{EASE}^{\\mathrm{R}}$  any definition of the Gram matrix  $G \\triangleq X^{\\top}X$  may be used, e.g.,  $G$  may be the co-occurrence matrix (if  $X$  is a binary matrix), proportional to the covariance matrix (if  $X$  is pre-processed to have zero mean in each column), or the correlation matrix (if each column of  $X$  is pre-processed to have zero mean and unit variance). After training  $\\mathrm{EASE}^{\\mathrm{R}}$  on these transformed matrices  $X$  and then transforming the predicted scores back to the original space (as defined by the binary matrix  $X$ ), we found in our experiments that the differences in the obtained ranking accuracies were of the order of the standard error, and we hence do not separately report these results in Section 5.\n\n# 3.3 Algorithm\n\nThe Python code of the resulting learning algorithm is given in Algorithm 1. Note that the training of  $\\mathrm{EASE}^{\\mathrm{R}}$  requires only the item-item matrix  $G = X^{\\top}X$  as input, instead of the user-item matrix  $X$ , and hence is particularly efficient if the size of  $G$  (i.e.,  $|\\mathcal{I}| \\times |\\mathcal{I}|$ ) is smaller than the number of user-item-interactions in  $X$ . In this case, the expensive computation of  $G = X^{\\top}X$  can be done on a big-data pre-processing system, prior to the actual model training.\n\n# 3.4 Computational Cost\n\nThe computational complexity of Algorithm 1 is determined by the matrix inversion of the data Gram-matrix  $G \\triangleq X^{\\top}X \\in \\mathbb{R}^{|\\mathcal{I}| \\times |\\mathcal{I}|}$ , which is  $O(|\\mathcal{I}|^3)$  when using a basic approach, and about  $O(|\\mathcal{I}|^{2.376})$  when using the Coppersmith-Winograd algorithm. Note that this is independent of the number of users as well as the number of user-item-interactions, as  $G$  can be computed in the pre-processing step.\n\nThis computational complexity is orders of magnitude lower than the cost of training a SLIM model and its variants [12, 16, 20]: those approaches take advantage of the fact that the optimization problem regarding  $|\\mathcal{I}|$  items can be decomposed into  $|\\mathcal{I}|$  independent (and hence embarrassingly parallel) optimization problems involving  $|\\mathcal{I}| - 1$  items each, due to the identity  $\\| X - XB\\| _F^2 = \\sum_{j\\in \\mathcal{I}}|X_{..,j} - XB_{..,j}|_2^2$ . If each of the  $|\\mathcal{I}|$  independent problems is solved based on an item-item matrix, the total computational cost is hence  $O(|\\mathcal{I}|(|\\mathcal{I}| - 1)^{2.376})$ . Note that the computational cost of solving those  $|\\mathcal{I}|$  problems is larger by almost a factor of  $|\\mathcal{I}|$  than training  $\\mathrm{EASE^{R}}$ , which requires only a single regression problem to be solved. In practice, however, SLIM and its variants are trained on the user-item-interactions in  $X$ , which may incur additional\n\nAlgorithm 1: Training in Python 2 using numpy  \nInput: data Gram-matrix  $G\\coloneqq X^{\\top}X\\in \\mathbb{R}^{|\\mathcal{I}|\\times |\\mathcal{I}|}$  L2-norm regularization-parameter  $\\lambda \\in \\mathbb{R}^{+}$    \nOutput: weight-matrix  $B$  with zero diagonal (see Eq. 8) diagIndices  $=$  numpy.daiq Indices(G.shape[0])   \n $G[\\mathrm{diagIndices}] += \\lambda$ $P =$  numpy.linalg.inv(G)   \n $B = P / (-$  numpy.daiq(P))   \n $B[\\mathrm{diagIndices}] = 0$\n\ncomputational cost. This explains the vastly reduced training-times of  $\\mathrm{EASE}^{\\mathrm{R}}$  observed in our experiments in Section 5.\n\nIn practice, the wall-clock time depends crucially on the fact if the number of items  $|I|$  is sufficiently small such that the weight matrix fits into memory, so that the matrix inversion can be computed in memory. This was the case in our experiments in Section 5.",
  "experiments": "# 5 EXPERIMENTS\n\nIn this section, the proposed EASE model is empirically compared to several state-of-the-art approaches, based on two papers that provided publicly available code for reproducibility of results [13, 24]. Both papers together cover linear, non-linear, deep and probabilistic models, as well as neighborhood-based approaches.\n\n# 5.1 Experimental Set-up\n\nWe will only summarize the experimental set-ups used in these papers, and refer the reader to these papers for details.\n\nSummary of Set-up in [13]: This paper considers the following models:\n\n- Sparse Linear Method (SLIM) [16]. Besides the original model, also a computationally faster approximation (which drops the constraints on the weights) [12] was considered, but its results were not found to be on par with the other models in the experiments in [13].  \n- Weighted Matrix Factorization (WMF) [10, 18], a linear model with a latent representation of users and items.  \n- Collaborative Denoising Autoencoder (CDAE) [25], a nonlinear model with one hidden layer.  \n- denoising autoencoder (MULT-DAE) and variational autoencoder (MULT-VAE PR) [13], both trained using the multinomial likelihood, which was found to outperform the Gaussian and logistic likelihoods. Best results were obtained in [13] for the MULT-VAE PR and MULT-DAE models that were rather shallow 'deep models', namely with a 200-dimensional latent representation, as well as a 600-dimensional hidden layer in both the encoder and decoder. Both models are non-linear, and MULT-VAE PR is also probabilistic.\n\nThree data sets were used in the experiments in [13], and were preprocessed and filtered for items and users with a certain activity level, resulting in the following data-set sizes, see [13] for details:4\n\n- MovieLens 20 Million (ML-20M) data [6]: 136,677 users and 20,108 movies with about 10 million interactions,  \n- Netflix Prize (Netflix) data [2]: 463,435 users and 17,769 movies with about 57 million interactions,  \n- Million Song Data (MSD) [3]: 571,355 users and 41,140 songs with about 34 million interactions.\n\nThe evaluation in [13] was conducted in terms of strong generalization, i.e., the training, validation and test sets are disjoint in terms of users. This is in contrast to weak generalization, where the training and test sets are disjoint in terms of the user-item interaction-pairs, but not in terms of users. Concerning evaluation in terms of ranking metrics, Recall@k for  $k \\in \\{20, 50\\}$  as well as Normalized Discounted Cumulative Gain, NDCG@100 were used in [13].\n\nSummary of Set-up in [24]: Their paper focuses on neighborhood-based approaches, and the authors publicly shared code<sup>5</sup> regarding the experiments in their table 2 in [24], albeit only for the data-split where the training data was comprised of (at most)  $30\\%$  of each user's interactions (and the remainder was assigned to the test data), which restricted our experimental comparison to this single split in Table 2. They used the MovieLens 10 Million (ML-10M) data [6], which was binarized in [24] and is comprised of 69,878 users and 10,677 movies with 10 million interactions. Their evaluation was done in terms of weak generalization, and NDCG@10 was used as ranking metric for evaluation in [24].\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-15/48780de5-5b48-4baf-828d-0ce1f8dffba0/ed75e53660f92ae2bbfef856fb639fac911ff3db8ab4c89ac618e0903ceb7cb6.jpg)  \nFigure 2: Histogram of the weights learned on Netflix data.\n\n# 5.2 Results\n\nDespite the simplicity of  $\\mathrm{EASE}^{\\mathrm{R}}$ , we observed that  $\\mathrm{EASE}^{\\mathrm{R}}$  obtained considerably better ranking accuracy than any of the competing models on most of the data sets. This remarkable empirical result is discussed in detail in the following.\n\nComparison to SLIM: Table 1 shows that  $\\mathrm{EASE}^{\\mathrm{R}}$  achieved notably increased accuracy compared to SLIM on all the data sets. This suggests that dropping the L1-norm regularization as well as the non-negativity constraint on the learned weights is beneficial. Our analysis indicates that the latter is especially important: as illustrated in Figure 2 on the Netflix data (the histograms for ML-20M and MSD data look almost identical up to re-scaling, and are omitted), the learned weights in  $\\mathrm{EASE}^{\\mathrm{R}}$  are distributed around 0. Interestingly, it turns out that about  $60\\%$  of the learned weights are negative on all the data sets in our experiments (regarding both papers [13, 24]). This indicates that it is crucial to learn also the dissimilarity (negative weights) between items besides their similarity (positive weights). Moreover, when we simply set the negative weights to zero (see  $\\mathrm{EASE}^{\\mathrm{R}} \\geq 0$  in Table 1), which obviously is not the optimal non-negative solution, the resulting accuracy drops and is very close to the one of SLIM. Apart from that, note that  $\\mathrm{EASE}^{\\mathrm{R}} \\geq 0$  is still quite dense ( $40\\%$  positive weights) compared to SLIM, which indirectly indicates that the sparsity of SLIM (due to  $L_{1}$ -norm regularization) did not noticeably improve the ranking accuracy of SLIM in our experiments.\n\nRegarding regularization, the optimal L2-norm regularization parameter  $(\\lambda)$  for  $\\mathrm{EASE}^{\\mathrm{R}}$  is about 500 on  $ML - 20M$ , 1,000 on Netflix, and 200 on MSD. These values are much larger than the typical values used for SLIM, which often are of the order of 1, see [16]. Note that SLIM additionally uses L1-norm regularization, and hence has much fewer (non-zero) parameters than  $\\mathrm{EASE}^{\\mathrm{R}}$ .\n\nAs expected based on Section 3.4, we also found the (wall-clock) training-time of  $\\mathrm{EASE}^{\\mathrm{R}}$  to be smaller by several orders of magnitude compared to SLIM : [13] reports that parallelized grid search for SLIM took about two weeks on the Netflix data, and the MSD data was 'too large for it to finish in a reasonable amount of time' [13]. In contrast, training  $\\mathrm{EASE}^{\\mathrm{R}}$  on the Netflix data took less than two minutes, and on the MSD data less than 20 minutes on an AWS instance with 64 GB RAM and 16 vCPUs in our experiments. These times have to be multiplied by the number of different hyperparameter-values to be grid-searched. Note, however, that  $\\mathrm{EASE}^{\\mathrm{R}}$  only has a single hyperparameter (regarding L2-norm regularization), while SLIM has\n\nTable 1: Ranking accuracy (with standard errors of about 0.002, 0.001, and 0.001 on the ML-20M, Netflix, and MSD data, respectively), following the experimental set-up in [13].  \n\n<table><tr><td>(a) ML-20M</td><td>Recall@20</td><td>Recall@50</td><td>NDCG@100</td></tr><tr><td>popularity</td><td>0.162</td><td>0.235</td><td>0.191</td></tr><tr><td>EASER</td><td>0.391</td><td>0.521</td><td>0.420</td></tr><tr><td>EASER≥ 0</td><td>0.373</td><td>0.499</td><td>0.402</td></tr><tr><td colspan=\"4\">results reproduced from [13]:</td></tr><tr><td>SLIM</td><td>0.370</td><td>0.495</td><td>0.401</td></tr><tr><td>WMF</td><td>0.360</td><td>0.498</td><td>0.386</td></tr><tr><td>CDAE</td><td>0.391</td><td>0.523</td><td>0.418</td></tr><tr><td>MULT-VAE PR</td><td>0.395</td><td>0.537</td><td>0.426</td></tr><tr><td>MULT-DAE</td><td>0.387</td><td>0.524</td><td>0.419</td></tr><tr><td colspan=\"4\">(b) Netflix</td></tr><tr><td>popularity</td><td>0.116</td><td>0.175</td><td>0.159</td></tr><tr><td>EASER</td><td>0.362</td><td>0.445</td><td>0.393</td></tr><tr><td>EASER≥ 0</td><td>0.345</td><td>0.424</td><td>0.373</td></tr><tr><td colspan=\"4\">results reproduced from [13]:</td></tr><tr><td>SLIM</td><td>0.347</td><td>0.428</td><td>0.379</td></tr><tr><td>WMF</td><td>0.316</td><td>0.404</td><td>0.351</td></tr><tr><td>CDAE</td><td>0.343</td><td>0.428</td><td>0.376</td></tr><tr><td>MULT-VAE PR</td><td>0.351</td><td>0.444</td><td>0.386</td></tr><tr><td>MULT-DAE</td><td>0.344</td><td>0.438</td><td>0.380</td></tr><tr><td colspan=\"4\">(c) MSD</td></tr><tr><td>popularity</td><td>0.043</td><td>0.068</td><td>0.058</td></tr><tr><td>EASER</td><td>0.333</td><td>0.428</td><td>0.389</td></tr><tr><td>EASER≥ 0</td><td>0.324</td><td>0.418</td><td>0.379</td></tr><tr><td colspan=\"4\">results reproduced from [13]:</td></tr><tr><td>SLIM</td><td colspan=\"3\">- did not finish in [13] -</td></tr><tr><td>WMF</td><td>0.211</td><td>0.312</td><td>0.257</td></tr><tr><td>CDAE</td><td>0.188</td><td>0.283</td><td>0.237</td></tr><tr><td>MULT-VAE PR</td><td>0.266</td><td>0.364</td><td>0.316</td></tr><tr><td>MULT-DAE</td><td>0.266</td><td>0.363</td><td>0.313</td></tr></table>\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-15/48780de5-5b48-4baf-828d-0ce1f8dffba0/de9dee70e0d86ead103efce4fd36d35b6022b59347782ff8e915445b26f77c17.jpg)  \nFigure 3:  $\\mathrm{EASE}^{\\mathrm{R}}$  (green) recommends long-tail items more often in the top-100, compared to MULT-VAE PR (dotted), on MSD data.\n\ntwo hyperparameters (concerning L1 and L2 norms) to be jointly optimized.\n\nComparison to linear and deep non-linear models in [13]: Table 1 shows that  $\\mathrm{EASE}^{\\mathrm{R}}$  was consistently outperformed on only\n\nTable 2: Comparison to the neighborhood-approaches in [24]:  $\\mathrm{EASE}^{\\mathrm{R}}$  considerably improves over 'ii-SVD-500' [24].  \n\n<table><tr><td></td><td>EASER</td><td>EASER</td><td colspan=\"3\">reproduced from [24]:</td></tr><tr><td></td><td></td><td>≥ 0</td><td>ii-SVD-500</td><td>item-item</td><td>WMF</td></tr><tr><td>NDCG@10</td><td>0.6258</td><td>0.6199</td><td>0.6113</td><td>0.5957</td><td>0.5969</td></tr></table>\n\nthe  $ML - 20M$  data, and only by a small margin by the best competing model (MULT-VAE PR). On the Netflix and MSD data,  $\\mathrm{EASE^R}$  obtained significantly better ranking results than any of the competing linear, non-linear, deep or probabilistic models evaluated in [13]. On the MSD data,  $\\mathrm{EASE^R}$  even improved over the best competing model by  $25\\%$ $17\\%$  and  $23\\%$  regarding Recall@20, Recall@50, and NDCG@100, respectively. This is consistent with the results of the Million Song Data Challenge on Kaggle [14], where neighborhood-based approaches were found to vastly outperform model-based approaches [1]. As discussed in Section 4.3,  $\\mathrm{EASE^R}$  may also be viewed as a principled neighborhood approach.\n\nAs to explain  $\\mathrm{EASE}^{\\mathrm{R}}$ 's relative improvements from ML-20M via Netflix to MSD data, various properties of the data sets may be considered. As shown by table 1 in [13], the number of user-item interactions, and the sparsity of the data sets do not appear well correlated with  $\\mathrm{EASE}^{\\mathrm{R}}$ 's relative performance in Table 1. Only the number of users correlates well with the improvements of  $\\mathrm{EASE}^{\\mathrm{R}}$  over the competing models, which, however, appears to be spurious.\n\nThe explanation can be understood in terms of the tradeoff between recommending generally popular items vs. personally relevant items to each user, which is supported by two empirical findings: (1) we evaluated the popularity model in Table 1 as an additional baseline, where the items are ranked by their popularities (i.e., the number of users who interacted with an item). These unpersonalized recommendations obviously ignore the personalized relevance to a user. Table 1 shows that this popularity model obtains better accuracy on the  $ML - 20M$  data than it does on the Netflix data, while its accuracy is considerably reduced on the MSD data. This suggests that good recommendations on the MSD data have to focus much more on personally relevant items rather than on generally popular items, compared to the  $ML - 20M$  and Netflix data. (2) When counting how often an item was recommended in the top-100 across all test-users, and then ranking the items by their counts, we obtained Figure 3 for the MSD data: it shows that  $\\mathrm{EASER}^{\\mathrm{R}}$  recommended long-tail items more often than MULT-VAE PR did. In contrast, there was almost no difference between the two approaches on either of the data sets  $ML - 20M$  and Netflix (figures omitted due to page limit).\n\nThe notable improvement of  $\\mathrm{EASE^R}$  over the other models on the MSD data suggests that it is able to better recommend personally relevant items on this data set. On the other hand,  $\\mathrm{EASE^R}$ 's results on the ML-20M and Netflix data suggest that it is also able to make recommendations with an increased focus on popular items. We suspect that  $\\mathrm{EASE^R}$ 's large number of parameters, combined with its constraint regarding self-similarity of items, provides it with sufficient flexibility to adapt to the various data sets. In contrast, the model architectures based on hidden layers with limited capacity seem to be unable to adapt well to the increased degree of personalized relevance in the MSD data.\n\nComparison to neighborhood-based approaches in [24]: Considerable improvements were obtained in [24] by first predicting the scores for all user-item interactions with a neighborhood-based approach ('item-item' in Table 2) that was followed by a low-rank singular value decomposition of the predicted user-item score-matrix ('ii-SVD-500' in Table 2): an increase in NDCG@10 by 0.0156 and 0.0144 compared to the baseline models 'item-item' and WMF, respectively, as reproduced in Table 2. In comparison,  $\\mathrm{EASE}^{\\mathrm{R}}$  obtained increases of 0.0301 and 0.0289 over the baseline models 'item-item' and WMF, respectively, see Table 2. This is about twice as large an improvement as was obtained by the approach 'ii-SVD-500' proposed in [24].\n\nGiven the small size of this training data-set, a large L2-norm regularization was required ( $\\lambda = 3000$ ) for  $\\mathrm{EASE^R}$ . Like in the previous experiments, also here about  $60\\%$  of the learned weights were negative in  $\\mathrm{EASE^R}$ , and setting them to zero ( $\\mathrm{EASE^R} \\geq 0$  in Table 2) resulted in a small decrease in NDCG@10, as expected. In terms of wall-clock time, we found that training  $\\mathrm{EASE^R}$  was about three times faster than computing merely the factorization step in the ii-SVD-500 approach.",
  "hyperparameter": "L2-norm regularization parameter λ: 500 for ML-20M, 1000 for Netflix, 200 for MSD, 3000 for ML-10M (small training set). These values are much larger than typical SLIM values (~1). The model has only a single hyperparameter to tune, unlike SLIM which has both L1 and L2 regularization parameters. The optimal λ depends on dataset size and sparsity, with larger values needed for smaller/sparser datasets."
}