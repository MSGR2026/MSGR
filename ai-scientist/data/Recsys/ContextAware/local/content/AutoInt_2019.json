{
  "id": "AutoInt_2019",
  "paper_title": "AutoInt: Automatic Feature Interaction Learning via Self-Attentive Neural Networks",
  "alias": "AutoInt",
  "year": 2019,
  "domain": "Recsys",
  "task": "ContextAwareRecommendation",
  "idea": "AutoInt proposes a novel automatic feature interaction learning approach using multi-head self-attentive neural networks for CTR prediction. The key innovation is using multi-head self-attention mechanism to explicitly learn arbitrary-order feature interactions in a hierarchical manner, where attention weights automatically identify meaningful feature combinations without manual feature engineering. By stacking multiple interacting layers with residual connections, the model can capture feature interactions from low-order to high-order, while maintaining efficiency through a memory-efficient architecture with O(LHdd') space complexity independent of the number of feature fields.",
  "introduction": "# 1 INTRODUCTION\n\nPredicting the probabilities of users clicking on ads or items (a.k.a., click-through rate prediction) is a critical problem for many applications such as online advertising and recommender systems [8, 10, 15]. The performance of the prediction has a direct impact on the final revenue of the business providers. Due to its importance, it has attracted growing interest in both academia and industry communities.\n\nMachine learning has been playing a key role in click-through rate prediction, which is usually formulated as supervised learning with user profiles and item attributes as input features. The problem is very challenging for several reasons. First, the input features are extremely sparse and high-dimensional [8, 11, 13, 21, 32]. In real-world applications, a considerable percentage of user's demographics and item's attributes are usually discrete and/or categorical. To make supervised learning methods applicable, these features are first converted to a one-hot encoding vector, which can easily result in features with millions of dimensions. Taking the well-known CTR prediction data Criteo<sup>1</sup> as an example, the feature dimension is approximately 30 million with sparsity over  $99.99\\%$ . With such sparse and high-dimensional input features, the machine learning models are easily overfitted. Second, as shown in extensive literature [8, 11, 19, 32], high-order feature interactions<sup>2</sup>\n\nare crucial for a good performance. For example, it is reasonable to recommend Mario Bros., a famous video game, to David, who is a ten-year-old boy. In this case, the third-order combinatorial feature  $<$  Gender  $\\equiv$  Male, Age  $\\equiv$  10, ProductCategory  $\\equiv$  VideoGame  $\\Rightarrow$  is very informative for prediction. However, finding such meaningful high-order combinatorial features heavily relies on domain experts. Moreover, it is almost impossible to hand-craft all the meaningful combinations [8, 26]. One may ask that we can enumerate all the possible high-order features and let machine learning models select the meaningful ones. However, enumerating all the possible high-order features will exponentially increase the dimension and sparsity of the input features, leading to a more serious problem of model overfitting. Therefore, there has been extensive efforts in the communities in finding low-dimensional representations of the sparse and high-dimensional input features and meanwhile modeling different orders of feature combinations.\n\nFor example, Factorization Machines (FM) [26], which combine polynomial regression models with factorization techniques, are developed to model feature interactions and have been proved effective for various tasks [27, 28]. However, limited by its polynomial fitting time, it is only effective for modeling low-order feature interactions and impractical to capture high-order feature interactions. Recently, many works [8, 11, 13, 38] based on deep neural networks have been proposed to model the high-order feature interactions. Specifically, multiple layers of non-linear neural networks are usually used to capture the high-order feature interactions. However, such kinds of methods suffer from two limitations. First, fully-connected neural networks have been shown inefficient in learning multiplicative feature interactions [4]. Second, since these models learn the feature interactions in an implicit way, they lack good explanation on which feature combinations are meaningful. Therefore, we are looking for an approach that is able to explicitly model different orders of feature combinations, represent the entire features into low-dimensional spaces, and meanwhile offer good model explainability.\n\nIn this paper, we propose such an approach based on the multi-head self-attention mechanism [36]. Our proposed approach learns effective low-dimensional representations of the sparse and high-dimensional input features and is applicable to both the categorical and/or numerical input features. Specifically, both the categorical and numerical features are first embedded into low-dimensional spaces, which reduces the dimension of the input features and meanwhile allows different types of features to interact with each other via vector arithmetic (e.g., summation and inner product). Afterwards, we propose a novel interacting layer to promote the interactions between different features. Within each interacting layer, each feature is allowed to interact with all the other features and is able to automatically identify relevant features to form meaningful higher-order features via the multi-head attention mechanism [36]. Moreover, the multi-head mechanism projects a feature into multiple subspaces, and hence it can capture different feature interactions in different subspaces. Such an interacting layer models the one-step interaction between the features. By stacking multiple interacting layers, we are able to model different orders of feature interactions. In practice, the residual connection [12] is added to the interacting layer, which allows combining different orders of\n\nfeature combinations. We use the attention mechanism for measuring the correlations between features, which offers good model explainability.\n\nTo summarize, in this paper we make the following contributions:\n\n- We propose to study the problem of explicitly learning high-order feature interactions and meanwhile finding models with good explainability for the problem.  \n- We propose a novel approach based on self-attentive neural network, which can automatically learn high-order feature interactions and efficiently handle large-scale high-dimensional sparse data.  \n- We conducted extensive experiments on several real-world data sets. Experimental results on the task of CTR prediction show that our proposed approach not only outperforms existing state-of-the-art approaches for prediction but also offers good model explainability.\n\nOur work is organized as follows. In Section 2, we summarize the related work. Section 3 formally defines our problem. Section 4 presents the proposed approach to learn feature interactions. In Section 5, we present the experimental results and detailed analysis. We conclude this paper and point out the future work in Section 6.",
  "method": "# 4 AUTOINT: AUTOMATIC FEATURE INTERACTION LEARNING\n\nIn this section, we first give an overview of the proposed approach AutoInt, which can automatically learn feature interactions for CTR prediction. Next, we present a comprehensive description of how to learn a low-dimensional representation that models high-order combinatorial features without manual feature engineering.\n\n# 4.1 Overview\n\nThe goal of our approach is to map the original sparse and high-dimensional feature vector into low-dimensional spaces and meanwhile model the high-order feature interactions. As shown in Figure 1, our proposed method takes the sparse feature vector  $\\mathbf{x}$  as input, followed by an embedding layer that projects all features\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-14/c8ae4619-da46-4e14-bea3-f5615a41c4a2/6c64d1070f98bcfdaa0c3574c592ee559e5572b97d4a9bd44cfe49762d3a50ed.jpg)  \nFigure 2: Illustration of input and embedding layer, where both categorical and numerical fields are represented by low-dimensional dense vectors.\n\n(i.e., both categorical and numerical features) into the same low-dimensional space. Next, we feed embeddings of all fields into a novel interacting layer, which is implemented as a multi-head self-attentive neural network. For each interacting layer, high-order features are combined through the attention mechanism, and different kinds of combinations can be evaluated with the multi-head mechanisms, which map the features into different subspaces. By stacking multiple interacting layers, different orders of combinatorial features can be modeled.\n\nThe output of the final interacting layer is the low-dimensional representation of the input feature, which models the high-order combinatorial features and is further used for estimating the click-through rate through a sigmoid function. Next, we introduce the details of our proposed method.\n\n# 4.2 Input Layer\n\nWe first represent user's profiles and item's attributes as a sparse vector, which is the concatenation of all fields. Specifically,\n\n$$\n\\mathbf {x} = \\left[ \\mathbf {x} _ {1}; \\mathbf {x} _ {2}; \\dots ; \\mathbf {x} _ {\\mathrm {M}} \\right], \\tag {1}\n$$\n\nwhere  $M$  is the number of total feature fields, and  $\\mathbf{x_i}$  is the feature representation of the  $i$ -th field.  $\\mathbf{x_i}$  is a one-hot vector if the  $i$ -th field is categorical (e.g.,  $\\mathbf{x_1}$  in Figure 2).  $\\mathbf{x_i}$  is a scalar value if the  $i$ -th field is numerical (e.g.,  $\\mathbf{x_M}$  in Figure 2).\n\n# 4.3 Embedding Layer\n\nSince the feature representations of the categorical features are very sparse and high-dimensional, a common way is to represent them into low-dimensional spaces (e.g., word embeddings). Specifically, we represent each categorical feature with a low-dimensional vector, i.e.,\n\n$$\n\\mathbf {e} _ {\\mathrm {i}} = \\mathbf {V} _ {\\mathrm {i}} \\mathbf {x} _ {\\mathrm {i}}, \\tag {2}\n$$\n\nwhere  $\\mathbf{V}_{\\mathrm{i}}$  is an embedding matrix for field  $i$ , and  $\\mathbf{x_i}$  is an one-hot vector. Often times categorical features can be multi-valued, i.e.,  $\\mathbf{x_{i}}$  is a multi-hot vector. Take movie watching prediction as an example, there could be a feature field Genre which describes the types of a movie and it may be multi-valued (e.g., Drama and Romance for movie \"Titanic\"). To be compatible with multi-valued inputs, we further modify the Equation 2 and represent the multi-valued feature field as the average of corresponding feature embedding vectors:\n\n$$\n\\mathbf {e} _ {\\mathrm {i}} = \\frac {1}{q} \\mathbf {V} _ {\\mathrm {i}} \\mathbf {x} _ {\\mathrm {i}}, \\tag {3}\n$$\n\nwhere  $q$  is the number of values that a sample has for  $i$ -th field and  $\\mathbf{x}_i$  is the multi-hot vector representation for this field.\n\nTo allow the interaction between categorical and numerical features, we also represent the numerical features in the same low-dimensional feature space. Specifically, we represent the numerical\n\nfeature as\n\n$$\n\\mathbf {e} _ {\\mathbf {m}} = \\mathbf {v} _ {\\mathbf {m}} x _ {m}, \\tag {4}\n$$\n\nwhere  $\\mathbf{v}_{\\mathbf{m}}$  is an embedding vector for field  $m$ , and  $x_{m}$  is a scalar value.\n\nBy doing this, the output of the embedding layer would be a concatenation of multiple embedding vectors, as presented in Figure 2.\n\n# 4.4 Interacting Layer\n\nOnce the numerical and categorical features live in the same low-dimensional space, we move to model high-order combinatorial features in the space. The key problem is to determine which features should be combined to form meaningful high-order features. Traditionally, this is accomplished by domain experts who create meaningful combinations based on their knowledge. In this paper, we tackle this problem with a novel method, the multi-head self-attention mechanism [36].\n\nMulti-head self-attentive network [36] has recently achieved remarkable performance in modeling complicated relations. For example, it shows superiority for modeling arbitrary word dependency in machine translation [36] and sentence embedding [20], and has been successfully applied to capturing node similarities in graph embedding [37]. Here we extend this latest technique to model the correlations between different feature fields.\n\nSpecifically, we adopt the key-value attention mechanism [22] to determine which feature combinations are meaningful. Taking the feature  $m$  as an example, next we explain how to identify multiple meaningful high-order features involving feature  $m$ . We first define the correlation between feature  $m$  and feature  $k$  under a specific attention head  $h$  as follows:\n\n$$\n\\alpha_ {\\mathbf {m}, \\mathbf {k}} ^ {(\\mathrm {h})} = \\frac {\\exp \\left(\\psi^ {(h)} \\left(\\mathbf {e} _ {\\mathbf {m}} , \\mathbf {e} _ {\\mathbf {k}}\\right)\\right)}{\\sum_ {l = 1} ^ {M} \\exp \\left(\\psi^ {(h)} \\left(\\mathbf {e} _ {\\mathbf {m}} , \\mathbf {e} _ {\\mathbf {l}}\\right)\\right)}, \\tag {5}\n$$\n\n$$\n\\psi^ {(h)} (\\mathbf {e _ {m}}, \\mathbf {e _ {k}}) = \\langle \\mathbf {W} _ {\\mathrm {Q u e r y}} ^ {(\\mathrm {h})} \\mathbf {e _ {m}}, \\mathbf {W} _ {\\mathrm {K e y}} ^ {(\\mathrm {h})} \\mathbf {e _ {k}} \\rangle ,\n$$\n\nwhere  $\\psi^{(h)}(\\cdot ,\\cdot)$  is an attention function which defines the similarity between the feature  $m$  and  $k$ . It can be defined as a neural network or as simple as inner product, i.e.,  $\\langle \\cdot ,\\cdot \\rangle$ . In this work, we use inner product due to its simplicity and effectiveness.  $\\mathbf{W}_{\\mathrm{Query}}^{\\mathrm{(h)}},\\mathbf{W}_{\\mathrm{Key}}^{\\mathrm{(h)}}\\in \\mathbb{R}^{d'\\times d}$  in Equation 5 are transformation matrices which map the original embedding space  $\\mathbb{R}^d$  into a new space  $\\mathbb{R}^{d'}$ . Next, we update the representation of feature  $m$  in subspace  $h$  via combining all relevant features guided by coefficients  $\\alpha_{\\mathbf{m},\\mathbf{k}}^{\\mathrm{(h)}}$ :\n\n$$\n\\widetilde {\\mathbf {e}} _ {\\mathbf {m}} ^ {(\\mathrm {h})} = \\sum_ {k = 1} ^ {M} \\alpha_ {\\mathbf {m}, \\mathbf {k}} ^ {(\\mathrm {h})} \\left(\\mathbf {W} _ {\\text {V a l u e}} ^ {(\\mathrm {h})} \\mathbf {e} _ {\\mathbf {k}}\\right), \\tag {6}\n$$\n\nwhere  $\\mathbf{W}_{\\mathrm{Value}}^{(\\mathrm{h})} \\in \\mathbb{R}^{d' \\times d}$ .\n\nSince  $\\widetilde{\\mathbf{e}}_{\\mathbf{m}}^{\\mathrm{(h)}} \\in \\mathbb{R}^{d'}$  is a combination of feature  $m$  and its relevant features (under head  $h$ ), it represents a new combinatorial feature learned by our method. Furthermore, a feature is also likely to be involved in different combinatorial features, and we achieve this by using multiple heads, which create different subspaces and learn distinct feature interactions separately. We collect combinatorial features learned in all subspaces as follows:\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-14/c8ae4619-da46-4e14-bea3-f5615a41c4a2/aaf415d21ddb1e770ae46c1913c0f14b917e97418ef827e8dbc9644cf0a6bdd9.jpg)  \nFigure 3: The architecture of interacting layer. Combinatorial features are conditioned on attention weights, i.e.,  $\\alpha_{\\mathrm{m}}^{(\\mathrm{h})}$ .\n\n$$\n\\widetilde {\\mathbf {e}} _ {\\mathbf {m}} = \\widetilde {\\mathbf {e}} _ {\\mathbf {m}} ^ {(1)} \\oplus \\widetilde {\\mathbf {e}} _ {\\mathbf {m}} ^ {(2)} \\oplus \\dots \\oplus \\widetilde {\\mathbf {e}} _ {\\mathbf {m}} ^ {(\\mathrm {H})}, \\tag {7}\n$$\n\nwhere  $\\oplus$  is the concatenation operator, and H is the number of total heads.\n\nTo preserve previously learned combinatorial features, including raw individual (i.e., first-order) features, we add standard residual connections in our network. Formally,\n\n$$\n\\mathbf {e} _ {\\mathbf {m}} ^ {\\mathrm {R e s}} = \\operatorname {R e L U} \\left(\\overline {{\\mathbf {e}}} _ {\\mathbf {m}} + \\mathbf {W} _ {\\mathrm {R e s}} \\mathbf {e} _ {\\mathbf {m}}\\right), \\tag {8}\n$$\n\nwhere  $\\mathbf{W}_{\\mathrm{Res}} \\in \\mathbb{R}^{d'H \\times d}$  is the projection matrix in case of dimension mismatching [12], and  $ReLU(z) = max(0, z)$  is a non-linear activation function.\n\nWith such an interacting layer, the representation of each feature  $\\mathbf{e}_{\\mathfrak{m}}$  will be updated into a new feature representation  $\\mathbf{e}_{\\mathfrak{m}}^{\\mathrm{Res}}$ , which is a representation of high-order features. We can stack multiple such layers with the output of the previous interacting layer as the input of the next interacting layer. By doing this, we can model arbitrary-order combinatorial features.\n\n# 4.5 Output Layer\n\nThe output of the interacting layer is a set of feature vectors  $\\{\\mathbf{e}_{\\mathbf{m}}^{\\mathrm{Res}}\\}_{m = 1}^{M}$ , which includes raw individual features reserved by residual block and combinatorial features learned via the multi-head self-attention mechanism. For final CTR prediction, we simply concatenate all of them and then apply a non-linear projection as follows:\n\n$$\n\\hat {y} = \\sigma \\left(\\mathbf {w} ^ {\\mathrm {T}} \\left(\\mathbf {e} _ {1} ^ {\\text {R e s}} \\oplus \\mathbf {e} _ {2} ^ {\\text {R e s}} \\oplus \\dots \\oplus \\mathbf {e} _ {\\mathbf {M}} ^ {\\text {R e s}}\\right) + b\\right), \\tag {9}\n$$\n\nwhere  $\\mathbf{w} \\in \\mathbb{R}^{d^{\\prime}HM}$  is a column projection vector which linearly combines concatenated features,  $b$  is the bias, and  $\\sigma(x) = 1/(1 + e^{-x})$  transforms the values to users clicking probabilities.\n\n# 4.6 Training\n\nOur loss function is Log loss, which is defined as follows:\n\n$$\n\\operatorname {L o g l o s s} = - \\frac {1}{N} \\sum_ {j = 1} ^ {N} \\left(y _ {j} \\log \\left(\\hat {y} _ {j}\\right) + \\left(1 - y _ {j}\\right) \\log \\left(1 - \\hat {y} _ {j}\\right)\\right), \\tag {10}\n$$\n\nwhere  $y_{j}$  and  $\\hat{y}_j$  are ground truth of user clicks and estimated CTR respectively,  $j$  indexes the training samples, and  $N$  is the total number of training samples. The parameters to learn in our model\n\nare  $\\{\\mathbf{V_i},\\mathbf{v_m},\\mathbf{W}_{\\mathrm{Query}}^{\\mathrm{(h)}},\\mathbf{W}_{\\mathrm{Key}}^{\\mathrm{(h)}},\\mathbf{W}_{\\mathrm{Value}}^{\\mathrm{(h)}},\\mathbf{W}_{\\mathrm{Res}},\\mathbf{w},b\\}$ , which are updated via minimizing the total Logloss using gradient descent.\n\n# 4.7 Analysis Of AutoInt\n\nModeling Arbitrary Order Combinatorial Features. Given feature interaction operator defined by Equation 5 - 8, we now analyze how low-order and high-order combinatorial features are modeled in our proposed model.\n\nFor simplicity, let's assume there are four feature fields (i.e.,  $M = 4$ ) denoted by  $x_{1}, x_{2}, x_{3}$  and  $x_{4}$  respectively. Within the first interacting layer, each individual feature interacts with any other features through attention mechanism (i.e. Equation 5) and therefore a set of second-order feature combinations such as  $g(x_{1}, x_{2}), g(x_{2}, x_{3})$  and  $g(x_{3}, x_{4})$  are captured with distinct correlation weights, where the non-additive property of interaction function  $g(\\cdot)$  (in DEFINITION 2) can be ensured by the non-linearity of activation function  $ReLU(\\cdot)$ . Ideally, combinatorial features that involve  $x_{1}$  can be encoded into the updated representation of the first feature field  $\\mathbf{e}_{1}^{\\mathrm{Res}}$ . As the same can be derived for other feature fields, all second-order feature interactions can be encoded in the output of the first interacting layer, where attention weights distill useful feature combinations.\n\nNext, we prove that higher-order feature interactions can be modeled within the second interacting layer. Given the representation of the first feature field  $\\mathbf{e}_1^{\\mathrm{Res}}$  and the representation of the third feature field  $\\mathbf{e}_3^{\\mathrm{Res}}$  generated by the first interacting layer, third-order combinatorial features that involve  $x_{1}, x_{2}$  and  $x_{3}$  can be modeled by allowing  $\\mathbf{e}_1^{\\mathrm{Res}}$  to attend on  $\\mathbf{e}_3^{\\mathrm{Res}}$  because  $\\mathbf{e}_1^{\\mathrm{Res}}$  contains the interaction  $g(x_{1}, x_{2})$  and  $\\mathbf{e}_3^{\\mathrm{Res}}$  contains the individual feature  $x_{3}$  (from residual connection). Moreover, the maximum order of combinatorial features grows exponentially with respect to the number of interacting layers. For example, fourth-order feature interaction  $g(x_{1}, x_{2}, x_{3}, x_{4})$  can be captured by the combination of  $\\mathbf{e}_1^{\\mathrm{Res}}$  and  $\\mathbf{e}_3^{\\mathrm{Res}}$ , which contain the second-order interactions  $g(x_{1}, x_{2})$  and  $g(x_{3}, x_{4})$  respectively. Therefore a few interacting layers will suffice to model high-order feature interactions.\n\nBased on above analysis, we can see that AutoInt learns feature interactions with attention mechanism in a hierarchical manner, i.e., from low-order to high-order, and all low-order feature interactions are carried by residual connections. This is promising and reasonable because learning hierarchical representation has proven quite effective in computer vision and speech processing with deep neural networks [3, 18].\n\nSpace Complexity. The embedding layer, which is a shared component in neural network-based methods [11, 19, 32], contains  $nd$  parameters, where  $n$  is the dimension of sparse representation of input feature and  $d$  is the embedding size. As an interacting layer contains following weight matrices:  $\\{\\mathbf{W}_{\\mathrm{Query}}^{\\mathrm{(h)}}, \\mathbf{W}_{\\mathrm{Key}}^{\\mathrm{(h)}}, \\mathbf{W}_{\\mathrm{Value}}^{\\mathrm{(h)}}, \\mathbf{W}_{\\mathrm{Res}}\\}$ , the number of parameters in an  $L$ -layer network is  $L \\times (3dd' + d'Hd)$ , which is independent of the number of feature fields  $M$ . Finally, there are  $d'HM + 1$  parameters in the output layer. As far as interacting layers are concerned, the space complexity is  $O(Ldd'H)$ . Note that  $H$  and  $d'$  are usually small (e.g.,  $H = 2$  and  $d' = 32$  in our experiments), which makes the interacting layer memory-efficient.\n\nTime Complexity. Within each interacting layer, the computation cost is two-fold. First, calculating attention weights for one head\n\ntakes  $O(Mdd' + M^2 d')$  time. Afterwards, forming combinatorial features under one head also takes  $O(Mdd' + M^2 d')$  time. Because we have  $H$  heads, it takes  $O(MHd'(M + d))$  time altogether. It is therefore efficient because  $H, d$  and  $d'$  are usually small. We provide running time of AutoInt in Section 5.2.",
  "experiments": "# 5 EXPERIMENT\n\nIn this section, we move forward to evaluate the effectiveness of our proposed approach. We aim to answer the following questions:\n\nRQ1 How does our proposed AutoInt perform on the problem of CTR prediction? Is it efficient for large-scale sparse and high-dimensional data?\n\nRQ2 What are the influences of different model configurations?  \nRQ3 What are the dependency structures between different features? Is our proposed model explainable?  \nRQ4 Will integrating implicit feature interactions further improve the performance?\n\nWe first describe the experimental settings before answering these questions.\n\n# 5.1 Experiment Setup\n\n5.1.1 Data Sets. We use four public real-world data sets. The statistics of the data sets are summarized in Table 1. Criteo<sup>3</sup> This is a benchmark dataset for CTR prediction, which has 45 million users' clicking records on displayed ads. It contains 26 categorical feature fields and 13 numerical feature fields. Avazu<sup>4</sup> This dataset contains users' mobile behaviors including whether a displayed mobile ad is clicked by a user or not. It has 23 feature fields spanning from user/device features to ad attributes. KDD12<sup>5</sup> This data set was released by KDDCup 2012, which originally aimed to predict the number of clicks. Since our work focuses on CTR prediction rather than the exact number of clicks, we treat this problem as a binary classification problem (1 for clicks  $>0$ , 0 for without click), which is similar to FFM [16]. MovieLens-1M<sup>6</sup> This dataset contains users' ratings on movies. During binarization, we treat samples with a rating less than 3 as negative samples because a low score indicates that the user does not like the movie. We treat samples with a rating greater than 3 as positive samples and remove neutral samples, i.e., a rating equal to 3.\n\nData Preparation First, we remove the infrequent features (appearing in less than threshold instances) and treat them as a single feature \"<unknown>\", where threshold is set to \\{10, 5, 10\\} for Criteo, Avazu and KDD12 data sets respectively. Second, since numerical features may have large variance and hurt machine learning algorithms, we normalize numerical values by transforming a value  $z$  to  $\\log^2(z)$  if  $z > 2$ , which is proposed by the winner of Criteo Competition<sup>7</sup>. Third, we randomly select  $80\\%$  of all samples for training and randomly split the rest into validation and test sets of equal size.\n\n5.1.2 Evaluation Metrics. We use two popular metrics to evaluate the performance of all methods.\n\n<sup>3</sup>https://www.kaggle.com/c/criteo-display-ad-challenge  \n4https://www.kaggle.com/c/avazu-ctr-prediction  \n<sup>5</sup>https://www.kaggle.com/c/kddcup2012-track2  \n$^{6}$ https://grouplens.org/datasets/movielens/  \n<sup>7</sup>https://www.csie.ntu.edu.tw/~r01922136/kaggle-2014-criteo.pdf\n\nTable 1: Statistics of evaluation data sets.  \n\n<table><tr><td>Data</td><td>#Samples</td><td>#Fields</td><td>#Features (Sparse)</td></tr><tr><td>Criteo</td><td>45,840,617</td><td>39</td><td>998,960</td></tr><tr><td>Avazu</td><td>40,428,967</td><td>23</td><td>1,544,488</td></tr><tr><td>KDD12</td><td>149,639,105</td><td>13</td><td>6,019,086</td></tr><tr><td>MovieLens-1M</td><td>739,012</td><td>7</td><td>3,529</td></tr></table>\n\nAUC Area Under the ROC Curve (AUC) measures the probability that a CTR predictor will assign a higher score to a randomly chosen positive item than a randomly chosen negative item. A higher AUC indicates a better performance.\n\nLogloss Since all models attempt to minimize the Logloss defined by Equation 10, we use it as a straightforward metric.\n\nIt is noticeable that a slightly higher AUC or lower Logloss at 0.001-level is regarded significant for CTR prediction task, which has also been pointed out in existing works [8, 11, 38].\n\n5.1.3 Competing Models. We compare the proposed approach with three classes of previous models. (A) the linear approach that only uses individual features. (B) factorization machines-based methods that take into account second-order combinatorial features. (C) techniques that can capture high-order feature interactions. We associate the model classes with model names accordingly.\n\nLR (A). LR only models the linear combination of raw features.\n\nFM [26] (B). FM uses factorization techniques to model second-order feature interactions.\n\nAFM [40] (B). AFM is one of the state-of-the-art models that capture second-order feature interactions. It extends FM by using attention mechanism to distinguish the different importance of second-order combinatorial features.\n\nDeepCrossing [32] (C). DeepCrossing utilizes deep fully-connected neural networks with residual connections to learn non-linear feature interactions in an implicit fashion.\n\nNFM [13] (C). NFM stacks deep neural networks on top of second-order feature interaction layer. High-order feature interactions are implicitly captured by the nonlinearity of neural networks.\n\nCrossNet [38] (C). Cross Network, which is the core of Deep&Cross model, takes outer product of concatenated feature vector at the bit-wise level to model feature interactions explicitly.\n\nCIN [19] (C). Compressed Interaction Network, which is the core of xDeepFM model, takes outer product of stacked feature matrix at vector-wise level.\n\nHOFM [5] (C). HOFM proposes efficient kernel-based algorithms for training high-order factorization machines. Follow settings in Blondel et al. [5] and He and Chua [13], we build a third-order factorization machine using public implementation.\n\nWe will compare with the full models of CrossNet and CIN, i.e., Deep&Cross and xDeepFM, under the setting of joint training with plain DNN later (i.e., Section 5.5).\n\n5.1.4 Implementation Details. All methods are implemented in TensorFlow[1]. For AutoInt and all baseline methods, we empirically set embedding dimension  $d$  to 16 and batch size to 1024. AutoInt has three interacting layers and the number of hidden units  $d'$  is 32 in default setting. Within each interacting layer, the number of\n\nTable 2: Effectiveness Comparison of Different Algorithms. We highlight that our proposed model almost outperforms all baselines across four data sets and both metrics. Further analysis is provided in Section 5.2.  \n\n<table><tr><td rowspan=\"2\">Model Class</td><td rowspan=\"2\">Model</td><td colspan=\"2\">Criteo</td><td colspan=\"2\">Avazu</td><td colspan=\"2\">KDD12</td><td colspan=\"2\">MovieLens-1M</td></tr><tr><td>AUC</td><td>Logloss</td><td>AUC</td><td>Logloss</td><td>AUC</td><td>Logloss</td><td>AUC</td><td>Logloss</td></tr><tr><td>First-order</td><td>LR</td><td>0.7820</td><td>0.4695</td><td>0.7560</td><td>0.3964</td><td>0.7361</td><td>0.1684</td><td>0.7716</td><td>0.4424</td></tr><tr><td rowspan=\"2\">Second-order</td><td>FM [26]</td><td>0.7836</td><td>0.4700</td><td>0.7706</td><td>0.3856</td><td>0.7759</td><td>0.1573</td><td>0.8252</td><td>0.3998</td></tr><tr><td>AFM[40]</td><td>0.7938</td><td>0.4584</td><td>0.7718</td><td>0.3854</td><td>0.7659</td><td>0.1591</td><td>0.8227</td><td>0.4048</td></tr><tr><td rowspan=\"6\">High-order</td><td>DeepCrossing [32]</td><td>0.8009</td><td>0.4513</td><td>0.7643</td><td>0.3889</td><td>0.7715</td><td>0.1591</td><td>0.8448</td><td>0.3814</td></tr><tr><td>NFM [13]</td><td>0.7957</td><td>0.4562</td><td>0.7708</td><td>0.3864</td><td>0.7515</td><td>0.1631</td><td>0.8357</td><td>0.3883</td></tr><tr><td>CrossNet [38]</td><td>0.7907</td><td>0.4591</td><td>0.7667</td><td>0.3868</td><td>0.7773</td><td>0.1572</td><td>0.7968</td><td>0.4266</td></tr><tr><td>CIN [19]</td><td>0.8009</td><td>0.4517</td><td>0.7758</td><td>0.3829</td><td>0.7799</td><td>0.1566</td><td>0.8286</td><td>0.4108</td></tr><tr><td>HOFM [5]</td><td>0.8005</td><td>0.4508</td><td>0.7701</td><td>0.3854</td><td>0.7707</td><td>0.1586</td><td>0.8304</td><td>0.4013</td></tr><tr><td>AutoInt (ours)</td><td>0.8061**</td><td>0.4455**</td><td>0.7752</td><td>0.3824</td><td>0.7883**</td><td>0.1546**</td><td>0.8456*</td><td>0.3797**</td></tr></table>\n\nAutoInt outperforms the strongest baseline w.r.t. Criteo, KDD12 and MovieLens-1M data at the: \\*\\* 0.01 and \\* 0.05 level, unpaired t-test.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-14/c8ae4619-da46-4e14-bea3-f5615a41c4a2/aad104e639ee8ac90eddbeeda47c5df654c9e20d597cf1d2427ba6b355ceac6b.jpg)  \n(a) Criteo\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-14/c8ae4619-da46-4e14-bea3-f5615a41c4a2/1c3213a52829b9537f0d1d724f8abaded6f7112c2e3c86d5fbfc6e03dd8dba30.jpg)  \n(b) Avazu  \nFigure 4: Efficiency Comparison of Different Algorithms in terms of Run Time. \"DC\" and \"CN\" are DeepCrossing and CrossNet for short, respectively. Since HOFM cannot be fit on one GPU card for the KDD12 dataset, extra communication cost makes it most time-consuming. Further analysis is presented in Section 5.2.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-14/c8ae4619-da46-4e14-bea3-f5615a41c4a2/d5c3cae438c9ee0f1d6b514aa544a71497653a0362a5c64a581be1e988cbca8a.jpg)  \n(c) KDD12\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-14/c8ae4619-da46-4e14-bea3-f5615a41c4a2/cffbb964bbb639a3b03d6a5b7b88d13f5718ee6365f2927eefdb25ca150b44ac.jpg)  \n(d) MovieLens-1M\n\nattention head is two $^{8}$ . To prevent overfitting, we use grid search to select dropout rate [34] from  $\\{0.1 - 0.9\\}$  for MovieLens-1M data set, and we found dropout is not necessary for other three large data sets. For baseline methods, we use one hidden layer of size 200 on top of Bi-Interaction layer for NFM as recommended by their paper. For CN and CIN, we use three interaction layers following AutoInt. DeepCrossing has four feed-forward layers and the number of hidden units is 100, because it performs poorly when using three neural layers. Once all network structures are fixed, we also apply grid search to baseline methods for optimal hype-parameters. Finally, we use Adam [17] to optimize all deep neural network-based models.\n\n# 5.2 Quantitative Results (RQ1)\n\n# Evaluation of Effectiveness\n\nWe summarize the results averaged over 10 different runs into Table 2. We have the following observations: (1) FM and AFM, which explore second-order feature interactions, consistently outperform LR by a large margin on all datasets, which indicates that individual features are insufficient in CTR prediction. (2) An interesting observation is the inferiority of some models which capture high-order feature interactions. For example, although DeepCrossing\n\nand NFM use the deep neural network as a core component to learning high-order feature interactions, they do not guarantee improvement over FM and AFM. This may attribute to the fact that they learn feature interactions in an implicit fashion. On the contrary, CIN does it explicitly and outperforms low-order models consistently. (3) HOFM significantly outperforms FM on Criteo and MovieLens-1M datasets, which indicates that modeling third-order feature interactions can be beneficial to prediction performance. (4) AutoInt achieves the best performance overall baseline methods on three of four real-world data sets. On Avazu data set, CIN performs a little better than AutoInt in AUC evaluation, but we get lower Logloss. Note that our proposed AutoInt shares the same structures as DeepCrossing except the feature interacting layer, which indicates using the attention mechanism to learn explicit combinatorial features is crucial.\n\n# Evaluation of Model Efficiency\n\nWe present the runtime results of different algorithms on four data sets in Figure 4. Unsurprisingly, LR is the most efficient algorithm due to its simplicity. FM and NFM perform similarly in terms of runtime because NFM only stacks a single feed-forward hidden layer on top of the second-order interaction layer. Among all listed methods, CIN, which achieves the best performance for prediction among all the baselines, is much more time-consuming due to its complicated crossing layer. This may make it impractical in the\n\nTable 3: Efficiency Comparison of Different Algorithms in terms of Model Size on Criteo data set. \"DC\" and \"CN\" are DeepCrossing and CrossNet for short, respectively. The counted parameters exclude the embedding layer.  \n\n<table><tr><td>Model</td><td>DC</td><td>CN</td><td>CIN</td><td>NFM</td><td>AutoInt</td></tr><tr><td>#Params</td><td>1.6 × 105</td><td>3 × 103</td><td>1.9 × 106</td><td>4 × 103</td><td>3.9 × 104</td></tr></table>\n\nTable 4: Ablation study comparing the performance of AutoInt with and without residual connections. AutoIntw/ is the complete model while the AutoIntw/o is the model without residual connection.  \n\n<table><tr><td>Data Sets</td><td>Models</td><td>AUC</td><td>Logloss</td></tr><tr><td rowspan=\"2\">Criteo</td><td>\\( AutoInt_{w/} \\)</td><td>0.8061</td><td>0.4454</td></tr><tr><td>\\( AutoInt_{w/o} \\)</td><td>0.8033</td><td>0.4478</td></tr><tr><td rowspan=\"2\">Avazu</td><td>\\( AutoInt_{w/} \\)</td><td>0.7752</td><td>0.3823</td></tr><tr><td>\\( AutoInt_{w/o} \\)</td><td>0.7729</td><td>0.3836</td></tr><tr><td rowspan=\"2\">KDD12</td><td>\\( AutoInt_{w/} \\)</td><td>0.7888</td><td>0.1545</td></tr><tr><td>\\( AutoInt_{w/o} \\)</td><td>0.7831</td><td>0.1557</td></tr><tr><td rowspan=\"2\">MovieLens-1M</td><td>\\( AutoInt_{w/} \\)</td><td>0.8460</td><td>0.3784</td></tr><tr><td>\\( AutoInt_{w/o} \\)</td><td>0.8299</td><td>0.3959</td></tr></table>\n\nindustrial scenarios. Note that AutoInt is sufficiently efficient, which is comparable to the efficient algorithms DeepCrossing and NFM.\n\nWe also compare the sizes of different models (i.e., the number of parameters) as another criterion for efficiency evaluation. As shown in Table 3, comparing to the best model CIN in the baseline models, the number of parameters in AutoInt is much smaller.\n\nTo summarize, our proposed AutoInt achieves the best performance among all the compared models. Compared to the most competitive baseline model CIN, AutoInt requires much fewer parameters and is much more efficient during online inference.\n\n# 5.3 Analysis (RQ2)\n\nTo further validate and gain deep insights into the proposed model, we conduct ablation study and compare several variants of AutoInt.\n\n5.3.1 Influence of Residual Structure. The standard AutoInt utilizes residual connections, which carry through all learned combinatorial features and therefore allow modeling very high-order combinations. To justify the contribution of residual units, we tease apart them from our standard model and keep other structures as they are. As presented in Table 4, we observe that the performance decrease on all datasets if residual connections are removed. Specifically, the full model outperforms the variant by a large margin on the KDD12 and MovieLens-1M data, which indicates residual connections are crucial to model high-order feature interactions in our proposed method.\n\n5.3.2 Influence of Network Depths. Our model learns high-order feature combinations by stacking multiple interacting layers (introduced in Section 4). Therefore, we are interested in how the performance change w.r.t. the number of interacting layers, i.e., the order of combinatorial features. Note that when there is no interacting layer (i.e., Number of layers equals zero), our model\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-14/c8ae4619-da46-4e14-bea3-f5615a41c4a2/49c1e529f76d954305d9a011ee23933c322d93d62f051c47fb0f217c17aeff7c.jpg)  \n(a) AUC\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-14/c8ae4619-da46-4e14-bea3-f5615a41c4a2/fe3d170c0175bbc401843601bf0945592a01ce3802f69351276381cfc0b7d931.jpg)  \n(b) Logloss\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-14/c8ae4619-da46-4e14-bea3-f5615a41c4a2/3ffbb278e934aa6c70fa39b84f4ad33db93bda6b572bb4bbadb6ee801e1982f1.jpg)  \nFigure 5: Performance w.r.t. the number of interacting layers. Results on Criteo and Avazu data sets are similar and hence omitted.  \n(a) AUC\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-14/c8ae4619-da46-4e14-bea3-f5615a41c4a2/62dc51dfd6d8911387b45887e18a76541f5a9f2f1bccc995d7977e721f536bd5.jpg)  \n(b) Logloss  \nFigure 6: Performance w.r.t. number of embedding dimensions. Results on Criteo and Avazu data sets are similar and hence omitted.\n\ntakes the weighted sum of raw individual features as input, i.e., no combinatorial features are considered.\n\nThe results are summarized in Figure 5. We can see that if one interacting layer is used, i.e., feature interactions are taken into account, the performance increase dramatically on both data sets, showing that combinatorial features are very informative for prediction. As the number of interacting layers further increases, i.e., higher-order combinatorial features are taken into account, the performance of the model further increases. When the number of layers reaches three, the performance becomes stable, showing that adding extremely high-order features are not informative for prediction.\n\n5.3.3 Influence of Different Dimensions. Next, we investigate the performance w.r.t. the parameter  $d$ , which is the output dimension of the embedding layer. On the KDD12 dataset, we can see that the performance continuously increase as we increase the dimension size since larger models are used for prediction. The results are different on the MovieLens-1M dataset. When the dimension size reaches 24, the performance begins to decrease. The reason is that this data set is small, and the model is overfitted when too many parameters are used.\n\n# 5.4 Explainable Recommendations (RQ3)\n\nA good recommender system can not only provide good recommendations but also offer good explainability. Therefore, in this part, we present how our AutoInt is able to explain the recommendation results. We take the MovieLens-1M dataset as an example.\n\nLet's look at a recommendation result suggested by our algorithm, i.e., a user likes an item. Figure 7 (a) presents the correlations between different fields of input features, which are obtained by\n\nTable 5: Results of Integrating Implicit Feature Interactions. We indicate the base model behind each method. The last two columns are average changes of AUC and Logloss compared to corresponding base models  $(^{+}):$  increase,  $-$  : decrease).  \n\n<table><tr><td rowspan=\"2\">Model</td><td colspan=\"2\">Criteo</td><td colspan=\"2\">Avazu</td><td colspan=\"2\">KDD12</td><td colspan=\"2\">MovieLens-1M</td><td colspan=\"2\">Avg. Changes</td></tr><tr><td>AUC</td><td>Logloss</td><td>AUC</td><td>Logloss</td><td>AUC</td><td>Logloss</td><td>AUC</td><td>Logloss</td><td>AUC</td><td>Logloss</td></tr><tr><td>Wide&amp;Deep (LR)</td><td>0.8026</td><td>0.4494</td><td>0.7749</td><td>0.3824</td><td>0.7549</td><td>0.1619</td><td>0.8300</td><td>0.3976</td><td>+0.0292</td><td>-0.0213</td></tr><tr><td>DeepFM (FM)</td><td>0.8066</td><td>0.4449</td><td>0.7751</td><td>0.3829</td><td>0.7867</td><td>0.1549</td><td>0.8437</td><td>0.3846</td><td>+0.0142</td><td>-0.0113</td></tr><tr><td>Deep&amp;Cross (CN)</td><td>0.8067</td><td>0.4447</td><td>0.7731</td><td>0.3836</td><td>0.7872</td><td>0.1549</td><td>0.8446</td><td>0.3809</td><td>+0.0200</td><td>-0.0164</td></tr><tr><td>xDeepFM (CIN)</td><td>0.8070</td><td>0.4447</td><td>0.7770</td><td>0.3823</td><td>0.7820</td><td>0.1560</td><td>0.8463</td><td>0.3808</td><td>+0.0068</td><td>-0.0096</td></tr><tr><td>AutoInt+ (ours)</td><td>0.8083**</td><td>0.4434**</td><td>0.7774*</td><td>0.3811**</td><td>0.7898**</td><td>0.1543**</td><td>0.8488**</td><td>0.3753**</td><td>+0.0023</td><td>-0.0020</td></tr></table>\n\nAutoInt+ outperforms the strongest baseline w.r.t. each data at the: \\*\\* 0.01 and \\* 0.05 level, unpaired t-test.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-14/c8ae4619-da46-4e14-bea3-f5615a41c4a2/5afaecaef786a15e2d08a45f70149a88f0b6ba764cd9b22e43402181175dc6aa.jpg)  \n(a) Label  $= 1$ , Predicted  $\\mathrm{CTR} = 0.89$  (b) Overall feature interactions Figure 7: Heat maps of attention weights for both case- and global-level feature interactions on MovieLens-1M. The axes represent feature fields <Gender, Age, Occupation, Zip code, RequestTime, ReleaseTime, Genre>. We highlight some learned combinatorial features in rectangles.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-14/c8ae4619-da46-4e14-bea3-f5615a41c4a2/e32e2dd826bee4b2ebff419153132c35d8d7793331eab8e546bc51c7c88eb550.jpg)\n\nthe attention score. We can see that AutoInt is able to identify the meaningful combinatorial feature  $<$  Gender  $\\equiv$  Male, Age  $\\equiv$  [18-24), MovieGenre  $\\equiv$  Action&Triller> (i.e., red dotted rectangle). This is very reasonable since young men are very likely to prefer action&triller movies.\n\nWe are also interested in what the correlations between different feature fields in the data are. Therefore, we measure the correlations between the feature fields according to their average attention score in the entire data. The correlations between different fields are summarized into Figure 7 (b). We can see that  $\\langle Gender, Genre \\rangle$ ,  $\\langle Age, Genre \\rangle$ ,  $\\langle RequestTime, ReleaseTime \\rangle$  and  $\\langle Gender, Age, Genre \\rangle$  (i.e., solid green region) are strongly correlated, which are the explainable rules for recommendation in this domain.\n\n# 5.5 Integrating Implicit Interactions (RQ4)\n\nFeed-forward neural networks are capable of modeling implicit feature interactions and have been widely integrated into existing CTR prediction methods [8, 11, 19]. To investigate whether integrating implicit feature interactions further improves the performance, we combine AutoInt with a two-layer feed-forward neural network by joint training. We name the joint model AutoInt+ and compare it with the following algorithms:\n\n- Wide&Deep [8]. Wide&Deep integrates the outputs of logistic regression and feed-forward neural networks.  \n- DeepFM [11]. DeepFM combines trainditional second-order factorization machines and feed-forward neural network, with a shared embedding layer.  \n- Deep&Cross [38]. Deep&Cross is the extension of CrossNet by integrating feed-forward neural networks.\n\n- xDeepFM [19]. xDeepFM is the extension of CIN by integrating feed-forward neural networks.\n\nTable 5 presents the averaged results (over 10 runs) of joint-training models. We have the following observations: 1) The performance of our method improves by joint training with feed-forward neural networks on all datasets. This indicates that integrating implicit feature interactions indeed boosts the predictive ability of our proposed model. However, as can be seen from last two columns, the magnitude of performance improvement is fairly small compared to other models, showing that our individual model AutoInt is quite powerful. 2) After integrating implicit feature interactions, AutoInt+ outperforms all competitive methods, and achieves new state-of-the-art performances on used CTR prediction data sets.",
  "hyperparameter": "embedding_dimension (d): 16; batch_size: 1024; number_of_interacting_layers: 3; hidden_units_per_layer (d'): 32; number_of_attention_heads (H): 2; dropout_rate: 0.1-0.9 (for MovieLens-1M, not necessary for large datasets); optimizer: Adam; threshold_for_infrequent_features: {10 (Criteo), 5 (Avazu), 10 (KDD12)}; numerical_feature_normalization: log²(z) if z > 2; train_test_split: 80% training, 10% validation, 10% test; number_of_hidden_layers_for_DeepCrossing_baseline: 4 with 100 units; number_of_hidden_layers_for_NFM_baseline: 1 with 200 units; number_of_hidden_layers_for_AutoInt+: 2 (feed-forward neural network)"
}