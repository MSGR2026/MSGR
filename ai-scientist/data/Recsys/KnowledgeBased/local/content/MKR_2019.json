{
  "id": "MKR_2019",
  "paper_title": "Multi-Task Feature Learning for Knowledge Graph Enhanced Recommendation",
  "alias": "MKR",
  "year": 2019,
  "domain": "Recsys",
  "task": "KnowledgeAwareRecommendation",
  "idea": "MKR proposes a multi-task learning framework that jointly trains recommendation and knowledge graph embedding (KGE) tasks through specially designed cross&compress units. The key innovation is the cross&compress unit that explicitly models high-order feature interactions between items and their corresponding entities by first constructing a cross feature matrix of all pairwise interactions, then compressing it back to latent spaces through learned projection weights. This allows adaptive knowledge transfer between the two tasks while maintaining task-specific parameters in high-level layers to avoid negative transfer.",
  "introduction": "# 1 INTRODUCTION\n\nRecommender systems (RS) aims to address the information explosion and meet users personalized interests. One of the most popular recommendation techniques is collaborative filtering (CF) [11],\n\nwhich utilizes users' historical interactions and makes recommendations based on their common preferences. However, CF-based methods usually suffer from the sparsity of user-item interactions and the cold start problem. Therefore, researchers propose using side information in recommender systems, including social networks [10], attributes [30], and multimedia (e.g., texts [29], images [40]). Knowledge graphs (KGs) are one type of side information for RS, which usually contain fruitful facts and connections about items. Recently, researchers have proposed several academic and commercial KGs, such as NELL \\(^{1}\\) , DBpedia \\(^{2}\\) , Google Knowledge Graph \\(^{3}\\)  and Microsoft Satori \\(^{4}\\) . Due to its high dimensionality and heterogeneity, a KG is usually pre-processed by knowledge graph embedding (KGE) methods [27], which embeds entities and relations into low-dimensional vector spaces while preserving its inherent structure.\n\n## Existing KG-aware methods\n\nInspired by the success of applying KG in a wide variety of tasks, researchers have recently tried to utilize KG to improve the performance of recommender systems [31, 32, 39, 40, 45]. Personalized Entity Recommendation (PER) [39] and Factorization Machine with Group lasso (FMG) [45] treat KG as a heterogeneous information network, and extract meta-path/meta-graph based latent features to represent the connectivity between users and items along different types of relation paths/graphs. It should be noted that PER and FMG rely heavily on manually designed meta-paths/meta-graphs, which limits its application in generic recommendation scenarios. Deep Knowledge-aware Network (DKN) [32] designs a CNN framework to combine entity embeddings with word embeddings for news recommendation. However, the entity embeddings are required in advance of using DKN, causing DKN to lack an end-to-end way of training. Another concern about DKN is that it can hardly incorporate side information other than texts. RippleNet [31] is a memory-network-like model that propagates users' potential preferences in the KG and explores their hierarchical interests. But the importance of relations is weakly characterized in RippleNet, because the embedding matrix of a relation  \\(\\mathbf{R}\\)  can hardly be trained to capture the sense of importance in the quadratic form  \\(\\mathbf{v}^{\\top}\\mathbf{R}\\mathbf{h}\\)  ( \\(\\mathbf{v}\\)  and  \\(\\mathbf{h}\\)  are embedding vectors of two entities). Collaborative Knowledge base Embedding (CKE) [40] combines CF with structural knowledge, textual knowledge, and visual knowledge in a unified framework. However, the KGE module in CKE (i.e., TransR [13]) is more suitable for in-graph applications (such as KG\n\ncompletion and link prediction) rather than recommendation. In addition, the CF module and the KGE module are loosely coupled in CKE under a Bayesian framework, making the supervision from KG less obvious for recommender systems.\n\n## The proposed approach\n\nTo address the limitations of previous work, we propose MKR, a multi-task learning (MTL) approach for knowledge graph enhanced recommendation. MKR is a generic, end-to-end deep recommendation framework, which aims to utilize KGE task to assist recommendation task<sup>5</sup>. Note that the two tasks are not mutually independent, but are highly correlated since an item in RS may associate with one or more entities in KG. Therefore, an item and its corresponding entity are likely to have a similar proximity structure in RS and KG, and share similar features in low-level and non-task-specific latent feature spaces [15]. We will further validate the similarity in the experiments section. To model the shared features between items and entities, we design a cross&compress unit in MKR. The cross&compress unit explicitly models high-order interactions between item and entity features, and automatically control the cross knowledge transfer for both tasks. Through cross&compress units, representations of items and entities can complement each other, assisting both tasks in avoiding fitting noises and improving generalization. The whole framework can be trained by alternately optimizing the two tasks with different frequencies, which endows MKR with high flexibility and adaptability in real recommendation scenarios.\n\nWe probe the expressive capability of MKR and show, through theoretical analysis, that the cross&compress unit is capable of approximating sufficiently high order feature interactions between items and entities. We also show that MKR is a generalized framework over several representative methods of recommender systems and multi-task learning, including factorization machines [22, 23], deep&cross network [34], and cross-stitch network [18]. Empirically, we evaluate our method in four recommendation scenarios, i.e., movie, book, music, and news recommendations. The results demonstrate that MKR achieves substantial gains over state-of-the-art baselines in both click-through rate (CTR) prediction (e.g.,  \\(11.6\\%\\)  AUC improvements on average for movies) and top- \\(K\\)  recommendation (e.g.,  \\(66.4\\%\\)  Recall@10 improvements on average for books). MKR is also shown to maintain satisfactory performance even when user-item interactions are sparse.\n\n## Contribution\n\nIt is worth noticing that the problem studied in this paper can also be modelled as cross-domain recommendation [26] or transfer learning [21], since we care more about the performance of recommendation task. However, the key observation is that though cross-domain recommendation and transfer learning have single objective for the target domain, their loss functions still contain constraint terms for measuring data distribution in the source domain or similarity between two domains. In our proposed MKR, the KGE task serves as the constraint term explicitly to provide regularization for recommender systems. We would like to emphasize that the major contribution of this paper is exactly modeling the problem as multi-task learning: We go a step further than cross-domain\n\nrecommendation and transfer learning by finding that the intertask similarity is helpful to not only recommender systems but also knowledge graph embedding, as shown in theoretical analysis and experiment results.\n",
  "method": "# 2 OUR APPROACH\n\nIn this section, we first formulate the knowledge graph enhanced recommendation problem, then introduce the framework of MKR and present the design of the cross&compress unit, recommendation module and KGE module in detail. We lastly discuss the learning algorithm for MKR.\n\n## 2.1 Problem Formulation\n\nWe formulate the knowledge graph enhanced recommendation problem in this paper as follows. In a typical recommendation scenario, we have a set of  \\(M\\)  users  \\(\\mathcal{U} = \\{u_1, u_2, \\dots, u_M\\}\\)  and a set of  \\(N\\)  items  \\(\\mathcal{V} = \\{v_1, v_2, \\dots, v_N\\}\\) . The user-item interaction matrix  \\(\\mathbf{Y} \\in \\mathbb{R}^{M \\times N}\\)  is defined according to users' implicit feedback, where  \\(y_{uv} = 1\\)  indicates that user  \\(u\\)  engaged with item  \\(v\\) , such as behaviors of clicking, watching, browsing, or purchasing; otherwise  \\(y_{uv} = 0\\) . Additionally, we also have access to a knowledge graph  \\(\\mathcal{G}\\) , which is comprised of entity-relation-entity triples  \\((h, r, t)\\) . Here  \\(h\\) ,  \\(r\\) , and  \\(t\\)  denote the head, relation, and tail of a knowledge triple, respectively. For example, the triple (Quentin Tarantino, filmdirector,film, Pulp Fiction) states the fact that Quentin Tarantino directs the film Pulp Fiction. In many recommendation scenarios, an item  \\(v \\in \\mathcal{V}\\)  may associate with one or more entities in  \\(\\mathcal{G}\\) . For example, in movie recommendation, the item \"Pulp Fiction\" is linked with its namesake in a knowledge graph, while in news recommendation, news with the title \"Trump pledges aid to Silicon Valley during tech meeting\" is linked with entities \"Donald Trump\" and \"Silicon Valley\" in a knowledge graph.\n\nGiven the user-item interaction matrix  \\(\\mathbf{Y}\\)  as well as the knowledge graph  \\(\\mathcal{G}\\) , we aim to predict whether user  \\(u\\)  has potential interest in item  \\(v\\)  with which he has had no interaction before. Our goal is to learn a prediction function  \\(\\hat{y}_{uv} = \\mathcal{F}(u,v|\\Theta, \\mathbf{Y}, \\mathcal{G})\\) , where  \\(\\hat{y}_{uv}\\)  denotes the probability that user  \\(u\\)  will engage with item  \\(v\\) , and  \\(\\Theta\\)  is the model parameters of function  \\(\\mathcal{F}\\) .\n\n## 2.2 Framework\n\nThe framework of MKR is illustrated in Figure 1a. MKR consists of three main components: recommendation module, KGE module, and cross&compress units. (1) The recommendation module on the left takes a user and an item as input, and uses a multi-layer perceptron (MLP) and cross&compress units to extract short and dense features for the user and the item, respectively. The extracted features are then fed into another MLP together to output the predicted probability. (2) Similar to the left part, the KGE module in the right part also uses multiple layers to extract features from the head and relation of a knowledge triple, and outputs the representation of the predicted tail under the supervision of a score function  \\(f\\)  and the real tail. (3) The recommendation module and the KGE module are bridged by specially designed cross&compress units. The proposed unit can automatically learn high-order feature interactions of items in recommender systems and entities in the knowledge graph.\n\n![](images/b1d5ebe3e6d512cbc316e2886446790283f4988626b5d1a224e22d700e4d1295.jpg)  \n(a) Framework of MKR\n\n![](images/5aa8fa1d69f0b50ca3474bc2a3886d8468949921032975e7f8f2d0f97d0640c6.jpg)  \n(b) Cross&compress unit  \nFigure 1: (a) The framework of MKR. The left and right part illustrate the recommendation module and the KGE module, respectively, which are bridged by the cross&compress units. (b) Illustration of a cross&compress unit. The cross&compress unit generates a cross feature matrix from item and entity vectors by cross operation, and outputs their vectors for the next layer by compress operation.\n\n### 2.3 Cross&compress Unit\n\nTo model feature interactions between items and entities, we design a cross&compress unit in MKR framework. As shown in Figure 1b, for item  \\(v\\)  and one of its associated entities  \\(e\\) , we first construct  \\(d \\times d\\)  pairwise interactions of their latent feature  \\(\\mathbf{v}_l \\in \\mathbb{R}^d\\)  and  \\(\\mathbf{e}_l \\in \\mathbb{R}^d\\)  from layer  \\(l\\) :\n\n\\[\n\\mathbf {C} _ {l} = \\mathbf {v} _ {l} \\mathbf {e} _ {l} ^ {\\top} = \\left[ \\begin{array}{c c c} v _ {l} ^ {(1)} e _ {l} ^ {(1)} & \\dots & v _ {l} ^ {(1)} e _ {l} ^ {(d)} \\\\ \\dots & & \\dots \\\\ v _ {l} ^ {(d)} e _ {l} ^ {(1)} & \\dots & v _ {l} ^ {(d)} e _ {l} ^ {(d)} \\end{array} \\right], \\tag {1}\n\\]\n\nwhere  \\(\\mathbf{C}_l \\in \\mathbb{R}^{d \\times d}\\)  is the cross feature matrix of layer  \\(l\\) , and  \\(d\\)  is the dimension of hidden layers. This is called the cross operation, since each possible feature interaction  \\(v_{l}^{(i)}e_{l}^{(j)}, \\forall (i,j) \\in \\{1,\\dots,d\\}^{2}\\)  between item  \\(v\\)  and its associated entity  \\(e\\)  is modeled explicitly in the cross feature matrix. We then output the feature vectors of items and entities for the next layer by projecting the cross feature matrix into their latent representation spaces:\n\n\\[\n\\begin{array}{l} \\mathbf {v} _ {l + 1} = \\mathbf {C} _ {l} \\mathbf {w} _ {l} ^ {V V} + \\mathbf {C} _ {l} ^ {\\top} \\mathbf {w} _ {l} ^ {E V} + \\mathbf {b} _ {l} ^ {V} = \\mathbf {v} _ {l} \\mathbf {e} _ {l} ^ {\\top} \\mathbf {w} _ {l} ^ {V V} + \\mathbf {e} _ {l} \\mathbf {v} _ {l} ^ {\\top} \\mathbf {w} _ {l} ^ {E V} + \\mathbf {b} _ {l} ^ {V}, \\\\ \\mathbf {e} _ {l + 1} = \\mathrm {C} _ {l} \\mathbf {w} _ {l} ^ {V E} + \\mathrm {C} _ {l} ^ {\\top} \\mathbf {w} _ {l} ^ {E E} + \\mathbf {b} _ {l} ^ {E} = \\mathbf {v} _ {l} \\mathbf {e} _ {l} ^ {\\top} \\mathbf {w} _ {l} ^ {V E} + \\mathbf {e} _ {l} \\mathbf {v} _ {l} ^ {\\top} \\mathbf {w} _ {l} ^ {E E} + \\mathbf {b} _ {l} ^ {E}, \\tag {2} \\\\ \\end{array}\n\\]\n\nwhere  \\(\\mathbf{w}_l^{\\cdot \\cdot} \\in \\mathbb{R}^d\\)  and  \\(\\mathbf{b}_l^{\\cdot} \\in \\mathbb{R}^d\\)  are trainable weight and bias vectors. This is called the compress operation, since the weight vectors project the cross feature matrix from  \\(\\mathbb{R}^{d \\times d}\\)  space back to the feature spaces  \\(\\mathbb{R}^d\\) . Note that in Eq. (2), the cross feature matrix is compressed along both horizontal and vertical directions (by operating on  \\(\\mathbf{C}_l\\)  and  \\(\\mathbf{C}_l^\\top\\) ) for the sake of symmetry, but we will provide more insights of the design in Section 3.2. For simplicity, the cross&compress unit is denoted as:\n\n\\[\n[ \\mathbf {v} _ {l + 1}, \\mathbf {e} _ {l + 1} ] = C (\\mathbf {v} _ {l}, \\mathbf {e} _ {l}), \\tag {3}\n\\]\n\nand we use a suffix [v] or [e] to distinguish its two outputs in the following of this paper. Through cross&compress units, MKR can\n\nadaptively adjust the weights of knowledge transfer and learn the relevance between the two tasks.\n\nIt should be noted that cross&compress units should only exist in low-level layers of MKR, as shown in Figure 1a. This is because: (1) In deep architectures, features usually transform from general to specific along the network, and feature transferability drops significantly in higher layers with increasing task dissimilarity [38]. Therefore, sharing high-level layers risks to possible negative transfer, especially for the heterogeneous tasks in MKR. (2) In high-level layers of MKR, item features are mixed with user features, and entity features are mixed with relation features. The mixed features are not suitable for sharing since they have no explicit association.\n\n### 2.4 Recommendation Module\n\nThe input of the recommendation module in MKR consists of two raw feature vectors  \\(\\mathbf{u}\\)  and  \\(\\mathbf{v}\\)  that describe user  \\(u\\)  and item  \\(v\\) , respectively.  \\(\\mathbf{u}\\)  and  \\(\\mathbf{v}\\)  can be customized as one-hot ID [8], attributes [30], bag-of-words [29], or their combinations, based on the application scenario. Given user  \\(u\\) 's raw feature vector  \\(\\mathbf{u}\\) , we use an  \\(L\\) -layer MLP to extract his latent condensed feature<sup>6</sup>:\n\n\\[\n\\mathbf {u} _ {L} = \\mathcal {M} (\\mathcal {M} (\\dots \\mathcal {M} (\\mathbf {u}))) = \\mathcal {M} ^ {L} (\\mathbf {u}), \\tag {4}\n\\]\n\nwhere  \\(\\mathcal{M}(\\mathbf{x}) = \\sigma (\\mathbf{W}\\mathbf{x} + \\mathbf{b})\\)  is a fully-connected neural network layer with weight  \\(\\mathbf{W}\\) , bias  \\(\\mathbf{b}\\) , and nonlinear activation function  \\(\\sigma (\\cdot)\\) . For item  \\(v\\) , we use  \\(L\\)  cross&compress units to extract its feature:\n\n\\[\n\\mathbf {v} _ {L} = \\mathbb {E} _ {e \\sim \\mathcal {S} (v)} \\left[ \\mathcal {C} ^ {L} (\\mathbf {v}, \\mathbf {e}) [ \\mathbf {v} ] \\right], \\tag {5}\n\\]\n\nwhere  \\(S(v)\\)  is the set of associated entities of item  \\(v\\) .\n\nAfter having user  \\(u\\) 's latent feature  \\(\\mathbf{u}_L\\)  and item  \\(v\\) 's latent feature  \\(\\mathbf{v}_L\\) , we combine the two pathways by a predicting function  \\(f_{RS}\\)\n\nfor example, inner product or an  \\(H\\) -layer MLP. The final predicted probability of user  \\(u\\)  engaging item  \\(v\\)  is:\n\n\\[\n\\dot {y} _ {u v} = \\sigma \\left(f _ {R S} \\left(\\mathbf {u} _ {L}, \\mathbf {v} _ {L}\\right)\\right). \\tag {6}\n\\]\n\n### 2.5 Knowledge Graph Embedding Module\n\nKnowledge graph embedding is to embed entities and relations into continuous vector spaces while preserving their structure. Recently, researchers have proposed a great many KGE methods, including translational distance models [2, 13] and semantic matching models [14, 19]. In MKR, we propose a deep semantic matching architecture for KGE module. Similar to the recommendation module, for a given knowledge triple  \\((h,r,t)\\) , we first utilize multiple cross&compress units and nonlinear layers to process the raw feature vectors of head  \\(h\\)  and relation  \\(r\\)  (including ID [13], types [36], textual description [35], etc.), respectively. Their latent features are then concatenated together, followed by a  \\(K\\) -layer MLP for predicting tail  \\(t\\) :\n\n\\[\n\\mathbf {h} _ {L} = \\mathbb {E} _ {\\boldsymbol {v} \\sim \\mathcal {S} (\\boldsymbol {h})} \\left[ C ^ {L} (\\mathbf {v}, \\mathbf {h}) [ \\mathbf {e} ] \\right],\n\\]\n\n\\[\n\\mathbf {r} _ {L} = \\mathcal {M} ^ {L} (\\mathbf {r}), \\tag {7}\n\\]\n\n\\[\n\\hat {\\mathbf {t}} = \\mathcal {M} ^ {K} \\left(\\left[ \\begin{array}{c} \\mathbf {h} _ {L} \\\\ \\mathbf {r} _ {L} \\end{array} \\right]\\right),\n\\]\n\nwhere  \\(S(h)\\)  is the set of associated items of entity  \\(h\\) , and  \\(\\hat{t}\\)  is the predicted vector of tail  \\(t\\) . Finally, the score of the triple  \\((h,r,t)\\)  is calculated using a score (similarity) function  \\(f_{KG}\\) :\n\n\\[\n\\operatorname {s c o r e} (h, r, t) = f _ {K G} (\\mathbf {t}, \\hat {\\mathbf {t}}), \\tag {8}\n\\]\n\nwhere  \\(\\mathbf{t}\\)  is the real feature vector of  \\(t\\) . In this paper, we use the normalized inner product  \\(f_{KG}(\\mathbf{t},\\hat{\\mathbf{t}}) = \\sigma (\\mathbf{t}^{\\top}\\hat{\\mathbf{t}})\\)  as the choice of score function [18], but other forms of (dis)similarity metrics can also be applied here such as Kullback \\(\\hat{\\mathbf{A}}\\) SLeibler divergence.\n\n### 2.6 Learning Algorithm\n\nThe complete loss function of MKR is as follows:\n\n\\[\n\\begin{array}{l} \\mathcal {L} = \\mathcal {L} _ {R S} + \\mathcal {L} _ {K G} + \\mathcal {L} _ {R E G} \\\\ = \\sum_ {u \\in \\mathcal {U}, v \\in \\mathcal {V}} \\mathcal {I} (\\hat {y} _ {u v}, y _ {u v}) \\\\ - \\lambda_ {1} \\left(\\sum_ {(h, r, t) \\in \\mathcal {G}} s c o r e (h, r, t) - \\sum_ {\\left(h ^ {\\prime}, r, t ^ {\\prime}\\right) \\notin \\mathcal {G}} s c o r e \\left(h ^ {\\prime}, r, t ^ {\\prime}\\right)\\right) \\tag {9} \\\\ + \\lambda_ {2} \\| \\mathbf {W} \\| _ {2} ^ {2}. \\\\ \\end{array}\n\\]\n\nIn Eq. (9), the first term measures loss in the recommendation module, where  \\(u\\)  and  \\(v\\)  traverse the set of users and the items, respectively, and  \\(\\mathcal{I}\\)  is the cross-entropy function. The second term calculates the loss in the KGE module, in which we aim to increase the score for all true triples while reducing the score for all false triples. The last item is the regularization term for preventing overfitting,  \\(\\lambda_{1}\\)  and  \\(\\lambda_{2}\\)  are the balancing parameters.\n\nNote that the loss function in Eq. (9) traverses all possible user-item pairs and knowledge triples. To make computation more efficient, following [17], we use a negative sampling strategy during training.\n\nThe learning algorithm of MKR is presented in Algorithm 1, in which a training epoch consists of two stages: recommendation\n\n#### Algorithm 1 Multi-Task Training for MKR\n\n#### Require: Interaction matrix Y, knowledge graph  \\(\\mathcal{G}\\)\n\nEnsure: Prediction function  \\(\\mathcal{F}(u,v|\\Theta ,\\Upsilon ,\\mathcal{G})\\)\n\n1: Initialize all parameters  \n2: for number of training iteration do // recommendation task\n\n3: for  \\(t\\)  steps do\n\n4: Sample minibatch of positive and negative interactions from Y;  \n5: Sample  \\(e \\sim S(v)\\)  for each item  \\(v\\)  in the minibatch;  \n6: Update parameters of  \\(\\mathcal{F}\\)  by gradient descent on Eq. (1)-(6), (9);  \n7: end for // knowledge graph embedding task  \n8: Sample minibatch of true and false triples from  \\(\\mathcal{G}\\)  \n9: Sample  \\(v \\sim S(h)\\)  for each head  \\(h\\)  in the minibatch;  \n10: Update parameters of  \\(\\mathcal{F}\\)  by gradient descent on Eq. (1)-(3), (7)-(9);  \n11: end for\n\ntask (line 3-7) and KGE task (line 8-10). In each iteration, we repeat training on recommendation task for  \\(t\\)  times ( \\(t\\)  is a hyper-parameter and normally  \\(t > 1\\) ) before training on KGE task once in each epoch, since we are more focused on improving recommendation performance. We will discuss the choice of  \\(t\\)  in the experiments section.\n",
  "experiments": "# 4 EXPERIMENTS\n\nIn this section, we evaluate the performance of MKR in four real-world recommendation scenarios: movie, book, music, and news<sup>9</sup>.\n\n## 4.1 Datasets\n\nWe utilize the following four datasets in our experiments:\n\n- MovieLens-1M \\(^{10}\\)  is a widely used benchmark dataset in movie recommendations, which consists of approximately 1 million explicit ratings (ranging from 1 to 5) on the MovieLens website.  \n- Book-Crossing \\(^{11}\\)  dataset contains 1,149,780 explicit ratings (ranging from 0 to 10) of books in the Book-Crossing community.  \n- Last.FM \\(^{12}\\)  dataset contains musician listening information from a set of 2 thousand users from Last.fm online music system.\n\nTable 1: Basic statistics and hyper-parameter settings for the four datasets.  \n\n<table><tr><td>Dataset</td><td># users</td><td># items</td><td># interactions</td><td># KG triples</td><td>Hyper-parameters</td></tr><tr><td>MovieLens-1M</td><td>6,036</td><td>2,347</td><td>753,772</td><td>20,195</td><td>L=1,d=8,t=3,λ1=0.5</td></tr><tr><td>Book-Crossing</td><td>17,860</td><td>14,910</td><td>139,746</td><td>19,793</td><td>L=1,d=8,t=2,λ1=0.1</td></tr><tr><td>Last.FM</td><td>1,872</td><td>3,846</td><td>42,346</td><td>15,518</td><td>L=2,d=4,t=2,λ1=0.1</td></tr><tr><td>Bing-News</td><td>141,487</td><td>535,145</td><td>1,025,192</td><td>1,545,217</td><td>L=3,d=16,t=5,λ1=0.2</td></tr></table>\n\n- Bing-News dataset contains 1,025,192 pieces of implicit feedback collected from the server logs of Bing News<sup>13</sup> from October 16, 2016 to August 11, 2017. Each piece of news has a title and a snippet.\n\nSince MovieLens-1M, Book-Crossing, and Last.FM are explicit feedback data (Last.FM provides the listening count as weight for each user-item interaction), we transform them into implicit feedback where each entry is marked with 1 indicating that the user has rated the item positively, and sample an unwatched set marked as 0 for each user. The threshold of positive rating is 4 for MovieLens-1M, while no threshold is set for Book-Crossing and Last.FM due to their sparsity.\n\nWe use Microsoft Satori to construct the KG for each dataset. We first select a subset of triples from the whole KG with a confidence level greater than 0.9. For MovieLens-1M and Book-Crossing, we additionally select a subset of triples from the sub-KG whose relation name contains \"film\" or \"book\" respectively to further reduce KG size.\n\nGiven the sub-KGs, for MovieLens-1M, Book-Crossing, and Last.FM, we collect IDs of all valid movies, books, or musicians by matching their names with tail of triples (head, film.film.name, tail), (head, book.book.title, tail), or (head, type.object.name, tail), respectively. For simplicity, items with no matched or multiple matched entities are excluded. We then match the IDs with the head and tail of all KG triples and select all well-matched triples from the sub-KG. The constructing process is similar for Bing-News except that: (1) we use entity linking tools to extract entities in news titles; (2) we do not impose restrictions on the names of relations since the entities in news titles are not within one particular domain. The basic statistics of the four datasets are presented in Table 1. Note that the number of users, items, and interactions are smaller than original datasets since we filtered out items with no corresponding entity in the KG.\n\n## 4.2Baselines\n\nWe compare our proposed MKR with the following baselines. Unless otherwise specified, the hyper-parameter settings of baselines are the same as reported in their original papers or as default in their codes.\n\n- PER [39] treats the KG as heterogeneous information networks and extracts meta-path based features to represent the connectivity between users and items. In this paper, we use manually designed user-item-attribute-item paths as features, i.e., \"user-movie-director-movie\", \"user-movie-genre-movie\", and \"user-movie-star-movie\" for MovieLens20M; \"user-book-author-book\" and \"user-book-genre-book\"\n\n![](images/b2a04b201e239c1e7855f9247041956faf9dded38471295fa1b00fcbf9e77bb0.jpg)  \n(a) RS to KG\n\n![](images/75ca64bf43cd58a5f890a7082a3acef5d9152e1607f2b7dd553babfec166d8e8.jpg)  \n(b) KG to RS  \nFigure 2: The correlation between the number of common neighbors of an item pair in KG and their number of common raters in RS.\n\nfor Book-Crossing; \"user-musician-genre-musician\", \"user-musician-country-musician\", and \"user-musician-age-musician\" (age is discretized) for Last.FM. Note that PER cannot be applied to news recommendation because it's hard to pre-define meta-paths for entities in news.\n\n- CKE [40] combines CF with structural, textual, and visual knowledge in a unified framework for recommendation. We implement CKE as CF plus structural knowledge module in this paper. The dimension of user and item embeddings for the four datasets are set as 64, 128, 32, 64, respectively. The dimension of entity embeddings is 32.  \n- DKN [32] treats entity embedding and word embedding as multiple channels and combines them together in CNN for CTR prediction. In this paper, we use movie/book names and news titles as textual input for DKN. The dimension of word embedding and entity embedding is 64, and the number of filters is 128 for each window size 1, 2, 3.  \n- RippleNet [31] is a memory-network-like approach that propagates users' preferences on the knowledge graph for recommendation. The hyper-parameter settings for Last.FM are  \\(d = 8\\) ,  \\(H = 2\\) ,  \\(\\lambda_1 = 10^{-6}\\) ,  \\(\\lambda_2 = 0.01\\) ,  \\(\\eta = 0.02\\) .  \n- LibFM [23] is a widely used feature-based factorization model. We concatenate the raw features of users and items as well as the corresponding averaged entity embeddings learned from TransR [13] as input for LibFM. The dimension is  \\(\\{1, 1, 8\\}\\)  and the number of training epochs is 50. The dimension of TransR is 32.  \n- Wide&Deep [3] is a deep recommendation model combining a (wide) linear channel with a (deep) nonlinear channel. The input for Wide&Deep is the same as in LibFM. The dimension of user, item, and entity is 64, and we use a two-layer deep channel with dimension of 100 and 50 as well as a wide channel.\n\nTable 2: The results of AUC and Accuracy in CTR prediction.  \n\n<table><tr><td rowspan=\"2\">Model</td><td colspan=\"2\">MovieLens-1M</td><td colspan=\"2\">Book-Crossing</td><td colspan=\"2\">Last.FM</td><td colspan=\"2\">Bing-News</td></tr><tr><td>AUC</td><td>ACC</td><td>AUC</td><td>ACC</td><td>AUC</td><td>ACC</td><td>AUC</td><td>ACC</td></tr><tr><td>PER</td><td>0.710 (-22.6%)</td><td>0.664 (-21.2%)</td><td>0.623 (-15.1%)</td><td>0.588 (-16.7%)</td><td>0.633 (-20.6%)</td><td>0.596 (-20.7%)</td><td>-</td><td>-</td></tr><tr><td>CKE</td><td>0.801 (-12.6%)</td><td>0.742 (-12.0%)</td><td>0.671 (-8.6%)</td><td>0.633 (-10.3%)</td><td>0.744 (-6.6%)</td><td>0.673 (-10.5%)</td><td>0.553 (-19.7%)</td><td>0.516 (-20.0%)</td></tr><tr><td>DKN</td><td>0.655 (-28.6%)</td><td>0.589 (-30.1%)</td><td>0.622 (-15.3%)</td><td>0.598 (-15.3%)</td><td>0.602 (-24.5%)</td><td>0.581 (-22.7%)</td><td>0.667 (-3.2%)</td><td>0.610 (-5.4%)</td></tr><tr><td>RippleNet</td><td>0.920 (+0.3%)</td><td>0.842 (-0.1%)</td><td>0.729 (-0.7%)</td><td>0.662 (-6.2%)</td><td>0.768 (-3.6%)</td><td>0.691 (-8.1%)</td><td>0.678 (-1.6%)</td><td>0.630 (-2.3%)</td></tr><tr><td>LibFM</td><td>0.892 (-2.7%)</td><td>0.812 (-3.7%)</td><td>0.685 (-6.7%)</td><td>0.640 (-9.3%)</td><td>0.777 (-2.5%)</td><td>0.709 (-5.7%)</td><td>0.640 (-7.1%)</td><td>0.591 (-8.4%)</td></tr><tr><td>Wide&amp;Deep</td><td>0.898 (-2.1%)</td><td>0.820 (-2.7%)</td><td>0.712 (-3.0%)</td><td>0.624 (-11.6%)</td><td>0.756 (-5.1%)</td><td>0.688 (-8.5%)</td><td>0.651 (-5.5%)</td><td>0.597 (-7.4%)</td></tr><tr><td>MKR</td><td>0.917</td><td>0.843</td><td>0.734</td><td>0.704</td><td>0.797</td><td>0.752</td><td>0.689</td><td>0.645</td></tr><tr><td>MKR-1L</td><td>-</td><td>-</td><td>-</td><td>-</td><td>0.795 (-0.3%)</td><td>0.749 (-0.4%)</td><td>0.680 (-1.3%)</td><td>0.631 (-2.2%)</td></tr><tr><td>MKR-DCN</td><td>0.883 (-3.7%)</td><td>0.802 (-4.9%)</td><td>0.705 (-4.3%)</td><td>0.676 (-4.2%)</td><td>0.778 (-2.4%)</td><td>0.730 (-2.9%)</td><td>0.671 (-2.6%)</td><td>0.614 (-4.8%)</td></tr><tr><td>MKR-stitch</td><td>0.905 (-1.3%)</td><td>0.830 (-1.5%)</td><td>0.721 (-2.2%)</td><td>0.682 (-3.4%)</td><td>0.772 (-3.1%)</td><td>0.725 (-3.6%)</td><td>0.674 (-2.2%)</td><td>0.621 (-3.7%)</td></tr></table>\n\n## 4.3 Experiments setup\n\nIn MKR, we set the number of high-level layers  \\(K = 1\\) ,  \\(f_{RS}\\)  as inner product, and  \\(\\lambda_2 = 10^{-6}\\)  for all three datasets, and other hyperparameter are given in Table 1. The settings of hyper-parameters are determined by optimizing AUC on a validation set. For each dataset, the ratio of training, validation, and test set is  \\(6:2:2\\) . Each experiment is repeated 3 times, and the average performance is reported. We evaluate our method in two experiment scenarios: (1) In click-through rate (CTR) prediction, we apply the trained model to each piece of interactions in the test set and output the predicted click probability. We use AUC and Accuracy to evaluate the performance of CTR prediction. (2) In top-K recommendation, we use the trained model to select  \\(K\\)  items with highest predicted click probability for each user in the test set, and choose Precision@K and Recall@K to evaluate the recommended sets.\n\n## 4.4 Empirical study\n\nWe conduct an empirical study to investigate the correlation of items in RS and their corresponding entities in KG. Specifically, we aim to reveal how the number of common neighbors of an item pair in KG changes with their number of common raters in RS. To this end, we first randomly sample 1 million item pairs from MovieLens-1M. We then classify each pair into 5 categories based on the number of their common raters in RS, and count their average number of common neighbors in KG for each category. The result is presented in Figure 2a, which clearly shows that if two items have more common raters in RS, they are likely to share more common neighbors in KG. Figure 2b shows the positive correlation from an opposite direction. The above findings empirically demonstrate that items share the similar structure of proximity in KG and RS, thus the cross knowledge transfer of items benefits both recommendation and KGE tasks in MKR.\n\n## 4.5 Results\n\n4.5.1 Comparison with baselines. The results of all methods in CTR prediction and top-  \\(K\\)  recommendation are presented in Table 2 and Figure 3, 4, respectively, from which we have the following observations:\n\n- PER performs poor on movie, book, and music recommendation because the user-defined meta-paths can hardly be\n\noptimal in reality. Moreover, PER cannot be applied to news recommendation since entities in news titles are not within one particular domain.\n\n- CKE performs better in movie, book, and music recommendation than news. This may be because MovieLens-1M, Book-Crossing, and Last.FM are much denser than Bing-News, which is more favorable for the collaborative filtering part in CKE.  \n- DKN performs best in news recommendation compared with other baselines, but performs worst in other scenarios. This is because movie, book, and musician names are too short and ambiguous to provide useful information.  \n- RippleNet performs best among all baselines, and even outperforms MKR on MovieLens-1M. This demonstrates that RippleNet can precisely capture user interests, especially in the case where user-item interactions are dense. However, RippleNet is more sensitive to the density of datasets, as it performs worse than MKR in Book-Crossing, Last.FM, and Bing-News. We will further study their performance in sparse scenarios in Section 4.5.3.  \n- In general, our MKR performs best among all methods on the four datasets. Specifically, MKR achieves average Accuracy gains of  \\(11.6\\%\\) ,  \\(11.5\\%\\) ,  \\(12.7\\%\\) , and  \\(8.7\\%\\)  in movie, book, music, and news recommendation, respectively, which demonstrates the efficacy of the multi-task learning framework in MKR. Note that the top- \\(K\\)  metrics are much lower for BingNews because the number of news is significantly larger than movies, books, and musicians.\n\n4.5.2 Comparison with MKR variants. We further compare MKR with its three variants to demonstrate the efficacy of cross&compress unit:\n\n- MKR-1L is MKR with one layer of cross&compress unit, which corresponds to FM model according to Proposition 1. Note that MKR-1L is actually MKR in the experiments for MovieLens-1M.  \n- MKR-DCN is a variant of MKR based on Eq. (13), which corresponds to DCN model.  \n- MKR-stitch is another variant of MKR corresponding to the cross-stitch network, in which the transfer weights in Eq. (15) are replaced by four trainable scalars.\n\n![](images/146e085356ef72307d5ffecc87219303c8f72a19e487af856a21a837b6774dc6.jpg)  \n(a) MovieLens-1M\n\n![](images/0fb383aff27d25a6371c5c00bd534d8157eb7478842148b0d3b790de17c8248c.jpg)  \n(b) Book-Crossing\n\n![](images/479b0f42a92b1c4103836bc0059ae7f5b9f63f5da12a650e6b1b795f749037e3.jpg)  \n(c) Last.FM  \nFigure 3: The results of Precision@K in top-K recommendation.\n\n![](images/a0f5a34878cd7aeb6c4185a3db8e0ccf7d230eac26e2a09ea3bfb50d4cb7a5eb.jpg)  \n(d) Bing-News\n\n(a) MovieLens-1M  \n![](images/f2813e76b78b331d70e7d5e84b946d7833e5f8c46e3effd15298f10cb03288bf.jpg)  \nPER\n\n(b) Book-Crossing  \nFigure 4: The results of Recall@K in top-K recommendation.  \n![](images/7699cc299c5c3403169b6f52e4404508858c07379d81cc13738b69d5d931a344.jpg)  \nCKE  \nDKN\n\n(c) Last.FM  \n![](images/06421cd9b5165e323710aae8bce00b64086d3d845fd098f70ab822256ca1bb3f.jpg)  \nRippleNet  \nLibFM  \nWide&Deep\n\n(d) Bing-News  \n![](images/e3dbb549b1acf825224f2c5fe142e90565b1ed2dcccf0e3355629a987531a80d.jpg)  \nMKR\n\nTable 3: Results of AUC on MovieLens-1M in CTR prediction with different ratios of training set  \\(r\\)  .  \n\n<table><tr><td rowspan=\"2\">Model</td><td colspan=\"10\">r</td></tr><tr><td>10%</td><td>20%</td><td>30%</td><td>40%</td><td>50%</td><td>60%</td><td>70%</td><td>80%</td><td>90%</td><td>100%</td></tr><tr><td>PER</td><td>0.598</td><td>0.607</td><td>0.621</td><td>0.638</td><td>0.647</td><td>0.662</td><td>0.675</td><td>0.688</td><td>0.697</td><td>0.710</td></tr><tr><td>CKE</td><td>0.674</td><td>0.692</td><td>0.705</td><td>0.716</td><td>0.739</td><td>0.754</td><td>0.768</td><td>0.775</td><td>0.797</td><td>0.801</td></tr><tr><td>DKN</td><td>0.579</td><td>0.582</td><td>0.589</td><td>0.601</td><td>0.612</td><td>0.620</td><td>0.631</td><td>0.638</td><td>0.646</td><td>0.655</td></tr><tr><td>RippleNet</td><td>0.843</td><td>0.851</td><td>0.859</td><td>0.862</td><td>0.870</td><td>0.878</td><td>0.890</td><td>0.901</td><td>0.912</td><td>0.920</td></tr><tr><td>LibFM</td><td>0.801</td><td>0.810</td><td>0.816</td><td>0.829</td><td>0.837</td><td>0.850</td><td>0.864</td><td>0.875</td><td>0.886</td><td>0.892</td></tr><tr><td>Wide&amp;Deep</td><td>0.788</td><td>0.802</td><td>0.809</td><td>0.815</td><td>0.821</td><td>0.840</td><td>0.858</td><td>0.876</td><td>0.884</td><td>0.898</td></tr><tr><td>MKR</td><td>0.868</td><td>0.874</td><td>0.881</td><td>0.882</td><td>0.889</td><td>0.897</td><td>0.903</td><td>0.908</td><td>0.913</td><td>0.917</td></tr></table>\n\nFrom Table 2 we observe that MKR outperforms MKR-1L and MKR-DCN, which shows that modeling high-order interactions between item and entity features is helpful for maintaining decent performance. MKR also achieves better scores than MKR-stitch. This validates the efficacy of fine-grained control on knowledge transfer in MKR compared with the simple cross-stitch units.\n\n4.5.3 Results in sparse scenarios. One major goal of using knowledge graph in MKR is to alleviate the sparsity and the cold start\n\nproblem of recommender systems. To investigate the efficacy of the KGE module in sparse scenarios, we vary the ratio of training set of MovieLens-1M from  \\(100\\%\\)  to  \\(10\\%\\)  (while the validation and test set are kept fixed), and report the results of AUC in CTR prediction for all methods. The results are shown in Table 3. We observe that the performance of all methods deteriorates with the reduce of the training set. When  \\(r = 10\\%\\) , the AUC score decreases by  \\(15.8\\%\\) ,  \\(15.9\\%\\) ,  \\(11.6\\%\\) ,  \\(8.4\\%\\) ,  \\(10.2\\%\\) ,  \\(12.2\\%\\)  for PER, CKE, DKN, RippleNet, LibFM, and Wide&Deep, respectively, compared with\n\n![](images/789f109668b5ca2e6f3e79cb9b873cb90a99bb7f0b14c552a9aea5a931f02471.jpg)  \n(a) KG size\n\n![](images/1815705bd0bac47881b09c49c8d075058d9a50d1c9af577e8a7a5e5a846350c2.jpg)  \n(b) Training frequency\n\n![](images/78de212fb50c90c528bd1c853bfb9d6e0b24c5fd83b9fc8fcee7834e6f097d9d.jpg)  \n(c) Dimension of embeddings  \nFigure 5: Parameter sensitivity of MKR on Bing-News w.r.t. (a) the size of the knowledge graph; (b) training frequency of the RS module  \\(t\\) ; and (c) dimension of embeddings  \\(d\\) .\n\nTable 4: The results of RMSE on the KGE module for the three datasets. \"KGE\" means only KGE module is trained, while \"KGE + RS\" means KGE module and RS module are trained together.  \n\n<table><tr><td>dataset</td><td>KGE</td><td>KGE + RS</td></tr><tr><td>MovieLens-1M</td><td>0.319</td><td>0.302</td></tr><tr><td>Book-Crossing</td><td>0.596</td><td>0.558</td></tr><tr><td>Last.FM</td><td>0.480</td><td>0.471</td></tr><tr><td>Bing-News</td><td>0.488</td><td>0.459</td></tr></table>\n\nthe case when full training set is used ( \\(r = 100\\%\\) ). In contrast, the AUC score of MKR only decreases by  \\(5.3\\%\\) , which demonstrates that MKR can still maintain a decent performance even when the user-item interaction is sparse. We also notice that MKR performs better than RippleNet in sparse scenarios, which is accordance with our observation in Section 4.5.1 that RippleNet is more sensitive to the density of user-item interactions.\n\n4.5.4 Results on KGE side. Although the goal of MKR is to utilize KG to assist with recommendation, it is still interesting to investigate whether the RS task benefits the KGE task, since the principle of multi-task learning is to leverage shared information to help improve the performance of all tasks [42]. We present the result of RMSE (rooted mean square error) between predicted and real vectors of tails in the KGE task in Table 4. Fortunately, we find that the existence of RS module can indeed reduce the prediction error by  \\(1.9\\% \\sim 6.4\\%\\) . The results show that the cross&compress units are able to learn general and shared features that mutually benefit both sides of MKR.\n\n## 4.6 Parameter Sensitivity\n\n4.6.1 Impact of KG size. We vary the size of KG to further investigate the efficacy of usage of KG. The results of AUC on Bing-News are plotted in Figure 5a. Specifically, the AUC and Accuracy is enhanced by  \\(13.6\\%\\)  and  \\(11.8\\%\\)  with the KG ratio increasing from 0.1 to 1.0 in three scenarios, respectively. This is because the Bing-News dataset is extremely sparse, making the effect of KG usage rather obvious.\n\n4.6.2 Impact of RS training frequency. We investigate the influence of parameters  \\(t\\)  in MKR by varying  \\(t\\)  from 1 to 10, while keeping\n\nother parameters fixed. The results are presented in Figure 5b. We observe that MKR achieves the best performance when  \\(t = 5\\) . This is because a high training frequency of the KGE module will mislead the objective function of MKR, while too small of a training frequency of KGE cannot make full use of the transferred knowledge from the KG.\n\n4.6.3 Impact of embedding dimension. We also show how the dimension of users, items, and entities affects the performance of MKR in Figure 5c. We find that the performance is initially improved with the increase of dimension, because more bits in embedding layer can encode more useful information. However, the performance drops when the dimension further increases, as too large number of dimensions may introduce noises which mislead the subsequent prediction.\n",
  "hyperparameter": "Number of low-level layers L: 1-3 (MovieLens: 1, Book-Crossing: 1, Last.FM: 2, Bing-News: 3); Embedding dimension d: 4-16 (MovieLens: 8, Book-Crossing: 8, Last.FM: 4, Bing-News: 16); RS training frequency t: 2-5 (MovieLens: 3, Book-Crossing: 2, Last.FM: 2, Bing-News: 5); Balancing parameter λ1: 0.1-0.5 (MovieLens: 0.5, Book-Crossing: 0.1, Last.FM: 0.1, Bing-News: 0.2); Regularization parameter λ2: 10^-6 for all datasets; Number of high-level layers K: 1 for all datasets; Prediction function fRS: inner product; Train/validation/test split ratio: 6:2:2"
}