{
  "id": "KGCN_2019",
  "paper_title": "Knowledge Graph Convolutional Networks for Recommender Systems",
  "alias": "KGCN",
  "year": 2019,
  "domain": "Recsys",
  "task": "KnowledgeAwareRecommendation",
  "idea": "KGCN (Knowledge Graph Convolutional Networks) leverages knowledge graph structure for recommendation by aggregating neighborhood information of items in the KG. The core innovation is using personalized user-relation scores as attention weights when aggregating entity neighbors, allowing the model to capture user-specific preferences over different relation types. The method employs multi-hop neighborhood aggregation with fixed-size neighbor sampling to capture high-order structural proximity, where H-order representations mix information from entities up to H hops away in the knowledge graph.",
  "introduction": "# 1 INTRODUCTION\n\nWith the advance of Internet technology, people can access a vast amount of online content, such as news [25], movies [5], and commodities [26]. A notorious problem with online platforms is that the volume of items can be overwhelming to users. To alleviate the impact of information overloading, recommender systems (RS) is proposed to search for and recommend a small set of items to meet users' personalized interests.\n\nA traditional recommendation technique is collaborative filtering (CF), which assigns users and items ID-based representation vectors, then models their interactions by specific operation such as inner product [16] or neural networks [8]. However, CF-based methods usually suffer from sparsity of user-item interactions and the cold start problem. To address these limitations, researchers usually turn to feature-rich scenarios, where attributes of users and items are used to compensate for the sparsity and improve the performance of recommendation [3, 17].\n\nA few recent studies [9, 18, 19, 22-24] have gone a step further than simply using attributes: They point out that attributes are not isolated but linked up with each other, which forms a knowledge graph (KG). Typically, a KG is a directed heterogeneous graph in which nodes correspond to entities (items or item attributes) and edges correspond to relations. Compared with KG-free methods, incorporating KG into recommendation benefits the results in three ways [18]: (1) The rich semantic relatedness among items in a KG can help explore their latent connections and improve the precision of results; (2) The various types of relations in a KG are helpful for extending a user's interests reasonably and increasing the diversity of recommended items; (3) KG connects a user's historically-liked and recommended items, thereby bringing explainability to recommender systems.\n\nDespite the above benefits, utilizing KG in RS is rather challenging due to its high dimensionality and heterogeneity. One feasible way is to preprocess the KG by knowledge graph embedding (KGE) methods [20], which map entities and relations to low-dimensional representation vectors [9, 19, 23]. However, commonly-used KGE methods focus on modeling rigorous semantic relatedness (e.g., TransE [1] and TransR [12] assume head + relation = tail), which are more suitable for in-graph applications such as KG completion and link prediction rather than recommendation. A more natural and intuitive way is to design a graph algorithm directly to\n\nexploit the KG structure [18, 22, 24]. For example, PER [22] and FMG [24] treat KG as a heterogeneous information network, and extract meta-path/meta-graph based latent features to represent the connectivity between users and items along different types of relation paths/graphs. However, PER and FMG rely heavily on manually designed meta-paths or meta-graphs, which are hardly to be optimal in reality. RippleNet [18] is a memory-network-like model that propagates users' potential preferences in the KG and explores their hierarchical interests. But note that the importance of relations is weakly characterized in RippleNet, because the embedding matrix of a relation  \\(\\mathbf{R}\\)  can hardly be trained to capture the sense of importance in the quadratic form  \\(\\mathbf{v}^{\\top}\\mathbf{R}\\mathbf{h}\\)  ( \\(\\mathbf{v}\\)  and  \\(\\mathbf{h}\\)  are embedding vectors of two entities). In addition, the size of ripple set may go unpredictably with the increase of the size of KG, which incurs heavy computation and storage overhead.\n\nIn this paper, we investigate the problem of KG-aware recommendation. Our design objective is to automatically capture both high-order structure and semantic information in the KG. Inspired by graph convolutional networks (GCN)<sup>1</sup> that try to generalize convolution to the graph domain, we propose Knowledge Graph Convolutional Networks (KGCN) for recommender systems. The key idea of KGCN is to aggregate and incorporate neighborhood information with bias when calculating the representation of a given entity in the KG. Such a design has two advantages: (1) Through the operation of neighborhood aggregation, the local proximity structure is successfully captured and stored in each entity. (2) Neighbors are weighted by scores dependent on the connecting relation and specific user, which characterizes both the semantic information of KG and users' personalized interests in relations. Note that the size of an entity's neighbors varies and may be prohibitively large in the worst case. Therefore, we sample a fixed-size neighborhood of each node as the receptive field, which makes the cost of KGCN predictable. The definition of neighborhood for a given entity can also be extended hierarchically to multiple hops away to model high-order entity dependencies and capture users' potential long-distance interests.\n\nEmpirically, we apply KGCN to three datasets: MovieLens-20M (movie), Book-Crossing (book), and Last.FM (music). The experiment results show that KGCN achieves average AUC gains of  \\(4.4\\%\\) ,  \\(8.1\\%\\) , and  \\(6.2\\%\\)  in movie, book, and music recommendations, respectively, compared with state-of-the-art baselines for recommendation.\n\nOur contribution in this paper are summarized as follows:\n\n- We propose knowledge graph convolutional networks, an end-to-end framework that explores users' preferences on the knowledge graph for recommender systems. By extending the receptive field of each entity in the KG, KGCN is able to capture users' high-order personalized interests.  \n- We conduct experiments on three real-world recommendation scenarios. The results demonstrate the efficacy of KGCN-LS over state-of-the-art baselines.  \n- We release the code of KGCN and datasets (knowledge graphs) to researchers for validating the reported results and conducting further research. The code and the data are available at https://github.com/hwwang55/KGCN.\n",
  "method": "# 3 KNOWLEDGE GRAPH CONVOLUTIONAL NETWORKS\n\nIn this section, we introduce the proposed KGCN model. We first formulate the knowledge-graph-aware recommendation problem. Then we present the design of a single layer of KGCN. At last, we introduce the complete learning algorithm for KGCN, as well as its minibatach implementation.\n\n## 3.1 Problem Formulation\n\nWe formulate the knowledge-graph-aware recommendation problem as follows. In a typical recommendation scenario, we have a set of  \\(M\\)  users  \\(\\mathcal{U} = \\{u_1, u_2, \\dots, u_M\\}\\)  and a set of  \\(N\\)  items  \\(\\mathcal{V} = \\{v_1, v_2, \\dots, v_N\\}\\) . The user-item interaction matrix  \\(\\mathbf{Y} \\in \\mathbb{R}^{M \\times N}\\)  is defined according to users' implicit feedback, where  \\(y_{uv} = 1\\)  indicates that user  \\(u\\)  engages with item  \\(v\\) , such as clicking, browsing, or purchasing; otherwise  \\(y_{uv} = 0\\) . Additionally, we also have a knowledge graph  \\(\\mathcal{G}\\) , which is comprised of entity-relation-entity triples  \\((h, r, t)\\) . Here  \\(h \\in \\mathcal{E}\\) ,  \\(r \\in \\mathcal{R}\\) , and  \\(t \\in \\mathcal{E}\\)  denote the head, relation, and tail of a knowledge triple,  \\(\\mathcal{E}\\)  and  \\(\\mathcal{R}\\)  are the set of entities and relations in the knowledge graph, respectively. For example, the triple (A Song of Ice and Fire, book.book.author, George Martin) states the fact that George Martin writes the book \"A Song of Ice and Fire\". In many recommendation scenarios, an item  \\(v \\in \\mathcal{V}\\)  corresponds to one entity  \\(e \\in \\mathcal{E}\\) . For example, in book recommendation, the item \"A Song of Ice and Fire\" also appears in the knowledge graph as an entity with the same name.\n\nGiven the user-item interaction matrix  \\(\\mathbf{Y}\\)  as well as the knowledge graph  \\(\\mathcal{G}\\) , we aim to predict whether user  \\(u\\)  has potential interest in item  \\(v\\)  with which he has had no interaction before. Our goal is to learn a prediction function  \\(\\hat{y}_{uv} = \\mathcal{F}(u,v|\\Theta, \\mathbf{Y}, \\mathcal{G})\\) , where  \\(\\hat{y}_{uv}\\)  denotes the probability that user  \\(u\\)  will engage with item  \\(v\\) , and  \\(\\Theta\\)  denotes the model parameters of function  \\(\\mathcal{F}\\) .\n\n### 3.2 KGCN Layer\n\nKGCN is proposed to capture high-order structural proximity among entities in a knowledge graph. We start by describing a single KGCN layer in this subsection. Consider a candidate pair of user  \\(u\\)  and item (entity)  \\(v\\) . We use  \\(\\mathcal{N}(v)\\)  to denote the set of entities directly connected to  \\(v\\) , and  \\(r_{e_i, e_j}\\)  to denote the relation between entity  \\(e_i\\)  and  \\(e_j\\) . We also use a function  \\(g: \\mathbb{R}^d \\times \\mathbb{R}^d \\to \\mathbb{R}\\)  (e.g., inner product) to compute the score between a user and a relation:\n\n\\[\n\\pi_ {r} ^ {u} = g (\\mathbf {u}, \\mathbf {r}), \\tag {1}\n\\]\n\nwhere  \\(\\mathbf{u} \\in \\mathbb{R}^d\\)  and  \\(\\mathbf{r} \\in \\mathbb{R}^d\\)  are the representations of user  \\(u\\)  and relation  \\(r\\) , respectively,  \\(d\\)  is the dimension of representations. In general,  \\(\\pi_r^u\\)  characterizes the importance of relation  \\(r\\)  to user  \\(u\\) . For example, a user may have more potential interests in the movies that share the same \"star\" with his historically liked ones, while another user may be more concerned about the \"genre\" of movies.\n\nTo characterize the topological proximity structure of item  \\(v\\) , we compute the linear combination of  \\(v\\) 's neighborhood:\n\n\\[\n\\mathbf {v} _ {\\mathcal {N} (v)} ^ {u} = \\sum_ {e \\in \\mathcal {N} (v)} \\tilde {\\pi} _ {r _ {v, e}} ^ {u} \\mathbf {e}, \\tag {2}\n\\]\n\nwhere  \\(\\tilde{\\pi}_{r_{v,e}}^{u}\\)  is the normalized user-relation score\n\n\\[\n\\tilde {\\pi} _ {r _ {v, e}} ^ {u} = \\frac {\\exp \\left(\\pi_ {r _ {v , e}} ^ {u}\\right)}{\\sum_ {e \\in \\mathcal {N} (v)} \\exp \\left(\\pi_ {r _ {v , e}} ^ {u}\\right)}, \\tag {3}\n\\]\n\nand e is the representation of entity  \\(e\\) . User-relation scores act as personalized filters when computing an entity's neighborhood representation, since we aggregate the neighbors with bias with respect to these user-specific scores.\n\nIn a real-world knowledge graph, the size of  \\(\\mathcal{N}(e)\\)  may vary significantly over all entities. To keep the computational pattern of each batch fixed and more efficient, we uniformly sample a fixed-size set of neighbors for each entity instead of using its full neighbors. Specifically, we compute the neighborhood representation of entity  \\(v\\)  as  \\(\\mathbf{v}_{\\mathcal{S}(v)}^u\\) , where  \\(\\mathcal{S}(v) \\triangleq \\{e \\mid e \\sim \\mathcal{N}(v)\\}\\)  and  \\(|\\mathcal{S}(v)| = K\\)  is a configurable constant. In KGCN,  \\(\\mathcal{S}(v)\\)  is also called the (single-layer) receptive field of entity  \\(v\\) , as the final representation of  \\(v\\)  is sensitive to these locations. Figure 1a gives an illustrative example of a two-layer receptive field for a given entity, where  \\(K\\)  is set as 2.\n\nThe final step in a KGCN layer is to aggregate the entity representation  \\(\\mathbf{v}\\)  and its neighborhood representation  \\(\\mathbf{v}_{\\mathcal{S}(v)}^u\\)  into a single vector. We implement three types of aggregators  \\(agg: \\mathbb{R}^d \\times \\mathbb{R}^d \\to \\mathbb{R}^d\\)  in KGCN:\n\n- Sum aggregator takes the summation of two representation vectors, followed by a nonlinear transformation:\n\n\\[\na g g _ {s u m} = \\sigma \\left(\\mathbf {W} \\cdot \\left(\\mathbf {v} + \\mathbf {v} _ {S (v)} ^ {u}\\right) + \\mathbf {b}\\right), \\tag {4}\n\\]\n\nwhere  \\(\\mathbf{W}\\)  and  \\(\\mathbf{b}\\)  are transformation weight and bias, respectively, and  \\(\\sigma\\)  is the nonlinear function such  \\(ReLU\\) .\n\n- Concat aggregator [7] concatenates the two representation vectors first before applying nonlinear transformation:\n\n\\[\na g g _ {c o n c a t} = \\sigma \\left(\\mathbf {W} \\cdot c o n c a t \\left(\\mathbf {v}, \\mathbf {v} _ {S (v)} ^ {u}\\right) + \\mathbf {b}\\right). \\tag {5}\n\\]\n\n![](images/63114f7bded20aff1be7e279b0356e9dda318ce18c38002d55e1ccc9ddd19b6c.jpg)  \n(a)\n\n![](images/72d9665a3f0262b0695118a07499d8c5acdba911b37a591d2ee2304cca92cedb.jpg)  \n(b)  \nFigure 1: (a) A two-layer receptive field (green entities) of the blue entity in a KG. (b) The framework of KGCN.\n\n- Neighbor aggregator [15] directly takes the neighborhood representation of entity  \\(v\\)  as the output representation:\n\n\\[\na g g _ {n e i g h b o r} = \\sigma \\left(\\mathbf {W} \\cdot \\mathbf {v} _ {S (v)} ^ {u} + \\mathbf {b}\\right). \\tag {6}\n\\]\n\nAggregation is a key step in KGCN, because the representation of an item is bound up with its neighbors by aggregation. We will evaluate the three aggregators in experiments.\n\n### 3.3 Learning Algorithm\n\nThrough a single KGCN layer, the final representation of an entity is dependent on itself as well as its immediate neighbors, which we name 1-order entity representation. It is natural to extend KGCN from one layer to multiple layers to reasonably explore users' potential interests in a broader and deeper way. The technique is intuitive: Propagating the initial representation of each entity (0-order representation) to its neighbors leads to 1-order entity representation, then we can repeat this procedure, i.e., further propagating and aggregating 1-order representations to obtain 2-order ones. Generally speaking, the  \\(h\\) -order representation of an entity is a mixture of initial representations of itself and its neighbors up to  \\(h\\)  hops away. This is an important property for KGCN, which we will discuss in the next subsection.\n\nThe formal description of the above steps is presented in Algorithm 1.  \\(H\\)  denotes the maximum depth of receptive field (or equivalently, the number of aggregation iterations), and a suffix  \\([h]\\)  attached by a representation vector denotes  \\(h\\) -order. For a given user-item pair  \\((u,v)\\)  (line 2), we first calculate the receptive field  \\(\\mathcal{M}\\)  of  \\(v\\)  in an iterative layer-by-layer manner (line 3, 13-19). Then the aggregation is repeated  \\(H\\)  times (line 5): In iteration  \\(h\\) , we calculate the neighborhood representation of each entity  \\(e \\in \\mathcal{M}[h]\\)  (line 7), then aggregate it with its own representation  \\(\\mathbf{e}^u[h - 1]\\)  to obtain the one to be used at the next iteration (line 8). The final  \\(H\\) -order entity representation is denoted as  \\(\\mathbf{v}^u\\)  (line 9), which is fed into a function  \\(f: \\mathbb{R}^d \\times \\mathbb{R}^d \\to \\mathbb{R}\\)  together with user representation  \\(\\mathbf{u}\\)  for predicting the probability:\n\n\\[\n\\dot {y} _ {u v} = f (\\mathbf {u}, \\mathbf {v} ^ {u}). \\tag {7}\n\\]\n\nFigure 1b illustrates the KGCN algorithm in one iteration, in which the entity representation  \\(\\mathbf{v}^u[h]\\)  and neighborhood representations (green nodes) of a given node are mixed to form its representation for the next iteration (blue node).\n\nAlgorithm 1: KGCN algorithm  \nInput: Interaction matrix Y; knowledge graph  \\(\\mathcal{G}(\\mathcal{E},\\mathcal{R})\\)    \nneighborhood sampling mapping  \\(S:e\\to 2^{\\mathcal{E}}\\)  ; trainable parameters:  \\(\\{\\mathbf{u}\\}_{u\\in \\mathcal{U}},\\{\\mathbf{e}\\}_{e\\in \\mathcal{E}},\\{\\mathbf{r}\\}_{r\\in \\mathcal{R}},\\{\\mathbf{W}_i,\\mathbf{b}_i\\}_{i = 1}^H;\\)  hyper-parameters:  \\(H,d,g(\\cdot),f(\\cdot),\\sigma (\\cdot),agg(\\cdot)\\)    \nOutput: Prediction function  \\(\\mathcal{F}(u,v|\\Theta ,Y,\\mathcal{G})\\)    \nwhile KGCN not converge do   \nfor  \\((u,v)\\)  in Y do   \n \\(\\{\\mathcal{M}[i]\\}_{i = 0}^{H}\\gets\\)  Get-Receptive-Field  \\((v)\\)  .   \n \\(\\mathbf{e}^u [0]\\gets \\mathbf{e},\\forall e\\in \\mathcal{M}[0];\\)    \nfor  \\(h = 1,\\dots,H\\)  do   \nfor  \\(e\\in \\mathcal{M}[h]\\)  do   \n \\(\\begin{array}{rl} & {\\mathrm{e}_S(e)[h - 1]\\leftarrow \\sum_{e'\\in S(e)}\\tilde{\\pi}_{re,e'}^u\\mathrm{e}'^u [h - 1];}\\\\ & {\\mathrm{e}^u [h]\\leftarrow agg\\left(\\mathrm{e}_S(e)[h - 1],\\mathrm{e}^u [h - 1]\\right);} \\end{array}\\) \\(\\mathbf{v}^u\\gets \\mathbf{e}^u [H]\\)  . Calculate predicted probability  \\(\\hat{y}_{uv} = f(\\mathbf{u},\\mathbf{v}^u)\\)    \nUpdate parameters by gradient descent;   \nreturn F;   \nFunction Get-Receptive-Field (v)   \n \\(\\begin{array}{rl} & {\\mathcal{M}[H]\\gets v;}\\\\ & {\\textbf{for} h = H - 1,\\dots,0\\textbf{do}}\\\\ & {\\mathcal{M}[h]\\leftarrow \\mathcal{M}[h + 1];}\\\\ & {\\textbf{for} e\\in \\mathcal{M}[h + 1]\\textbf{do}}\\\\ & {\\mathcal{M}[h]\\leftarrow \\mathcal{M}[h]\\cup \\mathcal{S}(e);} \\end{array}\\)    \nreturn  \\(\\{\\mathcal{M}[i]\\}_{i = 0}^{H};\\)\n\nNote that Algorithm 1 traverses all possible user-item pairs (line 2). To make computation more efficient, we use a negative sampling strategy during training. The complete loss function is as follows:\n\n\\[\n\\mathcal {L} = \\sum_ {u \\in \\mathcal {U}} \\left(\\sum_ {v: y _ {u v} = 1} \\mathcal {J} \\left(y _ {u v}, \\hat {y} _ {u v}\\right) - \\sum_ {i = 1} ^ {T ^ {u}} \\mathbb {E} _ {v _ {i} \\sim P \\left(v _ {i}\\right)} \\mathcal {J} \\left(y _ {u v _ {i}}, \\hat {y} _ {u v _ {i}}\\right)\\right) + \\lambda \\| \\mathcal {F} \\| _ {2} ^ {2}, \\tag {8}\n\\]\n\nwhere  \\(\\mathcal{I}\\)  is cross-entropy loss,  \\(P\\)  is a negative sampling distribution, and  \\(T^u\\)  is the number of negative samples for user  \\(u\\) . In this paper,  \\(T^u = |\\{v : y_{uv} = 1\\}|\\)  and  \\(P\\)  follows a uniform distribution. The last term is the L2-regularizer.\n",
  "experiments": "# 4 EXPERIMENTS\n\nIn this section, we evaluate KGCN on three real-world scenarios: movie, book, and music recommendations.\n\n## 4.1 Datasets\n\nWe utilize the following three datasets in our experiments for movie, book, and music recommendation, respectively:\n\n- MovieLens-20M \\(^4\\)  is a widely used benchmark dataset in movie recommendations, which consists of approximately 20 million explicit ratings (ranging from 1 to 5) on the MovieLens website.\n\nTable 1: Basic statistics and hyper-parameter settings for the three datasets ( \\(K\\) : neighbor sampling size,  \\(d\\) : dimension of embeddings,  \\(H\\) : depth of receptive field,  \\(\\lambda\\) : L2 regularizer weight,  \\(\\eta\\) : learning rate).\n\n<table><tr><td></td><td>MovieLens-20M</td><td>Book-Crossing</td><td>Last.FM</td></tr><tr><td># users</td><td>138,159</td><td>19,676</td><td>1,872</td></tr><tr><td># items</td><td>16,954</td><td>20,003</td><td>3,846</td></tr><tr><td># interactions</td><td>13,501,622</td><td>172,576</td><td>42,346</td></tr><tr><td># entities</td><td>102,569</td><td>25,787</td><td>9,366</td></tr><tr><td># relations</td><td>32</td><td>18</td><td>60</td></tr><tr><td># KG triples</td><td>499,474</td><td>60,787</td><td>15,518</td></tr><tr><td>K</td><td>4</td><td>8</td><td>8</td></tr><tr><td>d</td><td>32</td><td>64</td><td>16</td></tr><tr><td>H</td><td>2</td><td>1</td><td>1</td></tr><tr><td>λ</td><td>10-7</td><td>2 × 10-5</td><td>10-4</td></tr><tr><td>η</td><td>2 × 10-2</td><td>2 × 10-4</td><td>5 × 10-4</td></tr><tr><td>batch size</td><td>65,536</td><td>256</td><td>128</td></tr></table>\n\n- Book-Crossing<sup>5</sup> contains 1 million ratings (ranging from 0 to 10) of books in the Book-Crossing community.  \n- Last.FM<sup>6</sup> contains musician listening information from a set of 2 thousand users from Last.fm online music system.\n\nSince the three datasets are explicit feedbacks, we transform them into implicit feedback where each entry is marked with 1 indicating that the user has rated the item positively, and sample an unmatched set marked as 0 for each user. The threshold of positive rating is 4 for MovieLens-20M, while no threshold is set for Book-Crossing and Last.FM due to their sparsity.\n\nWe use Microsoft Satori<sup>7</sup> to construct the knowledge graph for each dataset. We first select a subset of triples from the whole KG with a confidence level greater than 0.9. Given the sub-KG, we collect Satori IDs of all valid movies/books/musicians by matching their names with tail of triples (head, film.film.name, tail), (head, book.book.title, tail), or (head, typeobject.name, tail). Items with multiple matched or no matched entities are excluded for simplicity. We then match the item IDs with the head of all triples and select all well-matched triples from the sub-KG. The basic statistics of the three datasets are presented in Table 1.\n\n## 4.2Baselines\n\nWe compare the proposed KGCN with the following baselines, in which the first two baselines are KG-free while the rest are all KG-aware methods. Hyper-parameter settings for baselines are introduced in the next subsection.\n\n- SVD [11] is a classic CF-based model using inner product to model user-item interactions.  \n- LibFM [14] is a feature-based factorization model in CTR scenarios. We concatenate user ID and item ID as input for LibFM.\n\nTable 2: The results of AUC and F1 in CTR prediction.  \n\n<table><tr><td rowspan=\"2\">Model</td><td colspan=\"2\">MovieLens-20M</td><td colspan=\"2\">Book-Crossing</td><td colspan=\"2\">Last.FM</td></tr><tr><td>AUC</td><td>F1</td><td>AUC</td><td>F1</td><td>AUC</td><td>F1</td></tr><tr><td>SVD</td><td>0.963 (-1.5%)</td><td>0.919 (-1.4%)</td><td>0.672 (-8.9%)</td><td>0.635 (-7.7%)</td><td>0.769 (-3.4%)</td><td>0.696 (-3.5%)</td></tr><tr><td>LibFM</td><td>0.959 (-1.9%)</td><td>0.906 (-2.8%)</td><td>0.691 (-6.4%)</td><td>0.618 (-10.2%)</td><td>0.778 (-2.3%)</td><td>0.710 (-1.5%)</td></tr><tr><td>LibFM + TransE</td><td>0.966 (-1.2%)</td><td>0.917 (-1.6%)</td><td>0.698 (-5.4%)</td><td>0.622 (-9.6%)</td><td>0.777 (-2.4%)</td><td>0.709 (-1.7%)</td></tr><tr><td>PER</td><td>0.832 (-14.9%)</td><td>0.788 (-15.5%)</td><td>0.617 (-16.4%)</td><td>0.562 (-18.3%)</td><td>0.633 (-20.5%)</td><td>0.596 (-17.3%)</td></tr><tr><td>CKE</td><td>0.924 (-5.5%)</td><td>0.871 (-6.5%)</td><td>0.677 (-8.3%)</td><td>0.611 (-11.2%)</td><td>0.744 (-6.5%)</td><td>0.673 (-6.7%)</td></tr><tr><td>RippleNet</td><td>0.968 (-1.0%)</td><td>0.912 (-2.1%)</td><td>0.715 (-3.1%)</td><td>0.650 (-5.5%)</td><td>0.780 (-2.0%)</td><td>0.702 (-2.6%)</td></tr><tr><td>KGCN-sum</td><td>0.978</td><td>0.932*</td><td>0.738</td><td>0.688*</td><td>0.794 (-0.3%)</td><td>0.719 (-0.3%)</td></tr><tr><td>KGCN-concat</td><td>0.977 (-0.1%)</td><td>0.931 (-0.1%)</td><td>0.734 (-0.5%)</td><td>0.681 (-1.0%)</td><td>0.796*</td><td>0.721*</td></tr><tr><td>KGCN-neighbor</td><td>0.977 (-0.1%)</td><td>0.932*</td><td>0.728 (-1.4%)</td><td>0.679 (-1.3%)</td><td>0.781 (-1.9%)</td><td>0.699 (-3.1%)</td></tr><tr><td>KGCN-avg</td><td>0.975 (-0.3%)</td><td>0.929 (-0.3%)</td><td>0.722 (-2.2%)</td><td>0.682 (-0.9%)</td><td>0.774 (-2.8%)</td><td>0.692 (-4.0%)</td></tr></table>\n\n* Statistically significant improvement by unpaired two-sample  \\(t\\) -test with  \\(p = 0.1\\) .\n\n- LibFM + TransE extends LibFM by attaching an entity representation learned by TransE [1] to each user-item pair.  \n- PER [22] treats the KG as heterogeneous information networks and extracts meta-path based features to represent the connectivity between users and items.  \n- CKE [23] combines CF with structural, textual, and visual knowledge in a unified framework for recommendation. We implement CKE as CF plus a structural knowledge module in this paper.  \n- RippleNet [18] is a memory-network-like approach that propagates users' preferences on the KG for recommendation.\n\n### 4.3 Experiments Setup\n\nIn KGCN, we set functions  \\(g\\)  and  \\(f\\)  as inner product,  \\(\\sigma\\)  as  \\(ReLU\\)  for non-last-layer aggregator and  \\(tanh\\)  for last-layer aggregator. Other hyper-parameter settings are provided in Table 1. The hyperparameters are determined by optimizing  \\(AUC\\)  on a validation set. For each dataset, the ratio of training, evaluation, and test set is  \\(6:2:2\\) . Each experiment is repeated 3 times, and the average performance is reported. We evaluate our method in two experiment scenarios: (1) In click-through rate (CTR) prediction, we apply the trained model to predict each interaction in the test set. We use  \\(AUC\\)  and  \\(F1\\)  to evaluate CTR prediction. (2) In top-  \\(K\\)  recommendation, we use the trained model to select  \\(K\\)  items with highest predicted click probability for each user in the test set, and choose  \\(Recall@K\\)  to evaluate the recommended sets. All trainable parameters are optimized by Adam algorithm. The code of KGCN-LS is implemented under Python 3.6, TensorFlow 1.12.0, and NumPy 1.14.3.\n\nThe hyper-parameter settings for baselines are as follows. For SVD, we use the unbiased version (i.e., the predicted rating is modeled as  \\(r_{pq} = \\mathbf{p}^{\\top}\\mathbf{q}\\) ). The dimension and learning rate for the four datasets are set as:  \\(d = 8\\) ,  \\(\\eta = 0.5\\)  for MovieLens-20M, Book-Crossing;  \\(d = 8\\) ,  \\(\\eta = 0.1\\)  for Last.FM. For LibFM, the dimension is  \\(\\{1,1,8\\}\\)  and the number of training epochs is 50. The dimension of TransE is 32. For PER, we use manually designed user-item-attribute-item paths as features (i.e., \"user-movie-directormovie\", \"user-movie-genre-movie\", and \"user-movie-star-movie\" for MovieLens-20M; \"user-book-author-book\" and \"user-book-genre-book\" for Book-Crossing, \"user-musician-date_of_birth-musician\")\n\n(date of birth is discretized), \"user-musician-country-musician\", and \"user-musician-genre-musician\" for Last.FM). For CKE, the dimension of the three datasets are 64, 128, 64. The training weight for KG part is 0.1 for all datasets. The learning rate are the same as in SVD. For RippleNet,  \\(d = 8\\) ,  \\(H = 2\\) ,  \\(\\lambda_1 = 10^{-6}\\) ,  \\(\\lambda_2 = 0.01\\) ,  \\(\\eta = 0.01\\)  for MovieLens-20M;  \\(d = 16\\) ,  \\(H = 3\\) ,  \\(\\lambda_1 = 10^{-5}\\) ,  \\(\\lambda_2 = 0.02\\) ,  \\(\\eta = 0.005\\)  for Last.FM. Other hyper-parameters are the same as reported in their original papers or as default in their codes.\n\n## 4.4 Results\n\nThe results of CTR prediction and top-  \\(K\\)  recommendation are presented in Table 2 and Figure 2, respectively (SVD, LibFM and other variants of KGCN are not plotted in Figure 2 for clarity). We have the following observations:\n\n- In general, we find that the improvements of KGCN on book and music are higher than movie. This demonstrates that KGCN can well address sparse scenarios, since Book-Crossing and Last.FM are much sparser than MovieLens20M.  \n- The performance of KG-free baselines, SVD and LibFM, are actually better than the two KG-aware baselines PER and CKE, which indicates that PER and CKE cannot make full use of the KG with manually designed meta-paths and TransR-like regularization.  \n- LibFM + TransE is better than LibFM in most cases, which demonstrates that the introduction of KG is helpful for recommendation in general.  \n- PER performs worst among all baselines, since it is hard to define optimal meta-paths in reality.  \n- RippleNet shows strong performance compared with other baselines. Note that RippleNet also uses multi-hop neighborhood structure, which interestingly shows that capturing proximity information in the KG is essential for recommendation.\n\nThe last four rows in Table 2 summarize the performance of KGCN variants. The first three (sum, concat, neighbor) correspond to different aggregators introduced in the preceding section, while the last variant KGCN-avg is a reduced case of KGCN-sum where\n\n![](images/8608074a654e466b43e187187899b0db5e3ca8230f31e89c101234aac851bbb3.jpg)  \nFigure 2: The results of  \\(Recall@K\\)  in top- \\(K\\)  recommendation.\n\n![](images/fc0c28dd1789eaab3d00447acd90701e30bf61163e8182c6911d5923362d75ee.jpg)\n\n![](images/05a91947391b7febbe45b236a2a54872961451449a9c311b3465c03a56c20c81.jpg)\n\nTable 3: AUC result of KGCN with different neighbor sampling size  \\(K\\) .  \n\n<table><tr><td>K</td><td>2</td><td>4</td><td>8</td><td>16</td><td>32</td><td>64</td></tr><tr><td>MovieLens-20M</td><td>0.978</td><td>0.979</td><td>0.978</td><td>0.978</td><td>0.977</td><td>0.978</td></tr><tr><td>Book-Crossing</td><td>0.680</td><td>0.727</td><td>0.736</td><td>0.725</td><td>0.711</td><td>0.723</td></tr><tr><td>Last.FM</td><td>0.791</td><td>0.794</td><td>0.795</td><td>0.793</td><td>0.794</td><td>0.792</td></tr></table>\n\nTable 4: AUC result of KGCN with different depth of receptive field  \\(H\\)  .  \n\n<table><tr><td>H</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>MovieLens-20M</td><td>0.972</td><td>0.976</td><td>0.974</td><td>0.514</td></tr><tr><td>Book-Crossing</td><td>0.738</td><td>0.731</td><td>0.684</td><td>0.547</td></tr><tr><td>Last.FM</td><td>0.794</td><td>0.723</td><td>0.545</td><td>0.534</td></tr></table>\n\nneighborhood representations are directly averaged without user-relation scores (i.e.,  \\(\\mathbf{v}_{\\mathcal{N}(v)}^u = \\sum_{e\\in \\mathcal{N}(v)}\\mathbf{e}\\)  instead of Eq. (2)). Therefore, KGCN-avg is used to examine the efficacy of the \"attention mechanism\". From the results we find that:\n\n- KGCN outperforms all baselines by a significant margin, while their performances are slightly distinct: KGCN-sum performs best in general, while the performance of KGCN-neighbor shows a clear gap on Book-Crossing and Last.FM. This may be because the neighbor aggregator uses the neighborhood representation only, thus losing useful information from the entity itself.  \n- KGCN-avg performs worse than KGCN-sum, especially in Book-Crossing and Last.FM where interactions are sparse. This demonstrates that capturing users' personalized preferences and semantic information of the KG do benefit the recommendation.\n\n4.4.1 Impact of neighbor sampling size. We vary the size of sampled neighbor  \\(K\\)  to investigate the efficacy of usage of the KG. From Table 3 we observe that KGCN achieves the best performance when  \\(K = 4\\)  or 8. This is because a too small  \\(K\\)  does not have enough capacity to incorporate neighborhood information, while a too large  \\(K\\)  is prone to be misled by noises.  \n4.4.2 Impact of depth of receptive field. We investigate the influence of depth of receptive field in KGCN by varying  \\(H\\)  from 1 to 4. The results are shown in Table 4, which demonstrate that KGCN\n\nTable 5: AUC result of KGCN with different dimension of embedding.  \n\n<table><tr><td>d</td><td>4</td><td>8</td><td>16</td><td>32</td><td>64</td><td>128</td></tr><tr><td>MovieLens-20M</td><td>0.968</td><td>0.970</td><td>0.975</td><td>0.977</td><td>0.973</td><td>0.972</td></tr><tr><td>Book-Crossing</td><td>0.709</td><td>0.732</td><td>0.733</td><td>0.735</td><td>0.739</td><td>0.736</td></tr><tr><td>Last.FM</td><td>0.789</td><td>0.793</td><td>0.797</td><td>0.793</td><td>0.790</td><td>0.789</td></tr></table>\n\nis more sensitive to  \\(H\\)  compared to  \\(K\\) . We observe the occurrence of serious model collapse when  \\(H = 3\\)  or 4, as a larger  \\(H\\)  brings massive noises to the model. This is also in accordance with our intuition, since a too long relation-chain makes little sense when inferring inter-item similarities. An  \\(H\\)  of 1 or 2 is enough for real cases according to the experiment results.\n\n4.4.3 Impact of dimension of embedding. Lastly, we examine the influence of dimension of embedding  \\(d\\)  on performance of KGCN. The result in Table 5 is rather intuitive: Increasing  \\(d\\)  initially can boost the performance since a larger  \\(d\\)  can encode more information of users and entities, while a too large  \\(d\\)  adversely suffers from overfitting.\n",
  "hyperparameter": "Key hyperparameters include: (1) K (neighbor sampling size): 4 for MovieLens-20M, 8 for Book-Crossing and Last.FM, with best performance at K=4 or 8; (2) d (embedding dimension): 32 for MovieLens-20M, 64 for Book-Crossing, 16 for Last.FM, with optimal range 16-64; (3) H (depth of receptive field/number of layers): 2 for MovieLens-20M, 1 for Book-Crossing and Last.FM, with H=1 or 2 recommended to avoid model collapse; (4) λ (L2 regularization weight): 10^-7 for MovieLens-20M, 2×10^-5 for Book-Crossing, 10^-4 for Last.FM; (5) η (learning rate): 2×10^-2 for MovieLens-20M, 2×10^-4 for Book-Crossing, 5×10^-4 for Last.FM; (6) batch size: 65,536 for MovieLens-20M, 256 for Book-Crossing, 128 for Last.FM. Activation functions: ReLU for non-last-layer aggregators and tanh for last-layer aggregators."
}