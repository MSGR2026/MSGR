{
  "id": "Koopa_2022",
  "paper_title": "Koopa: Knowledge-Enhanced Pre-trained Language Model for Recommendation",
  "alias": "Koopa",
  "year": 2022,
  "domain": "Recsys",
  "task": "KnowledgeAwareRecommendation",
  "idea": "KGAT (Knowledge Graph Attention Network) exploits high-order connectivity in collaborative knowledge graphs through attentive embedding propagation layers. The core innovation is: (1) recursively propagating embeddings from neighbors using knowledge-aware attention mechanism that considers both entity proximity and relation semantics, (2) capturing collaborative signals through multiple propagation layers to model high-order user-item-entity relations, and (3) using three types of aggregators (GCN, GraphSage, Bi-Interaction) to combine entity and ego-network representations, with Bi-Interaction aggregator performing best by encoding both additive and multiplicative feature interactions.",
  "introduction": "# 1 INTRODUCTION\n\nThe success of recommendation system makes it prevalent in Web applications, ranging from search engines, E-commerce, to social media sites and news portals â€” without exaggeration, almost every service that provides content to users is equipped with a recommendation system. To predict user preference from the key (and widely available) source of user behavior data, much research effort has been devoted to collaborative filtering (CF) [12, 13, 32]. Despite its effectiveness and universality, CF methods suffer from the inability of modeling side information [30, 31], such as item attributes, user profiles, and contexts, thus perform poorly in sparse situations where users and items have few interactions. To integrate such information, a common paradigm is to transform them into a generic feature vector, together with user ID and item ID, and feed them into a supervised learning (SL) model to predict the score. Such a SL paradigm for recommendation has been widely deployed in industry [7, 24, 41], and some representative models include factorization machine (FM) [23], NFM (neural FM) [11], Wide&Deep [7], and xDeepFM [18], etc.\n\nAlthough these methods have provided strong performance, a deficiency is that they model each interaction as an independent data instance and do not consider their relations. This makes them insufficient to distill attribute-based collaborative signal from the collective behaviors of users. As shown in Figure 1, there is an interaction between user  \\(u_{1}\\)  and movie  \\(i_{1}\\) , which is directed by the person  \\(e_{1}\\) . CF methods focus on the histories of similar users who also watched  \\(i_{1}\\) , i.e.,  \\(u_{4}\\)  and  \\(u_{5}\\) ; while SL methods emphasize the similar items with the attribute  \\(e_{1}\\) , i.e.,  \\(i_{2}\\) . Obviously, these two types of information not only are complementary for recommendation,\n\n![](images/462e2feeaca860174db893607f0b9d97049d1e7171a8d8fbd216293a4f90189b.jpg)  \nFigure 1: A toy example of collaborative knowledge graph.  \\(u_{1}\\)  is the target user to provide recommendation for. The yellow circle and grey circle denote the important users and items discovered by high-order relations but are overlooked by traditional methods. Best view in color.\n\nbut also form a high-order relationship between a target user and item together. However, existing SL methods fail to unify them and cannot take into account the high-order connectivity, such as the users in the yellow circle who watched other movies directed by the same person  \\(e_1\\) , or the items in the grey circle that share other common relations with  \\(e_1\\) .\n\nTo address the limitation of feature-based SL models, a solution is to take the graph of item side information, aka. knowledge graph[3, 4], into account to construct the predictive model. We term the hybrid structure of knowledge graph and user-item graph as collaborative knowledge graph (CKG). As illustrated in Figure 1, the key to successful recommendation is to fully exploit the high-order relations in CKG, e.g., the long-range connectivities:\n\n-  \\(u_1 \\xrightarrow{r_1} i_1 \\xrightarrow{-r_2} e_1 \\xrightarrow{r_2} i_2 \\xrightarrow{-r_1} \\{u_2, u_3\\}\\) ,  \n\\(u_{1}\\xrightarrow{r_{1}}i_{1}\\xrightarrow{-r_{2}}e_{1}\\xrightarrow{r_{3}}\\{i_{3},i_{4}\\} ,\\)\n\nwhich represent the way to the yellow and grey circle, respectively. Nevertheless, to exploit such high-order information the challenges are non-negligible: 1) the nodes that have high-order relations with the target user increase dramatically with the order size, which imposes computational overload to the model, and 2) the high-order relations contribute unequally to a prediction, which requires the model to carefully weight (or select) them.\n\nSeveral recent efforts have attempted to leverage the CKG structure for recommendation, which can be roughly categorized into two types, path-based [14, 25, 29, 33, 37, 39] and regularization-based [5, 15, 33, 38]:\n\n- Path-based methods extract paths that carry the high-order information and feed them into predictive model. To handle the large number of paths between two nodes, they have either applied path selection algorithm to select prominent paths [25, 33], or defined meta-path patterns to constrain the paths [14, 36]. One issue with such two-stage methods is that the first stage of path selection has a large impact on the final performance, but it is not optimized for the recommendation objective. Moreover, defining effective meta-paths requires domain knowledge, which can be rather labor-intensive for complicated KG with diverse types of relations and entities, since many meta-paths have to be defined to retain model fidelity.  \n- Regularization-based methods devise additional loss terms that capture the KG structure to regularize the recommender model learning. For example, KTUP [5] and CFKG [1] jointly train\n\nthe two tasks of recommendation and KG completion with shared item embeddings. Instead of directly plugging high-order relations into the model optimized for recommendation, these methods only encode them in an implicit manner. Due to the lack of an explicit modeling, neither the long-range connectivities are guaranteed to be captured, nor the results of high-order modeling are interpretable.\n\nConsidering the limitations of existing solutions, we believe it is of critical importance to develop a model that can exploit high-order information in KG in an efficient, explicit, and end-to-end manner. Towards this end, we take inspiration from the recent developments of graph neural networks [9, 17, 28], which have the potential of achieving the goal but have not been explored much for KG-based recommendation. Specifically, we propose a new method named Knowledge Graph Attention Network (KGAT), which is equipped with two designs to correspondingly address the challenges in high-order relation modeling: 1) recursive embedding propagation, which updates a node's embedding based on the embeddings of its neighbors, and recursively performs such embedding propagation to capture high-order connectivities in a linear time complexity; and 2) attention-based aggregation, which employs the neural attention mechanism [6, 27] to learn the weight of each neighbor during a propagation, such that the attention weights of cascaded propagations can reveal the importance of a high-order connectivity. Our KGAT is conceptually advantageous to existing methods in that: 1) compared with path-based methods, it avoids the labor-intensive process of materializing paths, thus is more efficient and convenient to use, and 2) compared with regularization-based methods, it directly factors high-order relations into the predictive model, thus all related parameters are tailored for optimizing the recommendation objective.\n\nThe contributions of this work are summarized as follows:\n\n- We highlight the importance of explicitly modeling the high-order relations in collaborative knowledge graph to provide better recommendation with item side information.  \n- We develop a new method KGAT, which achieves high-order relation modeling in an explicit and end-to-end manner under the graph neural network framework.  \n- We conduct extensive experiments on three public benchmarks, demonstrating the effectiveness of KGAT and its interpretability in understanding the importance of high-order relations.\n",
  "method": "# 3 METHODOLOGY\n\nWe now present the proposed KGAT model, which exploits high-order relations in an end-to-end fashion. Figure 2 shows the model framework, which consists of three main components: 1) embedding layer, which parameterizes each node as a vector by preserving the structure of CKG; 2) attentive embedding propagation layers, which recursively propagate embeddings from a node's neighbors to update its representation, and employ knowledge-aware attention mechanism to learn the weight of each neighbor during a propagation; and 3) prediction layer, which aggregates the representations of a user and an item from all propagation layers, and outputs the predicted matching score.\n\n## 3.1 Embedding Layer\n\nKnowledge graph embedding is an effective way to parameterize entities and relations as vector representations, while preserving the graph structure. Here we employ TransR [19], a widely used method, on CKG. To be more specific, it learns embeds each entity and relation by optimizing the translation principle  \\(\\mathbf{e}_h^r +\\mathbf{e}_r\\approx \\mathbf{e}_t^r\\) , if a triplet  \\((h,r,t)\\)  exists in the graph. Herein,  \\(\\mathbf{e}_h,\\mathbf{e}_t\\in \\mathbb{R}^d\\)  and  \\(\\mathbf{e}_r\\in \\mathbb{R}^k\\)  are the embedding for  \\(h,t\\) , and  \\(r\\) , respectively; and  \\(\\mathbf{e}_h^r,\\mathbf{e}_t^r\\)  are the projected representations of  \\(\\mathbf{e}_h\\)  and  \\(\\mathbf{e}_t\\)  in the relation  \\(r\\) 's space. Hence, for a given triplet  \\((h,r,t)\\) , its plausibility score (or energy score) is formulated as follows:\n\n\\[\ng (h, r, t) = \\left\\| \\mathbf {W} _ {r} \\mathbf {e} _ {h} + \\mathbf {e} _ {r} - \\mathbf {W} _ {r} \\mathbf {e} _ {t} \\right\\| _ {2} ^ {2}, \\tag {1}\n\\]\n\nwhere  \\(\\mathbf{W}_r\\in \\mathbb{R}^{k\\times d}\\)  is the transformation matrix of relation  \\(r\\) , which projects entities from the  \\(d\\) -dimension entity space into the  \\(k\\) -dimension relation space. A lower score of  \\(g(h,r,t)\\)  suggests that the triplet is more likely to be true true, and vice versa.\n\nThe training of TransR considers the relative order between valid triplets and broken ones, and encourages their discrimination\n\nthrough a pairwise ranking loss:\n\n\\[\n\\mathcal {L} _ {\\mathrm {K G}} = \\sum_ {(h, r, t, t ^ {\\prime}) \\in \\mathcal {T}} - \\ln \\sigma (g (h, r, t ^ {\\prime}) - g (h, r, t)), \\tag {2}\n\\]\n\nwhere  \\(\\mathcal{T} = \\{(h,r,t,t^{\\prime})|(h,r,t)\\in \\mathcal{G},(h,r,t^{\\prime})\\notin \\mathcal{G}\\}\\) , and  \\((h,r,t^{\\prime})\\)  is a broken triplet constructed by replacing one entity in a valid triplet randomly;  \\(\\sigma (\\cdot)\\)  is the sigmoid function. This layer models the entities and relations on the granularity of triples, working as a regularizer and injecting the direct connections into representations, and thus increases the model representation ability (evidences in Section 4.4.3.)\n\n### 3.2 Attentive Embedding Propagation Layers\n\nNext we build upon the architecture of graph convolution network [17] to recursively propagate embeddings along high-order connectivity; moreover, by exploiting the idea of graph attention network [28], we generate attentive weights of cascaded propagations to reveal the importance of such connectivity. Here we start by describing a single layer, which consists of three components: information propagation, knowledge-aware attention, and information aggregation, and then discuss how to generalize it to multiple layers.\n\nInformation Propagation: One entity can be involved in multiple triplets, serving as the bridge connecting two triplets and propagating information. Taking  \\(e_1 \\xrightarrow{r_2} i_2 \\xrightarrow{-r_1} u_2\\)  and  \\(e_2 \\xrightarrow{r_3} i_2 \\xrightarrow{-r_1} u_2\\)  as an example, item  \\(i_2\\)  takes attributes  \\(e_1\\)  and  \\(e_2\\)  as inputs to enrich its own features, and then contributes user  \\(u_2\\) 's preferences, which can be simulated by propagating information from  \\(e_1\\)  to  \\(u_2\\) . We build upon this intuition to perform information propagation between an entity and its neighbors.\n\nConsidering an entity  \\(h\\) , we use  \\(\\mathcal{N}_h = \\{(h,r,t) | (h,r,t) \\in \\mathcal{G}\\}\\)  to denote the set of triplets where  \\(h\\)  is the head entity, termed ego-network [21]. To characterize the first-order connectivity structure of entity  \\(h\\) , we compute the linear combination of  \\(h\\) 's ego-network:\n\n\\[\n\\mathbf {e} _ {\\mathcal {N} _ {h}} = \\sum_ {(h, r, t) \\in \\mathcal {N} _ {h}} \\pi (h, r, t) \\mathbf {e} _ {t}, \\tag {3}\n\\]\n\nwhere  \\(\\pi (h,r,t)\\)  controls the decay factor on each propagation on edge  \\((h,r,t)\\) , indicating how much information being propagated from  \\(t\\)  to  \\(h\\)  conditioned to relation  \\(r\\) .\n\nKnowledge-aware Attention: We implement  \\(\\pi(h, r, t)\\)  via relational attention mechanism, which is formulated as follows:\n\n\\[\n\\pi (h, r, t) = \\left(\\mathbf {W} _ {r} \\mathbf {e} _ {t}\\right) ^ {\\top} \\operatorname {t a n h} \\left(\\left(\\mathbf {W} _ {r} \\mathbf {e} _ {h} + \\mathbf {e} _ {r}\\right)\\right), \\tag {4}\n\\]\n\nwhere we select tanh [28] as the nonlinear activation function. This makes the attention score dependent on the distance between  \\(e_h\\)  and  \\(e_t\\)  in the relation  \\(r\\) 's space, e.g., propagating more information for closer entities. Note that, we employ only inner product on these representations for simplicity, and leave the further exploration of the attention module as the future work.\n\nHereafter, we normalize the coefficients across all triplets connected with  \\(h\\)  by adopting the softmax function:\n\n\\[\n\\pi (h, r, t) = \\frac {\\exp (\\pi (h , r , t))}{\\sum_ {(h , r ^ {\\prime} , t ^ {\\prime}) \\in \\mathcal {N} _ {h}} \\exp (\\pi (h , r ^ {\\prime} , t ^ {\\prime}))}. \\tag {5}\n\\]\n\nAs a result, the final attention score is capable of suggesting which neighbor nodes should be given more attention to capture collaborative signals. When performing propagation forward, the attention flow suggests parts of the data to focus on, which can be treated as explanations behind the recommendation.\n\nDistinct from the information propagation in GCN [17] and GraphSage [9] which set the discount factor between two nodes as  \\(1 / \\sqrt{|\\mathcal{N}_h||\\mathcal{N}_t|}\\)  or  \\(1 / |\\mathcal{N}_t|\\) , our model not only exploits the proximity structure of graph, but also specify varying importance of neighbors. Moreover, distinct from graph attention network [28] which only takes node representations as inputs, we model the relation  \\(e_r\\)  between  \\(e_h\\)  and  \\(e_t\\) , encoding more information during propagation. We perform experiments to verify the effectiveness of the attention mechanism and visualize the attention flow in Section 4.4.3 and Section 4.5, respectively.\n\nInformation Aggregation: The final phase is to aggregate the entity representation  \\(\\mathbf{e}_h\\)  and its ego-network representations  \\(\\mathbf{e}_{\\mathcal{N}_h}\\)  as the new representation of entity  \\(h -\\)  more formally,  \\(\\mathbf{e}_h^{(1)} = f(\\mathbf{e}_h,\\mathbf{e}_{\\mathcal{N}_h})\\)  . We implement  \\(f(\\cdot)\\)  using three types of aggregators:\n\n- GCN Aggregator [17] sums two representations up and applies a nonlinear transformation, as follows:\n\n\\[\nf _ {\\mathrm {G C N}} = \\text {L e a k y R e L U} \\left(\\mathbf {W} \\left(\\mathbf {e} _ {h} + \\mathbf {e} _ {\\mathcal {N} _ {h}}\\right)\\right), \\tag {6}\n\\]\n\nwhere we set the activation function set as LeakyReLU [20];  \\(\\mathbf{W}\\in \\mathbb{R}^{d^{\\prime}\\times d}\\)  are the trainable weight matrices to distill useful information for propagation, and  \\(d^{\\prime}\\)  is the transformation size.\n\n- GraphSage Aggregator [9] concatenates two representations, followed by a nonlinear transformation:\n\n\\[\nf _ {\\text {G r a p h S a g e}} = \\text {L e a k y R e L U} \\left(\\mathbf {W} \\left(\\mathbf {e} _ {h} \\| \\mathbf {e} _ {\\mathcal {N} _ {h}}\\right)\\right), \\tag {7}\n\\]\n\nwhere  \\(||\\)  is the concatenation operation.\n\n- Bi-Interaction Aggregator is carefully designed by us to consider two kinds of feature interactions between  \\(\\mathbf{e}_h\\)  and  \\(\\mathbf{e}_{\\mathcal{N}_h}\\) , as follows:\n\n\\[\n\\begin{array}{l} f _ {\\text {B i - I t e r a c t i o n}} = \\text {L e a k y R e L U} \\left(\\mathbf {W} _ {1} \\left(\\mathbf {e} _ {h} + \\mathbf {e} _ {\\mathcal {N} _ {h}}\\right)\\right) + \\\\ \\text {L e a k y R e L U} \\left(\\mathbf {W} _ {2} \\left(\\mathbf {e} _ {h} \\odot \\mathbf {e} _ {\\mathcal {N} _ {h}}\\right)\\right), \\tag {8} \\\\ \\end{array}\n\\]\n\nwhere  \\(\\mathbf{W}_1, \\mathbf{W}_2 \\in \\mathbb{R}^{d' \\times d}\\)  are the trainable weight matrices, and  \\(\\odot\\)  denotes the element-wise product. Distinct from GCN and GraphSage aggregators, we additionally encode the feature interaction between  \\(\\mathbf{e}_h\\)  and  \\(\\mathbf{e}_{\\mathcal{N}_h}\\) . This term makes the information being propagated sensitive to the affinity between  \\(\\mathbf{e}_h\\)  and  \\(\\mathbf{e}_{\\mathcal{N}_h}\\) , e.g., passing more messages from similar entities.\n\nTo summarize, the advantage of the embedding propagation layer lies in explicitly exploiting the first-order connectivity information to relate user, item, and knowledge entity representations. We empirically compare the three aggregators in Section 4.4.2.\n\nHigh-order Propagation: We can further stack more propagation layers to explore the high-order connectivity information, gathering the information propagated from the higher-hop neighbors. More formally, in the  \\(l\\) -th steps, we recursively formulate the representation of an entity as:\n\n\\[\n\\mathbf {e} _ {h} ^ {(l)} = f \\left(\\mathbf {e} _ {h} ^ {(l - 1)}, \\mathbf {e} _ {\\mathcal {N} _ {h}} ^ {(l - 1)}\\right), \\tag {9}\n\\]\n\nwherein the information propagated within  \\(l\\) -ego network for the entity  \\(h\\)  is defined as follows,\n\n\\[\n\\mathbf {e} _ {\\mathcal {N} _ {h}} ^ {(l - 1)} = \\sum_ {(h, r, t) \\in \\mathcal {N} _ {h}} \\pi (h, r, t) \\mathbf {e} _ {t} ^ {(l - 1)}, \\tag {10}\n\\]\n\n\\(\\mathbf{e}_t^{(l-1)}\\)  is the representation of entity  \\(t\\)  generated from the previous information propagation steps, memorizing the information from its  \\((l-1)\\) -hop neighbors;  \\(\\mathbf{e}_h^{(0)}\\)  is set as  \\(\\mathbf{e}_h\\)  at the initial information-propagation iteration. It further contributes to the representation of entity  \\(h\\)  at layer  \\(l\\) . As a result, high-order connectivity like  \\(u_2 \\xrightarrow{r_1} i_2 \\xrightarrow{-r_2} e_1 \\xrightarrow{r_2} i_1 \\xrightarrow{-r_1} u_1\\)  can be captured in the embedding propagation process. Furthermore, the information from  \\(u_2\\)  is explicitly encoded in  \\(\\mathbf{e}_{u_1}^{(3)}\\) . Clearly, the high-order embedding propagation seamlessly injects the attribute-based collaborative signal into the representation learning process.\n\n### 3.3 Model Prediction\n\nAfter performing  \\(L\\)  layers, we obtain multiple representations for user node  \\(u\\) , namely  \\(\\{\\mathbf{e}_u^{(1)}, \\dots, \\mathbf{e}_u^{(L)}\\}\\) ; analogous to item node  \\(i\\) ,  \\(\\{\\mathbf{e}_i^{(1)}, \\dots, \\mathbf{e}_i^{(L)}\\}\\)  are obtained. As the output of the  \\(l\\) -th layer is the message aggregation of the tree structure depth of  \\(l\\)  rooted at  \\(u\\)  (or  \\(i\\) ) as shown in Figure 1, the outputs in different layers emphasize the connectivity information of different orders. We hence adopt the layer-aggregation mechanism [34] to concatenate the representations at each step into a single vector, as follows:\n\n\\[\n\\mathbf {e} _ {u} ^ {*} = \\mathbf {e} _ {u} ^ {(0)} \\| \\dots \\| \\mathbf {e} _ {u} ^ {(L)}, \\quad \\mathbf {e} _ {i} ^ {*} = \\mathbf {e} _ {i} ^ {(0)} \\| \\dots \\| \\mathbf {e} _ {i} ^ {(L)}, \\tag {11}\n\\]\n\nwhere  \\(\\parallel\\)  is the concatenation operation. By doing so, we not only enrich the initial embeddings by performing the embedding propagation operations, but also allow controlling the strength of propagation by adjusting  \\(L\\) .\n\nFinally, we conduct inner product of user and item representations, so as to predict their matching score:\n\n\\[\n\\hat {y} (u, i) = \\mathbf {e} _ {u} ^ {* \\top} \\mathbf {e} _ {i} ^ {*}. \\tag {12}\n\\]\n\n### 3.4 Optimization\n\nTo optimize the recommendation model, we opt for the BPR loss [22]. Specifically, it assumes that the observed interactions, which indicate more user preferences, should be assigned higher prediction values than unobserved ones:\n\n\\[\n\\mathcal {L} _ {\\mathrm {C F}} = \\sum_ {(u, i, j) \\in O} - \\ln \\sigma (\\hat {y} (u, i) - \\hat {y} (u, j)) \\tag {13}\n\\]\n\nwhere  \\(O = \\{(u,i,j)|(u,i)\\in \\mathcal{R}^{+},(u,j)\\in \\mathcal{R}^{-}\\}\\)  denotes the training set,  \\(\\mathcal{R}^+\\)  indicates the observed (positive) interactions between user  \\(u\\)  and item  \\(j\\)  while  \\(\\mathcal{R}^{-}\\)  is the sampled unobserved (negative) interaction set;  \\(\\sigma (\\cdot)\\)  is the sigmoid function.\n\nFinally, we have the objective function to learn Equations (2) and (13) jointly, as follows:\n\n\\[\n\\mathcal {L} _ {\\mathrm {K G A T}} = \\mathcal {L} _ {\\mathrm {K G}} + \\mathcal {L} _ {\\mathrm {C F}} + \\lambda \\| \\Theta \\| _ {2} ^ {2}, \\tag {14}\n\\]\n\nwhere  \\(\\Theta = \\{\\mathbf{E},\\mathbf{W}_r,\\forall l\\in \\mathcal{R},\\mathbf{W}_1^{(l)},\\mathbf{W}_2^{(l)},\\forall l\\in \\{1,\\dots ,L\\} \\}\\)  is the model parameter set, and  \\(\\mathbf{E}\\)  is the embedding table for all entities and relations;  \\(L_{2}\\)  regularization parameterized by  \\(\\lambda\\)  on  \\(\\Theta\\)  is conducted to prevent overfitting. It is worth pointing out that in terms of\n\nmodel size, the majority of model parameters comes from the entity embeddings (e.g., 6.5 million on experimented Amazon dataset), which is almost identical to that of FM; the propagation layer weights are lightweight (e.g., 5.4 thousand for the tower structure of three layers, i.e.,  \\(64 - 32 - 16 - 8\\) , on the Amazon dataset).\n\n3.4.1 Training: We optimize  \\(\\mathcal{L}_{KG}\\)  and  \\(\\mathcal{L}_{CF}\\)  alternatively, where mini-batch Adam [16] is adopted to optimize the embedding loss and the prediction loss. Adam is a widely used optimizer, which is able to adaptively control the learning rate w.r.t. the absolute value of gradient. In particular, for a batch of randomly sampled  \\((h,r,t,t')\\) , we update the embeddings for all nodes; hereafter, we sample a batch of  \\((u,i,j)\\)  randomly, retrieve their representations after  \\(L\\)  steps of propagation, and then update model parameters by using the gradients of the prediction loss.\n\n3.4.2 Time Complexity Analysis: As we adopt the alternative optimization strategy, the time cost mainly comes from two parts. For the knowledge graph embedding (cf. Equation (2)), the translation principle has computational complexity  \\(O(|\\mathcal{G}_2|d^2)\\) . For the attention embedding propagation part, the matrix multiplication of the  \\(l\\) -th layer has computational complexity  \\(O(|\\mathcal{G}|d_{l}d_{l - 1})\\) ; and  \\(d_{l}\\)  and  \\(d_{l - 1}\\)  are the current and previous transformation size. For the final prediction layer, only the inner product is conducted, for which the time cost of the whole training epoch is  \\(O(\\sum_{l = 1}^{L}|\\mathcal{G}|d_l)\\) . Finally, the overall training complexity of KGAT is  \\(O(|\\mathcal{G}_2|^2 + \\sum_{l = 1}^{L}|\\mathcal{G}|d_{l}d_{l - 1} + |\\mathcal{G}|d_{l})\\) .\n\nAs online services usually require real-time recommendation, the computational cost during inference is more important that that of training phase. Empirically, FM, NFM, CFKG, CKE, GC-MC, KGAT, MRec, and RippleNet cost around 700s, 780s, 800s, 420s, 500s, 560s, 20 hours, and 2 hours for all testing instances on Amazon-Book dataset, respectively. As we can see, KGAT achieves comparable computation complexity to SL models (FM and NFM) and regularization-based methods (CFKG and CKE), being much efficient that path-based methods (MRec and RippleNet).\n",
  "experiments": "# 4 EXPERIMENTS\n\nWe evaluate our proposed method, especially the embedding propagation layer, on three real-world datasets. We aim to answer the following research questions:\n\n- RQ1: How does KGAT perform compared with state-of-the-art knowledge-aware recommendation methods?  \n- RQ2: How do different components (i.e., knowledge graph embedding, attention mechanism, and aggregator selection) affect KGAT?  \n- RQ3: Can KGAT provide reasonable explanations about user preferences towards items?\n\n## 4.1 Dataset Description\n\nTo evaluate the effectiveness of KGAT, we utilize three benchmark datasets: Amazon-book, Last-FM, and Yelp2018, which are publicly accessible and vary in terms of domain, size, and sparsity.\n\nAmazon-book \\(^2\\) : Amazon-review is a widely used dataset for product recommendation [10]. We select Amazon-book from this\n\nTable 1: Statistics of the datasets.  \n\n<table><tr><td colspan=\"2\"></td><td>Amazon-book</td><td>Last-FM</td><td>Yelp2018</td></tr><tr><td rowspan=\"3\">User-Item Interaction</td><td>#Users</td><td>70,679</td><td>23,566</td><td>45,919</td></tr><tr><td>#Items</td><td>24,915</td><td>48,123</td><td>45,538</td></tr><tr><td>#Interactions</td><td>847,733</td><td>3,034,796</td><td>1,185,068</td></tr><tr><td rowspan=\"3\">Knowledge Graph</td><td>#Entities</td><td>88,572</td><td>58,266</td><td>90,961</td></tr><tr><td>#Relations</td><td>39</td><td>9</td><td>42</td></tr><tr><td>#Triplets</td><td>2,557,746</td><td>464,567</td><td>1,853,704</td></tr></table>\n\ncollection. To ensure the quality of the dataset, we use the 10-core setting, i.e., retaining users and items with at least ten interactions.\n\nLast-FM<sup>3</sup>: This is the music listening dataset collected from Last.fm online music systems. Wherein, the tracks are viewed as the items. In particular, we take the subset of the dataset where the timestamp is from Jan, 2015 to June, 2015. We use the same 10-core setting in order to ensure data quality.\n\nYelp2018<sup>4</sup>: This dataset is adopted from the 2018 edition of the Yelp challenge. Here we view the local businesses like restaurants and bars as the items. Similarly, we use the 10-core setting to ensure that each user and item have at least ten interactions.\n\nBesides the user-item interactions, we need to construct item knowledge for each dataset. For Amazon-book and Last-FM, we follow the way in [40] to map items into Freebase entities via title matching if there is a mapping available. In particular, we consider the triplets that are directly related to the entities aligned with items, no matter which role (i.e., subject or object) it serves as. Distinct from existing knowledge-aware datasets that provide only one-hop entities of items, we also take the triplets that involve two-hop neighbor entities of items into consideration. For Yelp2018, we extract item knowledge from the local business information network (e.g., category, location, and attribute) as KG data. To ensure the KG quality, we then preprocess the three KG parts by filtering out infrequent entities (i.e., however than 10 in both datasets) and retaining the relations appearing in at least 50 triplets. We summarize the statistics of three datasets in Table 1.\n\nFor each dataset, we randomly select  \\(80\\%\\)  of interaction history of each user to constitute the training set, and treat the remaining as the test set. From the training set, we randomly select  \\(10\\%\\)  of interactions as validation set to tune hyper-parameters. For each observed user-item interaction, we treat it as a positive instance, and then conduct the negative sampling strategy to pair it with one negative item that the user did not consume before.\n\n## 4.2 Experimental Settings\n\n4.2.1 Evaluation Metrics. For each user in the test set, we treat all the items that the user has not interacted with as the negative items. Then each method outputs the user's preference scores over all the items, except the positive ones in the training set. To evaluate the effectiveness of top- \\(K\\)  recommendation and preference ranking, we adopt two widely-used evaluation protocols [13, 35]: recall@ \\(K\\)  and ndcg@ \\(K\\) . By default, we set  \\(K = 20\\) . We report the average metrics for all users in the test set.\n\n4.2.2 Baselines. To demonstrate the effectiveness, we compare our proposed KGAT with SL (FM and NFM), regularization-based\n\n(CFKG and CKE), path-based (MCRec and RippleNet), and graph neural network-based (GC-MC) methods, as follows:\n\n- FM [23]: This is a benchmark factorization model, where considers the second-order feature interactions between inputs. Here we treat IDs of a user, an item, and its knowledge (i.e., entities connected to it) as input features.  \n- NFM [11]: The method is a state-of-the-art factorization model, which subsumes FM under neural network. Specially, we employed one hidden layer on input features as suggested in [11].  \n- CKE [38]: This is a representative regularization-based method, which exploits semantic embeddings derived from TransR [19] to enhance matrix factorization [22].  \n- CFKG [1]: The model applies TransE [2] on the unified graph including users, items, entities, and relations, casting the recommendation task as the plausibility prediction of  \\((u, \\text{Interact}, i)\\)  triplets.  \n- MCRec [14]: This is a path-based model, which extracts qualified meta-paths as connectivity between a user and an item.  \n- RippleNet [29]: Such model combines regularization- and path-based methods, which enrich user representations by adding that of items within paths rooted at each user.  \n- GC-MC [26]: Such model is designed to employ GCN [17] encoder on graph-structured data, especially for the user-item bipartite graph. Here we apply it on the user-item knowledge graph. Especially, we employ one graph convolution layers as suggested in [26], where the hidden dimension is set equal to the embedding size.\n\n4.2.3 Parameter Settings. We implement our KGAT model in Tensorflow. The embedding size is fixed to 64 for all models, except RippleNet 16 due to its high computational cost. We optimize all models with Adam optimizer, where the batch size is fixed at 1024. The default Xavier initializer [8] to initialize the model parameters. We apply a grid search for hyper-parameters: the learning rate is tuned amongst  \\(\\{0.05, 0.01, 0.005, 0.001\\}\\) , the coefficient of  \\(L_{2}\\)  normalization is searched in  \\(\\{10^{-5}, 10^{-4}, \\dots, 10^{1}, 10^{2}\\}\\) , and the dropout ratio is tuned in  \\(\\{0.0, 0.1, \\dots, 0.8\\}\\)  for NFM, GC-MC, and KGAT. Besides, we employ the node dropout technique for GC-MC and KGAT, where the ratio is searched in  \\(\\{0.0, 0.1, \\dots, 0.8\\}\\) . For MCRec, we manually define several types of user-item-attribute-item meta-paths, such as user-book-author-user and user-book-genre-user for Amazon-book dataset; we set the hidden layers as suggested in [14], which is a tower structure with 512, 256, 128, 64 dimensions. For RippleNet, we set the number of hops and the memory size as 2 and 8, respectively. Moreover, early stopping strategy is performed, i.e., premature stopping if recall@20 on the validation set does not increase for 50 successive epochs. To model the third-order connectivity, we set the depth of KGAT  \\(L\\)  as three with hidden dimension 64, 32, and 16, respectively; we also report the effect of layer depth in Section 4.4.1. For each layer, we conduct the Bi-Interaction aggregator.\n\n## 4.3 Performance Comparison (RQ1)\n\nWe first report the performance of all the methods, and then investigate how the modeling of high-order connectivity alleviate the sparsity issues.\n\n![](images/a726decf8775ef398cfa21ca3f5b6d4a92e7dfcac7bb8e0d1ccf185d2bd07601.jpg)  \n(a) ndcg on Amazon-Book\n\n![](images/68c7b2b82cd12adb7cc2673b20fb38335faed1b08a5b6251557aa108f0cf2aa7.jpg)  \n(b) ndcg on Last-FM  \nFigure 3: Performance comparison over the sparsity distribution of user groups on different datasets. The background histograms indicate the density of each user group; meanwhile, the lines demonstrate the performance w.r.t. ndcg@20.\n\n![](images/17ad9e4c90dfc7334eab652d6a606a894c3afe0beb1287123abc5560d6039310.jpg)  \n(c) ndcg on Yelp2018\n\nTable 2: Overall Performance Comparison.  \n\n<table><tr><td rowspan=\"2\"></td><td colspan=\"2\">Amazon-Book</td><td colspan=\"2\">Last-FM</td><td colspan=\"2\">Yelp2018</td></tr><tr><td>recall</td><td>ndcg</td><td>recall</td><td>ndcg</td><td>recall</td><td>ndcg</td></tr><tr><td>FM</td><td>0.1345</td><td>0.0886</td><td>0.0778</td><td>0.1181</td><td>0.0627</td><td>0.0768</td></tr><tr><td>NFM</td><td>0.1366</td><td>0.0913</td><td>0.0829</td><td>0.1214</td><td>0.0660</td><td>0.0810</td></tr><tr><td>CKE</td><td>0.1343</td><td>0.0885</td><td>0.0736</td><td>0.1184</td><td>0.0657</td><td>0.0805</td></tr><tr><td>CFKG</td><td>0.1142</td><td>0.0770</td><td>0.0723</td><td>0.1143</td><td>0.0522</td><td>0.0644</td></tr><tr><td>MCRec</td><td>0.1113</td><td>0.0783</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>RippleNet</td><td>0.1336</td><td>0.0910</td><td>0.0791</td><td>0.1238</td><td>0.0664</td><td>0.0822</td></tr><tr><td>GC-MC</td><td>0.1316</td><td>0.0874</td><td>0.0818</td><td>0.1253</td><td>0.0659</td><td>0.0790</td></tr><tr><td>KGAT</td><td>0.1489*</td><td>0.1006*</td><td>0.0870*</td><td>0.1325*</td><td>0.0712*</td><td>0.0867*</td></tr><tr><td>%Improv.</td><td>8.95%</td><td>10.05%</td><td>4.93%</td><td>5.77%</td><td>7.18%</td><td>5.54%</td></tr></table>\n\n4.3.1 Overall Comparison. The performance comparison results are presented in Table 2. We have the following observations:\n\n- KGAT consistently yields the best performance on all the datasets. In particular, KGAT improves over the strongest baselines w.r.t. recall@20 by  \\(8.95\\%\\) ,  \\(4.93\\%\\) , and  \\(7.18\\%\\)  in Amazon-book, LastFM, and Yelp2018, respectively. By stacking multiple attentive embedding propagation layers, KGAT is capable of exploring the high-order connectivity in an explicit way, so as to capture collaborative signal effectively. This verifies the significance of capturing collaborative signal to transfer knowledge. Moreover, compared with GC-MC, KGAT justifies the effectiveness of the attention mechanism, specifying the attentive weights w.r.t. compositional semantic relations, rather than the fixed weights used in GC-MC.  \n- SL methods (i.e., FM and NFM) achieve better performance than the CFKG and CKE in most cases, indicating that regularization-based methods might not make full use of item knowledge. In particular, to enrich the representation of an item, FM and NFM exploit the embeddings of its connected entities, while CFKG and CKE only use that of its aligned entities. Furthermore, the cross features in FM and NFM actually serve as the second-order connectivity between users and entities, whereas CFKG and CKE model connectivity on the granularity of triples, leaving high-order connectivity untouched.  \n- Compared to FM, the performance of RippleNet verifies that incorporating two-hop neighboring items is of importance to enrich user representations. It therefore points to the positive effect of modeling the high-order connectivity or neighbors. However, RippleNet slightly underperforms NFM in Amazon-book and Last-FM, while performing better in Yelp2018. One possible reason is that NFM has stronger expressiveness, since the\n\nhidden layer allows NFM to capture the nonlinear and complex feature interactions between user, item, and entity embeddings.\n\n- RippleNet outperforms MRec by a large margin in Amazon-book. One possible reason is that MRec depends heavily on the quality of meta-paths, which require extensive domain knowledge to define. The observation is consistent with [29].  \n- GC-MC achieves comparable performance to RippleNet in LastFM and Yelp2018 datasets. While introducing the high-order connectivity into user and item representations, GC-MC forgoes the semantic relations between nodes; whereas RippleNet utilizes relations to guide the exploration of user preferences.\n\n4.3.2 Performance Comparison w.r.t. Interaction Sparsity Levels. One motivation to exploiting KG is to alleviate the sparsity issue, which usually limits the expressiveness of recommender systems. It is hard to establish optimal representations for inactive users with few interactions. Here we investigate whether exploiting connectivity information helps alleviate this issue.\n\nTowards this end, we perform experiments over user groups of different sparsity levels. In particular, we divide the test set into four groups based on interaction number per user, meanwhile try to keep different groups have the same total interactions. Taking Amazon-book dataset as an example, the interaction numbers per user are less than 7, 15, 48, and 4475 respectively. Figure 3 illustrates the results w.r.t. ndcg@20 on different user groups in Amazon-book, Last-FM, and Yelp2018. We can see that:\n\n- KGAT outperforms the other models in most cases, especially on the two sparsest user groups in Amazon-Book and Yelp2018. It again verifies the significance of high-order connectivity modeling, which 1) contains the lower-order connectivity used in baselines, and 2) enriches the representations of inactive users via recursive embedding propagation.  \n- It is worthwhile pointing out that KGAT slightly outperforms some baselines in the densest user group (e.g., the  \\(< 2057\\)  group of Yelp2018). One possible reason is that the preferences of users with too many interactions are too general to capture. High-order connectivity could introduce more noise into the user preferences, thus leading to the negative effect.\n\n### 4.4 Study of KGAT (RQ2)\n\nTo get deep insights on the attentive embedding propagation layer of KGAT, we investigate its impact. We first study the influence of layer numbers. In what follows, we explore how different\n\nTable 3: Effect of embedding propagation layer numbers  \\((L)\\)  \n\n<table><tr><td></td><td colspan=\"2\">Amazon-Book</td><td colspan=\"2\">Last-FM</td><td colspan=\"2\">Yelp2018</td></tr><tr><td></td><td>recall</td><td>ndcg</td><td>recall</td><td>ndcg</td><td>recall</td><td>ndcg</td></tr><tr><td>KGAT-1</td><td>0.1393</td><td>0.0948</td><td>0.0834</td><td>0.1286</td><td>0.0693</td><td>0.0848</td></tr><tr><td>KGAT-2</td><td>0.1464</td><td>0.1002</td><td>0.0863</td><td>0.1318</td><td>0.0714</td><td>0.0872</td></tr><tr><td>KGAT-3</td><td>0.1489</td><td>0.1006</td><td>0.0870</td><td>0.1325</td><td>0.0712</td><td>0.0867</td></tr><tr><td>KGAT-4</td><td>0.1503</td><td>0.1015</td><td>0.0871</td><td>0.1329</td><td>0.0722</td><td>0.0871</td></tr></table>\n\nTable 4: Effect of aggregators.  \n\n<table><tr><td rowspan=\"2\">Aggregator</td><td colspan=\"2\">Amazon-Book</td><td colspan=\"2\">Last-FM</td><td colspan=\"2\">Yelp2018</td></tr><tr><td>recall</td><td>ndcg</td><td>recall</td><td>ndcg</td><td>recall</td><td>ndcg</td></tr><tr><td>GCN</td><td>0.1381</td><td>0.0931</td><td>0.0824</td><td>0.1278</td><td>0.0688</td><td>0.0847</td></tr><tr><td>GraphSage</td><td>0.1372</td><td>0.0929</td><td>0.0822</td><td>0.1268</td><td>0.0666</td><td>0.0831</td></tr><tr><td>Bi-Interaction</td><td>0.1393</td><td>0.0948</td><td>0.0834</td><td>0.1286</td><td>0.0693</td><td>0.0848</td></tr></table>\n\naggregators affect the performance. We then examine the influence of knowledge graph embedding and attention mechanism.\n\n4.4.1 Effect of Model Depth. We vary the depth of KGAT (e.g.,  \\(L\\) ) to investigate the efficiency of usage of multiple embedding propagation layers. In particular, the layer number is searched in the range of  \\(\\{1, 2, 3, 4\\}\\) ; we use KGAT-1 to indicate the model with one layer, and similar notations for others. We summarize the results in Table 3, and have the following observations:\n\n- Increasing the depth of KGAT is capable of boosting the performance substantially. Clearly, KGAT-2 and KGAT-3 achieve consistent improvement over KGAT-1 across all the board. We attribute the improvements to the effective modeling of high-order relation between users, items, and entities, which is carried by the second- and third-order connectivities, respectively.  \n- Further stacking one more layer over KGAT-3, we observe that KGAT-4 only achieve marginal improvements. It suggests that considering third-order relations among entities could be sufficient to capture the collaborative signal, which is consistent to the findings in [14, 33].  \n- Jointly analyzing Tables 2 and 3, KGAT-1 consistently outperforms other baselines in most cases. It again verifies the effectiveness of that attentive embedding propagation, empirically showing that it models the first-order relation better.\n\n4.4.2 Effect of Aggregators. To explore the impact of aggregators, we consider the variants of KGAT-1 that uses different settings - more specifically GCN, GraphSage, and Bi-Interaction (cf. Section 3.1), termed KGAT-1GCN, KGAT-1GraphSage, and KGAT-1Bi, respectively. Table 4 summarizes the experimental results. We have the following findings:\n\n- KGAT-1GCN is consistently superior to KGAT-1GraphSage. One possible reason is that GraphSage forgoes the interaction between the entity representation  \\(\\mathbf{e}_h\\)  and its ego-network representation  \\(\\mathbf{e}_{\\mathcal{N}_h}\\) . It hence illustrates the importance of feature interaction when performing information aggregation and propagation.  \n- Compared to KGAT-1GCN, the performance of KGAT-1Bi verifies that incorporating additional feature interaction can improve the representation learning. It again illustrates the rationality and effectiveness of Bi-Interaction aggregator.\n\n#### 4.4.3 Effect of Knowledge Graph Embedding and Attention\n\nMechanism. To verify the impact of knowledge graph embedding and attention mechanism, we do ablation study by considering three\n\nTable 5: Effect of knowledge graph embedding and attention mechanism.  \n\n<table><tr><td></td><td colspan=\"2\">Amazon-Book</td><td colspan=\"2\">Last-FM</td><td colspan=\"2\">Yelp2018</td></tr><tr><td></td><td>recall</td><td>ndcg</td><td>recall</td><td>ndcg</td><td>recall</td><td>ndcg</td></tr><tr><td>w/o K&amp;A</td><td>0.1367</td><td>0.0928</td><td>0.0819</td><td>0.1252</td><td>0.0654</td><td>0.0808</td></tr><tr><td>w/o KGE</td><td>0.1380</td><td>0.0933</td><td>0.0826</td><td>0.1273</td><td>0.0664</td><td>0.0824</td></tr><tr><td>w/o Att</td><td>0.1377</td><td>0.0930</td><td>0.0826</td><td>0.1270</td><td>0.0657</td><td>0.0815</td></tr></table>\n\n![](images/bd89e469622309d9dc8d0dfe89d3d3990a98ffb4b7f3128d210b5c6657c7afa7.jpg)  \nFigure 4: Real Example from Amazon-Book.\n\nvariants of KGAT-1. In particular, we disable the TransR embedding component (cf. Equation (2)) of KGAT, termed KGAT- \\(1_{\\mathrm{w/o KGE}}\\) ; we disable the attention mechanism (cf. Equation (4)) and set  \\(\\pi(h, r, t)\\)  as  \\(1 / |\\mathcal{N}_h|\\) , termed KGAT- \\(1_{\\mathrm{w/o Att}}\\) . Moreover, we obtain another variant by removing both components, named KGAT- \\(1_{\\mathrm{w/o K&A}}\\) . We summarize the experimental results in Table 5 and have the following findings:\n\n- Removing knowledge graph embedding and attention components degrades the model's performance. KGAT-1w/o K&A consistently underperforms KGAT-1w/o KGE and KGAT-1w/o Att. It makes sense since KGATw/o K&A fails to explicitly model the representation relatedness on the granularity of triplets.  \n- Compared with KGAT-1w/o Att, KGAT-1w/o KGE performs better in most cases. One possible reason is that treating all neighbors equally (i.e., KGAT-1w/o Att) might introduce noises and mislead the embedding propagation process. It verifies the substantial influence of graph attention mechanism.\n\n## 4.5 Case Study (RQ3)\n\nBenefiting from the attention mechanism, we can reason on high-order connectivity to infer the user preferences on the target item, offering explanations. Towards this end, we randomly selected one user  \\(u_{208}\\)  from Amazon-Book, and one relevant item  \\(i_{4293}\\)  (from the test, unseen in the training phase). We extract behavior-based and attribute-based high-order connectivity connecting the user-item pair, based on the attention scores. Figure 4 shows the visualization of high-order connectivity. There are two key observations:\n\n- KGAT captures the behavior-based and attribute-based high-order connectivity, which play a key role to infer user preferences. The retrieved paths can be viewed as the evidence why the item meets the user's preference. As we can see, the connectivity  \\(u_{208} \\xrightarrow{r_0}\\)  Old Man's War  \\(\\xrightarrow{r_{14}}\\)  John Scalzi  \\(\\xrightarrow{-r_{14}} i_{4293}\\)  has the highest attention score, labeled with the solid line in the left subfigure. Hence, we can generate the explanation as The Last Colony is recommended since you have watched Old Man's War written by the same author John Scalzi.\n\n- The quality of item knowledge is of crucial importance. As we can see, entity English with relation Original Language is involved in one path, which is too general to provide high-quality explanations. This inspires us to perform hard attention to filter less informative entities out in future work.\n",
  "hyperparameter": "Embedding size: 64 (16 for RippleNet); Batch size: 1024; Learning rate: searched in {0.05, 0.01, 0.005, 0.001}; L2 regularization coefficient: searched in {10^-5, 10^-4, ..., 10^1, 10^2}; Dropout ratio: searched in {0.0, 0.1, ..., 0.8}; Node dropout ratio: searched in {0.0, 0.1, ..., 0.8}; Number of propagation layers (L): 3 (optimal, searched in {1,2,3,4}); Hidden dimensions for 3 layers: [64, 32, 16]; Optimizer: Adam with Xavier initialization; Early stopping: 50 epochs without improvement on validation recall@20"
}