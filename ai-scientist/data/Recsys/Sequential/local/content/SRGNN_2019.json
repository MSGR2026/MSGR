{
  "id": "SRGNN_2019",
  "paper_title": "Session-based Recommendation with Graph Neural Networks (SR-GNN variant)",
  "alias": "SRGNN",
  "year": 2019,
  "domain": "Recsys",
  "task": "SequentialRecommendation",
  "idea": "SR-GNN models session-based recommendation by converting session sequences into directed graphs where items are nodes and consecutive clicks are edges. It employs gated graph neural networks to learn item embeddings that capture complex item transitions, and generates session representations by combining local embeddings (last-clicked item) with global embeddings (attention-weighted aggregation of all items). This graph-based approach captures richer item relationships and user behavior patterns compared to sequential RNN models, enabling more accurate next-item prediction.",
  "introduction": "# 1 Introduction\n\nWith the rapid growth of the amount of information on the Internet, recommendation systems become fundamental for helping users alleviate the problem of information overload and select interesting information in many Web applications, e.g., search, e-commerce, and media streaming sites. Most of the existing recommendation systems assume that the user profile and past activities are constantly recorded. However, in many services, user identification may be unknown and only the user behavior history during an ongoing session is available. Thereby, it is of great importance to model limited behavior in one session and generate the recommendation accordingly. Conversely, conventional recommendation methods relying on adequate user-item interactions have problems in yielding accurate results under this circumstance.\n\nDue to the highly practical value, increasing research interests in this problem can be observed, and many kinds of proposals for session-based recommendation have been developed. Based on Markov chains, some work (Shani,\n\nBrafman, and Heckerman 2002; Rendle, Freudenthaler, and Schmidt-Thieme 2010) predicts the user's next behavior based on the previous one. With a strong independence assumption, independent combinations of the past components confine the prediction accuracy.\n\nIn recent years, the majority of research (Hidasi et al. 2016a; Tan, Xu, and Liu 2016; Tuan and Phuong 2017; Li et al. 2017a) apply Recurrent Neural Networks (RNNs) for session-based recommendation systems and obtain promising results. The work (Hidasi et al. 2016a) proposes a recurrent neural network approach at first, then the model is enhanced by data augmentation and considering temporal shift of user behavior (Tan, Xu, and Liu 2016). Recently, NARM (Li et al. 2017a) designs a global and local RNN recommender to capture user's sequential behavior and main purposes simultaneously. Similar to NARM, STAMP (Liu et al. 2018) also captures users' general interests and current interests, by employing simple MLP networks and an attentive net.\n\nAlthough the methods above achieve satisfactory results and become the state-of-the-arts, they still have some limitations. Firstly, without adequate user behavior in one session, these methods have difficulty in estimating user representations. Usually, the hidden vectors of these RNN methods are treated as the user representations, such that recommendations can be then generated based on these representations, for instance, the global recommender of NARM. In session-based recommendation systems, however, sessions are mostly anonymous and numerous, and user behavior implicated in session clicks is often limited. It is thus difficult to accurately estimate the representation of each user from each session. Secondly, previous work reveals that patterns of item transitions are important and can be used as a local factor (Li et al. 2017a; Liu et al. 2018) in session-based recommendation, but these methods always model single-way transitions between consecutive items and neglect the transitions among the contexts, i.e. other items in the session. Thus, complex transitions among distant items are often overlooked by these methods.\n\nTo overcome the limitations mentioned above, we propose a novel method for Session-based Recommendation with Graph Neural Networks, SR-GNN for brevity, to explore rich transitions among items and generate accurate latent vectors of items. Graph Neural Networks (GNNs)\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-17/1f8b4305-2550-4a17-962c-237646ab38e5/1c2575d668cf476ec67ed6d81d6bf1990fe40094585c183ad83e79334e588417.jpg)  \nFigure 1: The workflow of the proposed SR-GNN method. We model all session sequences as session graphs. Then, each session graph is proceeded one by one and the resulting node vectors can be obtained through a gated graph neural network. After that, each session is represented as the combination of the global preference and current interests of this session using an attention net. Finally, we predict the probability of each item that will appear to be the next-click one for each session.\n\n(Scarselli et al. 2009; Li et al. 2015) are designed for generating representations for graphs. Recently, it has been employed to model graph-structured dependencies for natural language processing and computer vision applications flourishingly, e.g., script event prediction (Li, Ding, and Liu 2018), situation recognition (Li et al. 2017b), and image classification (Marino, Salakhutdinov, and Gupta 2017). For the session-based recommendation, we first construct directed graphs from historical session sequences. Based on the session graph, GNN is capable of capturing transitions of items and generating accurate item embedding vectors correspondingly, which are difficult to be revealed by the conventional sequential methods, like MC-based and RNN-based methods. Based on accurate item embedding vectors, the proposed SR-GNN constructs more reliable session representations and the next-click item can be inferred.\n\nFigure 1 illustrates the workflow of the proposed SR-GNN method. At first, all session sequences are modeled as directed session graphs, where each session sequence can be treated as a subgraph. Then, each session graph is proceeded successively and the latent vectors for all nodes involved in each graph can be obtained through gated graph neural networks. After that, we represent each session as a composition of the global preference and the current interest of the user in that session, where these global and local session embedding vectors are both composed by the latent vectors of nodes. Finally, for each session, we predict the probability of each item to be the next click. Extensive experiments conducted on real-world representative datasets demonstrate the effectiveness of the proposed method over the state-of-arts. The main contributions of this work are summarized as follows:\n\n- We model separated session sequences into graph-structured data and use graph neural networks to capture complex item transitions. To best of our knowledge, it presents a novel perspective on modeling in the session-based recommendation scenario.  \n- To generate session-based recommendations, we do not rely on user representations, but use the session embedding, which can be obtained merely based on latent vectors of items involved in each single session.\n\n- Extensive experiments conducted on real-world datasets show that SR-GNN evidently outperforms the state-of-art methods.\n\nTo make our results fully reproducible, all the relevant source codes have been made public at https://github.com/CRIPAC-DIG/SR-GNN.\n\nThe rest of this paper is organized as follows. We review prior related literature in Section 2. Section 3 presents the proposed method of session-based recommendation with graph neural networks. Detailed experiment results and analysis are shown in Section 4. Finally, we conclude this paper in Section 5.",
  "method": "# 3 The Proposed Method\n\nIn this section, we introduce the proposed SR-GNN which applies graph neural networks into session-based recommendation. We formulate the problem at first, then explain how to construct the graph from sessions, and finally describe the SR-GNN method thoroughly.\n\n# Notations\n\nSession-based recommendation aims to predict which item a user will click next, solely based on the user's current sequential session data without accessing to the long-term preference profile. Here we give a formulation of this problem as below.\n\nIn session-based recommendation, let  $V = \\{v_{1}, v_{2}, \\ldots, v_{m}\\}$  denote the set consisting of all unique items involved in all the sessions. An anonymous session sequence  $s$  can be represented by a list  $s = [v_{s,1}, v_{s,2}, \\ldots, v_{s,n}]$  ordered by timestamps, where  $v_{s,i} \\in V$  represents a clicked item of the user within the session  $s$ . The goal of the session-based recommendation is to predict the next click, i.e. the sequence label,  $v_{s,n+1}$  for the session  $s$ . Under a session-based recommendation model, for the session  $s$ , we output probabilities  $\\hat{\\mathbf{y}}$  for all possible items, where an element value of vector  $\\hat{\\mathbf{y}}$  is the recommendation score of the corresponding item. The items with top-  $K$  values in  $\\hat{\\mathbf{y}}$  will be the candidate items for recommendation.\n\n# Constructing Session Graphs\n\nEach session sequence  $s$  can be modeled as a directed graph  $\\mathcal{G}_s = (\\mathcal{V}_s, \\mathcal{E}_s)$ . In this session graph, each node represents an item  $v_{s,i} \\in V$ . Each edge  $(v_{s,i-1}, v_{s,i}) \\in \\mathcal{E}_s$  means that a user clicks item  $v_{s,i}$  after  $v_{s,i-1}$  in the session  $s$ . Since several items may appear in the sequence repeatedly, we assign each edge with a normalized weighted, which is calculated as the occurrence of the edge divided by the outdegree of that edge's start node. We embed every item  $v \\in V$  into an unified embedding space and the node vector  $\\mathbf{v} \\in \\mathbb{R}^d$  indicates the latent vector of item  $v$  learned via graph neural networks, where  $d$  is the dimensionality. Based on node vectors, each session  $s$  can be represented by an embedding vector  $\\mathbf{s}$ , which is composed of node vectors used in that graph.\n\n# Learning Item Embeddings on Session Graphs\n\nThen, we present how to obtain latent vectors of nodes via graph neural networks. The vanilla graph neural network is proposed by Scarselli et al. (2009), extending neural network methods for processing the graph-structured data. Li et al. (2015) further introduce gated recurrent units and propose gated GNN. Graph neural networks are well-suited for session-based recommendation, because it can automatically extract features of session graphs with considerations of rich node connections. We first demonstrate the learning process of node vectors in a session graph. Formally, for the node  $v_{s,i}$  of graph  $\\mathcal{G}_s$ , the update functions are given as follows:\n\n$$\n\\mathbf {a} _ {s, i} ^ {t} = \\mathbf {A} _ {s, i:} \\left[ \\mathbf {v} _ {1} ^ {t - 1}, \\dots , \\mathbf {v} _ {n} ^ {t - 1} \\right] ^ {\\top} \\mathbf {H} + \\mathbf {b}, \\tag {1}\n$$\n\n$$\n\\mathbf {z} _ {s, i} ^ {t} = \\sigma \\left(\\mathbf {W} _ {z} \\mathbf {a} _ {s, i} ^ {t} + \\mathbf {U} _ {z} \\mathbf {v} _ {i} ^ {t - 1}\\right), \\tag {2}\n$$\n\n$$\n\\mathbf {r} _ {s, i} ^ {t} = \\sigma \\left(\\mathbf {W} _ {r} \\mathbf {a} _ {s, i} ^ {t} + \\mathbf {U} _ {r} \\mathbf {v} _ {i} ^ {t - 1}\\right), \\tag {3}\n$$\n\n$$\n\\widetilde {\\mathbf {v}} _ {i} ^ {t} = \\tanh  \\left(\\mathbf {W} _ {o} \\mathbf {a} _ {s, i} ^ {t} + \\mathbf {U} _ {o} \\left(\\mathbf {r} _ {s, i} ^ {t} \\odot \\mathbf {v} _ {i} ^ {t - 1}\\right)\\right), \\tag {4}\n$$\n\n$$\n\\mathbf {v} _ {i} ^ {t} = \\left(1 - \\mathbf {z} _ {s, i} ^ {t}\\right) \\odot \\mathbf {v} _ {i} ^ {t - 1} + \\mathbf {z} _ {s, i} ^ {t} \\odot \\widetilde {\\mathbf {v}} _ {i} ^ {t}, \\tag {5}\n$$\n\nwhere  $\\mathbf{H} \\in \\mathbb{R}^{d \\times 2d}$  controls the weight,  $\\mathbf{z}_{s,i}$  and  $\\mathbf{r}_{s,i}$  are the reset and update gates respectively,  $\\left[\\mathbf{v}_1^{t-1}, \\ldots, \\mathbf{v}_n^{t-1}\\right]$  is the list of node vectors in session  $s$ ,  $\\sigma(\\cdot)$  is the sigmoid function, and  $\\odot$  is the element-wise multiplication operator.  $\\mathbf{v}_i \\in \\mathbb{R}^d$  represents the latent vector of node  $v_{s,i}$ . The connection matrix  $\\mathbf{A}_s \\in \\mathbb{R}^{n \\times 2n}$  determines how nodes in the graph communicate with each other and  $\\mathbf{A}_{s,i} \\in \\mathbb{R}^{1 \\times 2n}$  are the two columns of blocks in  $\\mathbf{A}_s$  corresponding to node  $v_{s,i}$ .\n\nHere  $\\mathbf{A}_{\\mathrm{s}}$  is defined as the concatenation of two adjacency matrices  $\\mathbf{A}_s^{\\mathrm{(out)}}$  and  $\\mathbf{A}_s^{\\mathrm{(in)}}$ , which represents weighted connections of outgoing and incoming edges in the session graph respectively. For example, consider a session  $s = [v_{1}, v_{2}, v_{3}, v_{2}, v_{4}]$ , the corresponding graph  $\\mathcal{G}_s$  and the matrix  $\\mathbf{A}_s$  are shown in Figure 2. Please note that SR-GNN can support different connection matrices  $\\mathbf{A}$  for various kinds of constructed session graphs. If different strategies of constructing the session graph are used, the connection matrix  $\\mathbf{A}_s$  will be changed accordingly. Moreover, when there exists content features of node, such as descriptions and categorical information, the method can be further generalized. To be specific, we can concatenate features with node vector to deal with such information.\n\nFor each session graph  $\\mathcal{G}_s$ , the gated graph neural network proceeds nodes at the same time. Eq. (1) is used for information propagation between different nodes, under restrictions given by the matrix  $\\mathbf{A}_s$ . Specifically, it extracts the latent vectors of neighborhoods and feeds them as input into the graph neural network. Then, two gates, i.e. update and reset gate, decide what information to be preserved and discarded respectively. After that, we construct the candidate state by the previous state, the current state, and the reset gate as described in Eq. (4). The final state is then the combination of the previous hidden state and the candidate state, under the control of the update gate. After updating all nodes in session graphs until convergence, we can obtain the final node vectors.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-17/1f8b4305-2550-4a17-962c-237646ab38e5/829238979e4ceac918a6cc88af8bb98c769edb9c67fff2aaa08a7bc01e15d76b.jpg)\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-17/1f8b4305-2550-4a17-962c-237646ab38e5/b627fe2fea58e2333f0e9d591f46a15d19df57ae310f060690e9ab6a9ad56703.jpg)  \nFigure 2: A example of a session graph and the connection matrix  $\\mathbf{A}_s$\n\n# Generating Session Embeddings\n\nPrevious session-based recommendation methods always assume there exists a distinct latent representation of user for each session. On the contrary, the proposed SR-GNN method does not make any assumptions on that vector. Instead, a session is represented directly by nodes involved in that session. To better predict the users' next clicks, we plan to develop a strategy to combine long-term preference and current interests of the session, and use this combined embedding as the session embedding.\n\nAfter feeding all session graphs into the gated graph neural networks, we obtain the vectors of all nodes. Then, to represent each session as an embedding vector  $\\mathbf{s} \\in \\mathbb{R}^d$ , we first consider the local embedding  $\\mathbf{s}_1$  of session  $s$ . For session  $s = [v_{s,1}, v_{s,2}, \\ldots, v_{s,n}]$ , the local embedding can be simply defined as  $\\mathbf{v}_n$  of the last-clicked item  $v_{s,n}$ , i.e.  $\\mathbf{s}_1 = \\mathbf{v}_n$ .\n\nThen, we consider the global embedding  $\\mathbf{s}_{\\mathrm{g}}$  of the session graph  $\\mathcal{G}_s$  by aggregating all node vectors. Consider information in these embedding may have different levels of priority, we further adopt the soft-attention mechanism to better represent the global session preference:\n\n$$\n\\alpha_ {i} = \\mathbf {q} ^ {\\top} \\sigma (\\mathbf {W} _ {1} \\mathbf {v} _ {n} + \\mathbf {W} _ {2} \\mathbf {v} _ {i} + \\mathbf {c}),\n$$\n\n$$\n\\mathbf {s} _ {\\mathrm {g}} = \\sum_ {i = 1} ^ {n} \\alpha_ {i} \\mathbf {v} _ {i}, \\tag {6}\n$$\n\nwhere parameters  $\\mathbf{q} \\in \\mathbb{R}^d$  and  $\\mathbf{W}_1, \\mathbf{W}_2 \\in \\mathbb{R}^{d \\times d}$  control the weights of item embedding vectors.\n\nFinally, we compute the hybrid embedding  $\\mathbf{s_h}$  by taking linear transformation over the concatenation of the local and global embedding vectors:\n\n$$\n\\mathbf {s} _ {\\mathrm {h}} = \\mathbf {W} _ {3} \\left[ \\mathbf {s} _ {\\mathrm {l}}; \\mathbf {s} _ {\\mathrm {g}} \\right], \\tag {7}\n$$\n\nwhere matrix  $\\mathbf{W}_3\\in \\mathbb{R}^{d\\times 2d}$  compresses two combined embedding vectors into the latent space  $\\mathbb{R}^d$\n\n# Making Recommendation and Model Training\n\nAfter obtained the embedding of each session, we compute the score  $\\hat{\\mathbf{z}}_i$  for each candidate item  $v_{i}\\in V$  by multiplying\n\nTable 1: Statistics of datasets used in the experiments  \n\n<table><tr><td>Statistics</td><td>Yoochoose 1/64</td><td>Yoochoose 1/4</td><td>Diginetica</td></tr><tr><td># of clicks</td><td>557,248</td><td>8,326,407</td><td>982,961</td></tr><tr><td># of training sessions</td><td>369,859</td><td>5,917,745</td><td>719,470</td></tr><tr><td># of test sessions</td><td>55,898</td><td>55,898</td><td>60,858</td></tr><tr><td># of items</td><td>16,766</td><td>29,618</td><td>43,097</td></tr><tr><td>Average length</td><td>6.16</td><td>5.71</td><td>5.12</td></tr></table>\n\nits embedding  $\\mathbf{v}_i$  by session representation  $\\mathbf{s_h}$ , which can be defined as:\n\n$$\n\\mathbf {\\hat {z}} _ {i} = \\mathbf {s} _ {\\mathrm {h}} ^ {\\top} \\mathbf {v} _ {i}. \\tag {8}\n$$\n\nThen we apply a softmax function to get the output vector of the model  $\\hat{\\mathbf{y}}$ :\n\n$$\n\\hat {\\mathbf {y}} = \\operatorname {s o f t m a x} (\\hat {\\mathbf {z}}), \\tag {9}\n$$\n\nwhere  $\\hat{\\mathbf{z}}\\in \\mathbb{R}^m$  denotes the recommendation scores over all candidate items and  $\\hat{\\mathbf{y}}\\in \\mathbb{R}^m$  denotes the probabilities of nodes appearing to be the next click in session  $s$ .\n\nFor each session graph, the loss function is defined as the cross-entropy of the prediction and the ground truth. It can be written as follows:\n\n$$\n\\mathcal {L} (\\hat {\\mathbf {y}}) = - \\sum_ {i = 1} ^ {m} \\mathbf {y} _ {i} \\log \\left(\\hat {\\mathbf {y}} _ {i}\\right) + (1 - \\mathbf {y} _ {i}) \\log \\left(1 - \\hat {\\mathbf {y}} _ {i}\\right), \\tag {10}\n$$\n\nwhere  $\\mathbf{y}$  denotes the one-hot encoding vector of the ground truth item.\n\nFinally, we use the Back-Propagation Through Time (BPTT) algorithm to train the proposed SR-GNN model. Note that in session-based recommendation scenarios, most sessions are of relatively short lengths. Therefore, it is suggested to choose a relatively small number of training steps to prevent overfitting.",
  "experiments": "# 4 Experiments and Analysis\n\nIn this section, we first describe the datasets, compared methods, and evaluation metrics used in the experiments. Then, we compare the proposed SR-GNN with other comparative methods. Finally, we make detailed analysis of SR-GNN under different experimental settings.\n\n# Datasets\n\nWe evaluate the proposed method on two real-world representative datasets, i.e. Yoochoose<sup>1</sup> and Diginetica<sup>2</sup>. The Yoochoose dataset is obtained from the RecSys Challenge 2015, which contains a stream of user clicks on an e-commerce website within 6 months. The Diginetica dataset comes from CIKM Cup 2016, where only its transactional data is used.\n\nFor fair comparison, following (Li et al. 2017a; Liu et al. 2018), we filter out all sessions of length 1 and items appearing less than 5 times in both datasets. The remaining 7,981,580 sessions and 37,483 items constitute the Yoochoose dataset, while 204,771 sessions and 43097 items construct the Diginetica dataset. Furthermore, similar to\n\n(Tan, Xu, and Liu 2016), we generate sequences and corresponding labels by splitting the input sequence. To be specific, we set the sessions of subsequent days as the test set for Yoochoose, and the sessions of subsequent weeks as the test set for Diginetiva. For example, for an input session  $s = [v_{s,1}, v_{s,2}, \\ldots, v_{s,n}]$ , we generate a series of sequences and labels  $([v_{s,1}], v_{s,2}), ([v_{s,1}, v_{s,2}], v_{s,3}), \\ldots, ([v_{s,1}, v_{s,2}, \\ldots, v_{s,n-1}], v_{s,n})$ , where  $[v_{s,1}, v_{s,2}, \\ldots, v_{s,n-1}]$  is the generated sequence and  $v_{s,n}$  denotes the next-clicked item, i.e. the label of the sequence. Following (Li et al. 2017a; Liu et al. 2018), we also use the most recent fractions 1/64 and 1/4 of the training sequences of Yoochoose. The statistics of datasets are summarized in Table 1.\n\n# Baseline Algorithms\n\nTo evaluate the performance of the proposed method, we compare it with the following representative baselines:\n\n- POP and S-POP recommend the top- $N$  frequent items in the training set and in the current session respectively.  \n- Item-KNN (Sarwar et al. 2001) recommends items similar to the previously clicked item in the session, where similarity is defined as the cosine similarity between the vector of sessions.  \n- BPR-MF (Rendle et al. 2009) optimizes a pairwise ranking objective function via stochastic gradient descent.  \n- FPMC (Rendle, Freudenthaler, and Schmidt-Thieme 2010) is a sequential prediction method based on markov chain.  \n- GRU4REC (Hidasi et al. 2016a) uses RNNs to model user sequences for the session-based recommendation.  \n- NARM (Li et al. 2017a) employs RNNs with attention mechanism to capture the user's main purpose and sequential behavior.  \n- STAMP (Liu et al. 2018) captures users' general interests of the current session and current interests of the last click.\n\n# Evaluation Metrics\n\nFollowing metrics are used to evaluate compared methods.\n\n$\\mathbf{P}@\\mathbf{20}$  (Precision) is widely used as a measure of predictive accuracy. It represents the proportion of correctly recommended items amongst the top-20 items.\n\nMRR@20 (Mean Reciprocal Rank) is the average of reciprocal ranks of the correctly-recommended items. The reciprocal rank is set to 0 when the rank exceeds 20. The MRR measure considers the order of recommendation ranking, where large MRR value indicates that correct recommendations in the top of the ranking list.\n\n# Parameter Setup\n\nFollowing previous methods (Li et al. 2017a; Liu et al. 2018), we set the dimensionality of latent vectors  $d = 100$  for both datasets. Besides, we select other hyper-parameters on a validation set which is a random  $10\\%$  subset of the training set. All parameters are initialized using a Gaussian distribution with a mean of 0 and a standard deviation of 0.1. The mini-batch Adam optimizer is exerted to optimize these\n\nTable 2: The performance of SR-GNN with other baseline methods over three datasets  \n\n<table><tr><td rowspan=\"2\">Method</td><td colspan=\"2\">Yoochoose 1/64</td><td colspan=\"2\">Yoochoose 1/4</td><td colspan=\"2\">Diginetica</td></tr><tr><td>P@20</td><td>MRR@20</td><td>P@20</td><td>MRR@20</td><td>P@20</td><td>MRR@20</td></tr><tr><td>POP</td><td>6.71</td><td>1.65</td><td>1.33</td><td>0.30</td><td>0.89</td><td>0.20</td></tr><tr><td>S-POP</td><td>30.44</td><td>18.35</td><td>27.08</td><td>17.75</td><td>21.06</td><td>13.68</td></tr><tr><td>Item-KNN</td><td>51.60</td><td>21.81</td><td>52.31</td><td>21.70</td><td>35.75</td><td>11.57</td></tr><tr><td>BPR-MF</td><td>31.31</td><td>12.08</td><td>3.40</td><td>1.57</td><td>5.24</td><td>1.98</td></tr><tr><td>FPMC</td><td>45.62</td><td>15.01</td><td>-</td><td>-</td><td>26.53</td><td>6.95</td></tr><tr><td>GRU4REC</td><td>60.64</td><td>22.89</td><td>59.53</td><td>22.60</td><td>29.45</td><td>8.33</td></tr><tr><td>NARM</td><td>68.32</td><td>28.63</td><td>69.73</td><td>29.23</td><td>49.70</td><td>16.17</td></tr><tr><td>STAMP</td><td>68.74</td><td>29.67</td><td>70.44</td><td>30.00</td><td>45.64</td><td>14.32</td></tr><tr><td>SR-GNN</td><td>70.57</td><td>30.94</td><td>71.36</td><td>31.89</td><td>50.73</td><td>17.59</td></tr></table>\n\nparameters, where the initial learning rate is set to 0.001 and will decay by 0.1 after every 3 epochs. Moreover, the batch size and the L2 penalty is set to 100 and  $10^{-5}$  respectively.\n\n# Comparison with Baseline Methods\n\nTo demonstrate the overall performance of the proposed model, we compare it with other state-of-art session-based recommendation methods. The overall performance in terms of  $\\mathrm{P@20}$  and MRR@20 is shown in Table 2, with the best results highlighted in boldface. Please note that, as in (Li et al. 2017a), due to insufficient memory to initialize FPMC, the performance on Yoochoose  $1/4$  is not reported.\n\nSR-GNN aggregates separated session sequences into graph-structured data. In this model, we jointly consider the global session preference as well as the local interests. According to the experiments, it is obvious that the proposed SR-GNN method achieves the best performance on all three datasets in terms of  $\\mathrm{P@20}$  and MRR@20. This verifies the effectiveness of the proposed method.\n\nRegarding those traditional algorithms like POP and S-POP, their performance is relatively poor. Such simple models make recommendations solely based on repetitive co-occurred items or successive items, which is problematic in session-based recommendation scenarios. Even so, S-POP still outperforms its opponents such as POP, BPR-MF, and FPMC, demonstrating the importance of session contextual information. Item-KNN achieves better results than FPMC which is based on Markov chains. Please note that, Item-KNN only utilizes the similarity between items without considering sequential information. This indicates that the assumption on the independence of successive items, which traditional MC-based methods mostly rely on, is not realistic.\n\nNeural-network-based methods, such as NARM and STAMP, outperform the conventional methods, demonstrating the power of adopting deep learning in this domain. Short/long-term memory models, like GRU4REC and NARM, use recurrent units to capture a user's general interest while STAMP improves the short-term memory by utilizing the last-clicked item. Those methods explicitly model the users' global behavioral preferences and consider transitions between users' previous actions and the next click, leading to superior performance against these traditional methods. However, their performance is still inferior to that of the proposed method. Compared with the state-of-art\n\nmethods like NARM and STAMP, SR-GNN further considers transitions between items in a session and thereby models every session as a graph, which can capture more complex and implicit connections between user clicks. Whereas in NARM and GRU4REC, they explicitly model each user and obtain the user representations through separated session sequences, with possible interactive relationships between items ignored. Therefore, the proposed model is more powerful to model session behavior.\n\nBesides, SR-GNN adopts the soft-attention mechanism to generate a session representation which can automatically select the most significant item transitions, and neglect noisy and ineffective user actions in the current session. On the contrary, STAMP only uses the transition between the last-clicked item and previous actions, which may not be sufficient. Other RNN models, such as GRU4REC and NARM, fail to select impactful information during the propagation process as well. They use all previous items to obtain a vector representing the user's general interest. When a user's behavior is aimless, or his interests drift quickly in the current session, conventional models are ineffective to cope with noisy sessions.\n\n# Comparison with Variants of Connection Schemes\n\nThe proposed SR-GNN method is flexible in constructing connecting relationships between items in the graph. Since user behavior in sessions is limited, we propose in this section another two connection variants in order to augment limited relationships between items in each session graph. Firstly, we aggregate all session sequences together and model them as a directed whole item graph, which is termed as the global graph hereafter. In the global graph, each node denotes a unique item, and each edge denotes a directed transition from one item to another. Secondly, we model all high-order relationships between items within one session as direct connections explicitly. In summary, the following two connection schemes are proposed to compare with SR-GNN:\n\n- SR-GNN with normalized global connections (SR-GNN-NGC) replaces the connection matrix with edge weights extracted from the global graph on the basis of SR-GNN.  \n- SR-GNN with full connections (SR-GNN-FC) represents all higher-order relationships using boolean weights and appends its corresponding connection matrix to that of SR-GNN.\n\nThe results of different connection schemes are shown in Figure 3. From the figures, it is seen that all three connection schemes achieve better or almost the same performance as the state-of-the-art STAMP and NARM methods, confirming the usefulness of modeling sessions as graphs.\n\nCompared with SR-GNN, for each session, SR-GNN-NGC takes the impact of other sessions into considerations in addition to items in the current session, which subsequently reduces the influence of edges that are connected to nodes with high degree within the current session graph. Such a fusion method notably affects the integrity of the current session, especially when the weight of the edge in the graph varies, leading to performance downgrade.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-17/1f8b4305-2550-4a17-962c-237646ab38e5/3084f9150781e84ee00b98b71963fa66344026947b1f75a60c793f73f681b399.jpg)  \nFigure 3: The performance of different connection schemes\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-17/1f8b4305-2550-4a17-962c-237646ab38e5/1844468a705171605a075ddd5a03dfc5d44cb765144643d207cd6f75ae4cc4b0.jpg)\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-17/1f8b4305-2550-4a17-962c-237646ab38e5/cbfc6efd6afb2e08c8823deb81f2243a1e31cf861a14593aafe38a0f266efb12.jpg)  \nFigure 4: The performance of different session representations\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-17/1f8b4305-2550-4a17-962c-237646ab38e5/3a7e38021f1ff8adbb85f53cfa983531e80743e527f7895d2628ce30f6a1edbc.jpg)\n\nIn regard to SR-GNN and SR-GNN-FC, the former one only models the exact relationship between consecutive items, and the latter one further explicitly regards all high-order relationships as direct connections. It is reported that SR-GNN-FC performs worse than SR-GNN, though the experimental results of the two methods are not of much difference. Such a small difference in results suggests that in most recommendation scenarios, not every high-order transitions can be directly converted to straight connections and intermediate stages between high-order items are still necessities. For instance, considering that the user has viewed the following pages when browsing a website:  $A\\to B\\to C$  it is not appropriate to recommend page  $C$  directly after  $A$  without intermediate page  $B$  due to the lack of a direct connection between  $A$  and  $C$\n\n# Comparison with Different Session Embeddings\n\nWe compare the session embedding strategy with the following three approaches: (1) local embedding only (SR-GNN-L), (2) global embedding with average pooling (SR-GNN-AVG), and (3) global embedding with the attention mechanism (SR-GNN-ATT). The results of methods with three different embedding strategies are given in Figure 4.\n\nFrom the figures, it can be observed that the hybrid embedding method SR-GNN achieves best results on all three datasets, which validates the importance of explicitly incorporating current session interests with the long-term preference. Furthermore, the figures show that SR-GNN-ATT performs better than SR-GNN-AVG with average pooling on three datasets. It indicates that the session may contain some noisy behavior, which cannot be treated independently. Besides, it is shown that attention mechanisms are helpful in extracting the significant behavior from the session data to\n\nconstruct the long-term preference.\n\nPlease note that SR-GNN-L, a downgraded version of SR-GNN, still outperforms SR-GNN-AVG and achieves almost the same performance as that of SR-GNN-ATT, supporting that both the current interest and long-term preference are crucial for session-based recommendation.\n\n# Analysis on Session Sequence Lengths\n\nWe further analyze the capability of different models to cope with sessions of different lengths. For comparison, we partition sessions of Yoochoose 1/64 and Diginetica into two groups, where \"Short\" indicates that the length of sessions is less than or equal to 5, while each session has more than 5 items in \"Long\". The pivot value 5 is chosen because it is the closest integer to the average length of total sessions in all datasets. The percentages of session belonging to short group and long group are 0.701 and 0.299 on the Yoochoose data, and 0.764 and 0.236 on the Diginetica data. For each method, we report the results evaluated in terms of P@20 in Table 3.\n\nOur proposed SR-GNN and its variants perform stably on two datasets with different session lengths. It demonstrates the superior performance of the proposed method and the adaptability of graph neural networks in session-based recommendation. On the contrary, the performance of STAMP changes greatly in short and long groups. STAMP (Liu et al. 2018) explains such a difference according to replicated actions. It adopts the attention mechanism, so replicated items can be ignored when obtaining user representations. Similar to STAMP, on Yoochoose, NARM achieves good performance on the short group, but the performance drops quickly with the length of the sessions increasing, which is partially because RNN models have difficulty in coping with long sequences.\n\nThen we analyze the performance of SR-GNN-L, SR-GNN-ATT, and SR-GNN with different session representations. These three methods achieve promising results comparing with STAMP and NARM. It is probably because that based on the learning framework of graph neural networks, our methods can attain more accurate node vectors. Such node embedding not only captures the latent features of nodes but also models the node connections globally. On such basis, the performance is stable among variants of SR-GNN, while the performance of two state-of-art methods fluctuate considerably on short and long datasets. Moreover, the table shows that SR-GNN-L can also achieve good results, although this variant only uses local session embedding vectors. It is maybe because that SR-GNN-L also implicitly considers the properties of the first-order and higher-order nodes in session graphs. Such results are also validated by Figure 4, where both SR-GNN-L and SR-GNN-ATT achieve the close-to-optimal performance.",
  "hyperparameter": "Embedding dimensionality d=100; Initial learning rate=0.001 with decay factor 0.1 every 3 epochs; Batch size=100; L2 regularization penalty=10^-5; Parameters initialized with Gaussian distribution (mean=0, std=0.1); Mini-batch Adam optimizer; Edge weights normalized by outdegree of start node; Validation set is 10% random subset of training data; Relatively small number of training steps recommended to prevent overfitting due to short session lengths"
}