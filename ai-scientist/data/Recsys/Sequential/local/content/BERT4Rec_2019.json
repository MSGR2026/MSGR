{
  "id": "BERT4Rec_2019",
  "paper_title": "BERT4Rec: Sequential Recommendation with Bidirectional Encoder Representations from Transformers",
  "alias": "BERT4Rec",
  "year": 2019,
  "domain": "Recsys",
  "task": "SequentialRecommendation",
  "idea": "BERT4Rec applies bidirectional self-attention (Transformer) to sequential recommendation, enabling the model to learn representations by attending to both left and right context in user behavior sequences. Unlike left-to-right unidirectional models (e.g., SASRec), it uses a Cloze task (masked item prediction) during training where a proportion ρ of items are randomly masked and predicted based on surrounding context. This bidirectional modeling combined with the Cloze objective allows the model to capture more complex item transition patterns and generate more training samples, significantly improving recommendation performance.",
  "introduction": "# 1 INTRODUCTION\n\nAccurately characterizing users' interests lives at the heart of an effective recommendation system. In many real-world applications,\n\nPermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org.\n\nCIKM '19, November 3-7, 2019, Beijing, China\n\n© 2019 Copyright held by the owner/author(s). Publication rights licensed to ACM.\n\nACM ISBN 978-1-4503-6976-3/19/11...$15.00\n\nhttps://doi.org/10.1145/3357384.3357895\n\nusers' current interests are intrinsically dynamic and evolving, influenced by their historical behaviors. For example, one may purchase accessories (e.g., Joy-Con controllers) soon after buying a Nintendo Switch, though she/he will not buy console accessories under normal circumstances.\n\nTo model such sequential dynamics in user behaviors, various methods have been proposed to make sequential recommendations based on users' historical interactions [15, 22, 40]. They aim to predict the successive item(s) that a user is likely to interact with given her/his past interactions. Recently, a surge of works employ sequential neural networks, e.g., Recurrent Neural Network (RNN), for sequential recommendation and obtain promising results [7, 14, 15, 56, 58]. The basic paradigm of previous work is to encode a user's historical interactions into a vector (i.e., representation of user's preference) using a left-to-right sequential model and make recommendations based on this hidden representation.\n\nDespite their prevalence and effectiveness, we argue that such left-to-right unidirectional models are not sufficient to learn optimal representations for user behavior sequences. The major limitation, as illustrated in Figure 1c and 1d, is that such unidirectional models restrict the power of hidden representation for items in the historical sequences, where each item can only encode the information from previous items. Another limitation is that previous unidirectional models are originally introduced for sequential data with natural order, e.g., text and time series data. They often assume a rigidly ordered sequence over data which is not always true for user behaviors in real-world applications. In fact, the choices of items in a user's historical interactions may not follow a rigid order assumption [18, 54] due to various unobservable external factors [5]. In such a situation, it is crucial to incorporate context from both directions in user behavior sequence modeling.\n\nTo address the limitations mentioned above, we seek to use a bidirectional model to learn the representations for users' historical behavior sequences. Specifically, inspired by the success of BERT [6] in text understanding, we propose to apply the deep bidirectional self-attention model to sequential recommendation, as illustrated in Figure 1b. For representation power, the superior results for deep bidirectional models on text sequence modeling tasks show that it is beneficial to incorporate context from both sides for sequence representations learning [6]. For rigid order assumption, our model is more suitable than unidirectional models in modeling user behavior sequences since all items in the bidirectional model can leverage the contexts from both left and right side.\n\nHowever, it is not straightforward and intuitive to train the bidirectional model for sequential recommendation. Conventional sequential recommendation models are usually trained left-to-right by predicting the next item for each position in the input sequence. As shown in Figure 1, jointly conditioning on both left and right\n\ncontext in a deep bidirectional model would cause information leakage, i.e., allowing each item to indirectly \"see the target item\". This could make predicting the future become trivial and the network would not learn anything useful.\n\nTo tackle this problem, we introduce the Cloze task [6, 50] to take the place of the objective in unidirectional models (i.e., sequentially predicting the next item). Specifically, we randomly mask some items (i.e., replace them with a special token [mask]) in the input sequences, and then predict the ids of those masked items based on their surrounding context. In this way, we avoid the information leakage and learn a bidirectional representation model by allowing the representation of each item in the input sequence to fuse both the left and right context. In addition to training a bidirectional model, another advantage of the Cloze objective is that it can produce more samples to train a more powerful model in multiple epochs. However, a downside of the Cloze task is that it is not consistent with the final task (i.e., sequential recommendation). To fix this, during the test, we append the special token \"[mask]\" at the end of the input sequence to indicate the item that we need to predict, and then make recommendations base on its final hidden vector. Extensive experiments on four datasets show that our model outperforms various state-of-the-art baselines consistently.\n\nThe contributions of our paper are as follows:\n\n- We propose to model user behavior sequences with a bidirectional self-attention network through Cloze task. To the best of our knowledge, this is the first study to introduce deep bidirectional sequential model and Cloze objective into the field of recommendation systems.  \n- We compare our model with state-of-the-art methods and demonstrate the effectiveness of both bidirectional architecture and the Cloze objective through quantitative analysis on four benchmark datasets.  \n- We conduct a comprehensive ablation study to analyze the contributions of key components in the proposed model.\n",
  "method": "# 3 BERT4REC\n\nBefore going into the details, we first introduce the research problem, the basic concepts, and the notations in this paper.\n\n## 3.1 Problem Statement\n\nIn sequential recommendation, let  \\(\\mathcal{U} = \\{u_1, u_2, \\dots, u_{|\\mathcal{U}|}\\}\\)  denote a set of users,  \\(\\mathcal{V} = \\{v_1, v_2, \\dots, v_{|\\mathcal{V}|}\\}\\)  be a set of items, and list  \\(S_u = [v_1^{(u)}, \\dots, v_t^{(u)}, \\dots, v_{n_u}^{(u)}]\\)  denote the interaction sequence in chronological order for user  \\(u \\in \\mathcal{U}\\) , where  \\(v_t^{(u)} \\in \\mathcal{V}\\)  is the item that  \\(u\\)  has interacted with at time step  \\(t\\)  and  \\(n_u\\)  is the length of interaction sequence for user  \\(u\\) . Given the interaction history  \\(S_u\\) , sequential recommendation aims to predict the item that user  \\(u\\)  will interact with at time step  \\(n_u + 1\\) . It can be formalized as modeling the probability over all possible items for user  \\(u\\)  at time step  \\(n_u + 1\\) :\n\n\\[\np \\left(v _ {n _ {u} + 1} ^ {(u)} = v \\mid S _ {u}\\right)\n\\]\n\n## 3.2 Model Architecture\n\nHere, we introduce a new sequential recommendation model called BERT4Rec, which adopts Bidirectional Encoder Representations from Transformers to a new task, sequential Recommendation. It is built upon the popular self-attention layer, \"Transformer layer\".\n\nAs illustrated in Figure 1b, BERT4Rec is stacked by  \\(L\\)  bidirectional Transformer layers. At each layer, it iteratively revises the\n\nrepresentation of every position by exchanging information across all positions at the previous layer in parallel with the Transformer layer. Instead of learning to pass relevant information forward step by step as RNN based methods did in Figure 1d, self-attention mechanism endows BERT4Rec with the capability to directly capture the dependencies in any distances. This mechanism results in a global receptive field, while CNN based methods like Caser usually have a limited receptive field. In addition, in contrast to RNN based methods, self-attention is straightforward to parallelize.\n\nComparing Figure 1b, 1c, and 1d, the most noticeable difference is that SASRec and RNN based methods are all left-to-right unidirectional architecture, while our BERT4Rec uses bidirectional self-attention to model users' behavior sequences. In this way, our proposed model can obtain more powerful representations of users' behavior sequences to improve recommendation performances.\n\n### 3.3 Transformer Layer\n\nAs illustrated in Figure 1b, given an input sequence of length  \\(t\\) , we iteratively compute hidden representations  \\(\\pmb{h}_i^l\\)  at each layer  \\(l\\)  for each position  \\(i\\)  simultaneously by applying the Transformer layer from [52]. Here, we stack  \\(\\pmb{h}_i^l \\in \\mathbb{R}^d\\)  together into matrix  \\(H^{l} \\in \\mathbb{R}^{t \\times d}\\)  since we compute attention function on all positions simultaneously in practice. As shown in Figure 1a, the Transformer layer Trm contains two sub-layers, a Multi-Head Self-Attention sub-layer and a Position-wise Feed-Forward Network.\n\nMulti-Head Self-Attention. Attention mechanisms have become an integral part of sequence modeling in a variety of tasks, allowing capturing the dependencies between representation pairs without regard to their distance in the sequences. Previous work has shown that it is beneficial to jointly attend to information from different representation subspaces at different positions [6, 29, 52]. Thus, we here adopt the multi-head self-attention instead of performing a single attention function. Specifically, multi-head attention first linearly projects  \\(H^{l}\\)  into  \\(h\\)  subspaces, with different, learnable linear projections, and then apply  \\(h\\)  attention functions\n\nin parallel to produce the output representations which are concatenated and once again projected:\n\n\\[\n\\mathrm {M H} \\left(\\boldsymbol {H} ^ {l}\\right) = \\left[ \\text {h e a d} _ {1}; \\text {h e a d} _ {2}; \\dots ; \\text {h e a d} _ {h} \\right] \\boldsymbol {W} ^ {O} \\tag {1}\n\\]\n\n\\[\n\\operatorname {h e a d} _ {i} = \\operatorname {A t t e n t i o n} \\left(\\boldsymbol {H} ^ {l} \\boldsymbol {W} _ {i} ^ {Q}, \\boldsymbol {H} ^ {l} \\boldsymbol {W} _ {i} ^ {K}, \\boldsymbol {H} ^ {l} \\boldsymbol {W} _ {i} ^ {V}\\right)\n\\]\n\nwhere the projections matrices for each head  \\(W_{i}^{Q}\\in \\mathbb{R}^{d\\times d / h},W_{i}^{K}\\in\\) \\(\\mathbb{R}^{d\\times d / h},W_{i}^{V}\\in \\mathbb{R}^{d\\times d / h}\\)  , and  \\(W_{i}^{O}\\in \\mathbb{R}^{d\\times d}\\)  are learnable parameters. Here, we omit the layer subscript  \\(l\\)  for the sake of simplicity. In fact, these projection parameters are not shared across the layers. Here, the Attention function is Scaled Dot-Product Attention:\n\n\\[\n\\operatorname {A t t e n t i o n} (Q, K, V) = \\operatorname {s o f t m a x} \\left(\\frac {Q K ^ {\\top}}{\\sqrt {d / h}}\\right) V \\tag {2}\n\\]\n\nwhere query  \\(Q\\) ,  \\(\\text{key } K\\) , and value  \\(V\\)  are projected from the same matrix  \\(H^l\\)  with different learned projection matrices as in Equation 1. The temperature  \\(\\sqrt{d / h}\\)  is introduced to produce a softer attention distribution for avoiding extremely small gradients [16, 52].\n\nPosition-wise Feed-Forward Network. As described above, the self-attention sub-layer is mainly based on linear projections. To endow the model with nonlinearity and interactions between different dimensions, we apply a Position-wise Feed-Forward Network to the outputs of the self-attention sub-layer, separately and identically at each position. It consists of two affine transformations with a Gaussian Error Linear Unit (GELU) activation in between:\n\n\\[\n\\operatorname {P F F N} \\left(\\boldsymbol {H} ^ {l}\\right) = \\left[ \\operatorname {F F N} \\left(\\boldsymbol {h} _ {1} ^ {l}\\right) ^ {\\top}; \\dots ; \\operatorname {F F N} \\left(\\boldsymbol {h} _ {t} ^ {l}\\right) ^ {\\top} \\right] ^ {\\top}\n\\]\n\n\\[\n\\mathsf {F F N} (\\boldsymbol {x}) = \\mathsf {G E L U} \\left(\\boldsymbol {x} \\boldsymbol {W} ^ {(1)} + \\boldsymbol {b} ^ {(1)}\\right) \\boldsymbol {W} ^ {(2)} + \\boldsymbol {b} ^ {(2)} \\tag {3}\n\\]\n\n\\[\n\\operatorname {G E L U} (x) = x \\Phi (x)\n\\]\n\nwhere  \\(\\Phi(x)\\)  is the cumulative distribution function of the standard gaussian distribution,  \\(W^{(1)} \\in \\mathbb{R}^{d \\times 4d}\\) ,  \\(W^{(2)} \\in \\mathbb{R}^{4d \\times d}\\) ,  \\(b^{(1)} \\in \\mathbb{R}^{4d}\\)  and  \\(b^{(2)} \\in \\mathbb{R}^d\\)  are learnable parameters and shared across all positions. We omit the layer subscript  \\(l\\)  for convenience. In fact, these parameters are different from layer to layer. In this work, following OpenAI GPT [38] and BERT [6], we use a smoother GELU [13] activation rather than the standard ReLu activation.\n\nStacking Transformer Layer. As elaborated above, we can easily capture item-item interactions across the entire user behavior sequence using self-attention mechanism. Nevertheless, it is usually beneficial to learn more complex item transition patterns by stacking the self-attention layers. However, the network becomes more difficult to train as it goes deeper. Therefore, we employ a residual connection [9] around each of the two sublayers as in Figure 1a, followed by layer normalization [1]. Moreover, we also apply dropout [47] to the output of each sub-layer, before it is normalized. That is, the output of each sub-layer is  \\(\\mathrm{LN}(\\pmb{x} + \\mathrm{Dropout}(\\mathrm{sublayer}(\\pmb{x})))\\) , where  \\(\\mathrm{sublayer}(\\cdot)\\)  is the function implemented by the sub-layer itself, LN is the layer normalization function defined in [1]. We use LN to normalize the inputs over all the hidden units in the same layer for stabilizing and accelerating the network training.\n\nIn summary, BERT4Rec refines the hidden representations of each layer as follows:\n\n\\[\n\\boldsymbol {H} ^ {l} = \\operatorname {T r m} \\left(\\boldsymbol {H} ^ {l - 1}\\right), \\quad \\forall i \\in [ 1, \\dots , L ] \\tag {4}\n\\]\n\n\\[\n\\operatorname {T r m} \\left(\\boldsymbol {H} ^ {l - 1}\\right) = \\operatorname {L N} \\left(\\boldsymbol {A} ^ {l - 1} + \\operatorname {D r o p o u t} \\left(\\operatorname {P F F N} \\left(\\boldsymbol {A} ^ {l - 1}\\right)\\right)\\right) \\tag {5}\n\\]\n\n\\[\n\\boldsymbol {A} ^ {l - 1} = \\mathsf {L N} \\left(\\boldsymbol {H} ^ {l - 1} + \\operatorname {D r o p o u t} \\left(\\mathsf {M H} \\left(\\boldsymbol {H} ^ {l - 1}\\right)\\right)\\right) \\tag {6}\n\\]\n\n### 3.4 Embedding Layer\n\nAs elaborated above, without any recurrence or convolution module, the Transformer layer  \\(\\mathsf{Trm}\\)  is not aware of the order of the input sequence. In order to make use of the sequential information of the input, we inject Positional Embeddings into the input item embeddings at the bottoms of the Transformer layer stacks. For a given item  \\(v_{i}\\) , its input representation  \\(\\pmb{h}_i^0\\)  is constructed by summing the corresponding item and positional embedding:\n\n\\[\n\\boldsymbol {h} _ {i} ^ {0} = \\boldsymbol {v} _ {i} + \\boldsymbol {p} _ {i}\n\\]\n\nwhere  \\(\\pmb{v}_i\\in E\\)  is the  \\(d\\) -dimensional embedding for item  \\(v_{i}\\) ,  \\(\\pmb{p}_i\\in P\\)  is the  \\(d\\) -dimensional positional embedding for position index  \\(i\\) . In this work, we use the learnable positional embeddings instead of the fixed sinusoid embeddings in [52] for better performances. The positional embedding matrix  \\(P\\in \\mathbb{R}^{N\\times d}\\)  allows our model to identify which portion of the input it is dealing with. However, it also imposes a restriction on the maximum sentence length  \\(N\\)  that our model can handle. Thus, we need to truncate the the input sequence  \\([v_1,\\dots ,v_t]\\)  to the last  \\(N\\)  items  \\([v_{t - N + 1}^u,\\dots ,v_t]\\)  if  \\(t > N\\) .\n\n### 3.5 Output Layer\n\nAfter  \\(L\\)  layers that hierarchically exchange information across all positions in the previous layer, we get the final output  \\(\\pmb{H}^{L}\\)  for all items of the input sequence. Assuming that we mask the item  \\(\\upsilon_{t}\\)  at time step  \\(t\\) , we then predict the masked items  \\(\\upsilon_{t}\\)  base on  \\(\\pmb{h}_{t}^{L}\\)  as shown in Figure 1b. Specifically, we apply a two-layer feed-forward network with GELU activation in between to produce an output distribution over target items:\n\n\\[\nP (v) = \\operatorname {s o f t m a x} \\left(\\operatorname {G E L U} \\left(\\boldsymbol {h} _ {t} ^ {L} \\boldsymbol {W} ^ {P} + \\boldsymbol {b} ^ {P}\\right) \\boldsymbol {E} ^ {\\top} + \\boldsymbol {b} ^ {O}\\right) \\tag {7}\n\\]\n\nwhere  \\(W^P\\)  is the learnable projection matrix,  \\(\\pmb{b}^{P}\\) , and  \\(\\pmb{b}^{O}\\)  are bias terms,  \\(E\\in \\mathbb{R}^{|\\mathcal{V}|\\times d}\\)  is the embedding matrix for the item set  \\(\\mathcal{V}\\) . We use the shared item embedding matrix in the input and output layer for alleviating overfitting and reducing model size.\n\n### 3.6 Model Learning\n\nTraining. Conventional unidirectional sequential recommendation models usually train the model by predicting the next item for each position in the input sequence as illustrated in Figure 1c and 1d. Specifically, the target of the input sequence  \\([v_{1},\\dots,v_{t}]\\)  is a shifted version  \\([v_{2},\\dots,v_{t+1}]\\) . However, as shown in Figure 1b, jointly conditioning on both left and right context in a bidirectional model would cause the final output representation of each item to contain the information of the target item. This makes predicting the future become trivial and the network would not learn anything useful. A simple solution for this issue is to create  \\(t-1\\)  samples (subsequences with next items like  \\(([v_{1}],v_{2})\\)  and  \\(([v_{1},v_{2}],v_{3}))\\)  from the original length  \\(t\\)  behavior sequence and then encode each historical\n\nsubsequence with the bidirectional model to predict the target item. However, this approach is very time and resources consuming since we need to create a new sample for each position in the sequence and predict them separately.\n\nIn order to efficiently train our proposed model, we apply a new objective: Cloze task [50] (also known as \"Masked Language Model\" in [6]) to sequential recommendation. It is a test consisting of a portion of language with some words removed, where the participant is asked to fill the missing words. In our case, for each training step, we randomly mask  \\(\\rho\\)  proportion of all items in the input sequence (i.e., replace with special token \"[mask]\", and then predict the original ids of the masked items based solely on its left and right context. For example:\n\n\\[\n\\text {I n p u t :} [ v _ {1}, v _ {2}, v _ {3}, v _ {4}, v _ {5} ] \\xrightarrow {\\text {r a n d o m l y m a s k}} [ v _ {1}, [ \\text {m a s k} ] _ {1}, v _ {3}, [ \\text {m a s k} ] _ {2}, v _ {5} ]\n\\]\n\n\\[\n\\text {L a b e l s :} [ \\text {m a s k} ] _ {1} = v _ {2}, \\quad [ \\text {m a s k} ] _ {2} = v _ {4}\n\\]\n\nThe final hidden vectors corresponding to \"[mask]\" are fed into an output softmax over the item set, as in conventional sequential recommendation. Eventually, we define the loss for each masked input  \\(S_{u}^{\\prime}\\)  as the negative log-likelihood of the masked targets:\n\n\\[\n\\mathcal {L} = \\frac {1}{| \\mathcal {S} _ {u} ^ {m} |} \\sum_ {v _ {m} \\in \\mathcal {S} _ {u} ^ {m}} - \\log P \\left(v _ {m} = v _ {m} ^ {*} \\mid \\mathcal {S} _ {u} ^ {\\prime}\\right) \\tag {8}\n\\]\n\nwhere  \\(S_{u}^{\\prime}\\)  is the masked version for user behavior history  \\(S_{u}, S_{u}^{m}\\)  is the random masked items in it,  \\(v_{m}^{*}\\)  is the true item for the masked item  \\(v_{m}\\) , and the probability  \\(P(\\cdot)\\)  is defined in Equation 7.\n\nAn additional advantage for Cloze task is that it can generate more samples to train the model. Assuming a sequence of length  \\(n\\) , conventional sequential predictions in Figure 1c and 1d produce  \\(n\\)  unique samples for training, while BERT4Rec can obtain  \\(\\binom{n}{k}\\)  samples (if we randomly mask  \\(k\\)  items) in multiple epochs. It allows us to train a more powerful bidirectional representation model.\n\nTest. As described above, we create a mismatch between the training and the final sequential recommendation task since the Cloze objective is to predict the current masked items while sequential recommendation aims to predict the future. To address this, we append the special token \"[mask]\" to the end of user's behavior sequence, and then predict the next item based on the final hidden representation of this token. To better match the sequential recommendation task (i.e., predict the last item), we also produce samples that only mask the last item in the input sequences during training. It works like fine-tuning for sequential recommendation and can further improve the recommendation performances.\n\n## 3.7 Discussion\n\nHere, we discuss the relation of our model with previous related work.\n\nSASRec. Obviously, SASRec is a left-to-right unidirectional version of our BERT4Rec with single head attention and causal attention mask. Different architectures lead to different training methods. SASRec predicts the next item for each position in a sequence, while BERT4Rec predicts the masked items in the sequence using Cloze objective.\n\nCBOW & SG. Another very similar work is Continuous Bag-of-Words (CBOW) and Skip-Gram (SG) [35]. CBOW predicts a target word using the average of all the word vectors in its context (both\n\nTable 1: Statistics of datasets.  \n\n<table><tr><td>Datasets</td><td>#users</td><td>#items</td><td>#actions</td><td>Avg. length</td><td>Density</td></tr><tr><td>Beauty</td><td>40,226</td><td>54,542</td><td>0.35m</td><td>8.8</td><td>0.02%</td></tr><tr><td>Steam</td><td>281,428</td><td>13,044</td><td>3.5m</td><td>12.4</td><td>0.10%</td></tr><tr><td>ML-1m</td><td>6040</td><td>3416</td><td>1.0m</td><td>163.5</td><td>4.79%</td></tr><tr><td>ML-20m</td><td>138,493</td><td>26,744</td><td>20m</td><td>144.4</td><td>0.54%</td></tr></table>\n\nleft and right). It can be seen as a simplified case of BERT4Rec, if we use one self-attention layer in BERT4Rec with uniform attention weights on items, unshare item embeddings, remove the positional embedding, and only mask the central item. Similar to CBOW, SG can also be seen as a simplified case of BERT4Rec following similar reduction operations (mask all items except only one). From this point of view, Cloze can be seen as a general form for the objective of CBOW and SG. Besides, CBOW uses a simple aggregator to model word sequences since its goal is to learn good word representations, not sentence representations. On the contrary, we seek to learn a powerful behavior sequence representation model (deep self-attention network in this work) for making recommendations.\n\nBERT. Although our BERT4Rec is inspired by the BERT in NLP, it still has several differences from BERT: a) The most critical difference is that BERT4Rec is an end-to-end model for sequential recommendation, while BERT is a pre-training model for sentence representation. BERT leverages large-scale task-independent corpora to pre-train the sentence representation model for various text sequence tasks since these tasks share the same background knowledge about the language. However, this assumption does not hold in the recommendation tasks. Thus we train BERT4Rec end-to-end for different sequential recommendation datasets. b) Different from BERT, we remove the next sentence loss and segment embeddings since BERT4Rec models a user's historical behaviors as only one sequence in sequential recommendation task.\n",
  "experiments": "# 4 EXPERIMENTS\n\n## 4.1 Datasets\n\nWe evaluate the proposed model on four real-world representative datasets which vary significantly in domains and sparsity.\n\n- Amazon Beauty<sup>3</sup>: This is a series of product review datasets crawled from Amazon.com by McAuley et al. [34]. They split the data into separate datasets according to the top-level product categories on Amazon. In this work, we adopt the \"Beauty\" category.  \n- Steam<sup>4</sup>: This is a dataset collected from Steam, a large online video game distribution platform, by Kang and McAuley [22].  \n- MovieLens [8]: This is a popular benchmark dataset for evaluating recommendation algorithms. In this work, we adopt two well-established versions, MovieLens 1m (ML-1m) \\(^{5}\\)  and MovieLens 20m (ML-20m) \\(^{6}\\) .\n\nFor dataset preprocessing, we follow the common practice in [22, 40, 49]. For all datasets, we convert all numeric ratings or the presence of a review to implicit feedback of 1 (i.e., the user interacted\n\nwith the item). After that, we group the interaction records by users and build the interaction sequence for each user by sorting these interaction records according to the timestamps. To ensure the quality of the dataset, following the common practice [12, 22, 40, 49], we keep users with at least five feedbacks. The statistics of the processed datasets are summarized in Table 1.\n\n## 4.2 Task Settings & Evaluation Metrics\n\nTo evaluate the sequential recommendation models, we adopted the leave-one-out evaluation (i.e., next item recommendation) task, which has been widely used in [12, 22, 49]. For each user, we hold out the last item of the behavior sequence as the test data, treat the item just before the last as the validation set, and utilize the remaining items for training. For easy and fair evaluation, we follow the common strategy in [12, 22, 49], pairing each ground truth item in the test set with 100 randomly sampled negative items that the user has not interacted with. To make the sampling reliable and representative [19], these 100 negative items are sampled according to their popularity. Hence, the task becomes to rank these negative items with the ground truth item for each user.\n\nEvaluation Metrics. To evaluate the ranking list of all the models, we employ a variety of evaluation metrics, including Hit Ratio (HR), Normalized Discounted Cumulative Gain (NDCG), and Mean Reciprocal Rank (MRR). Considering we only have one ground truth item for each user, HR@k is equivalent to Recall@k and proportional to Precision@k; MRR is equivalent to Mean Average Precision (MAP). In this work, we report HR and NDCG with  \\(k = 1, 5, 10\\) . For all these metrics, the higher the value, the better the performance.\n\n## 4.3 Baselines & Implementation Details\n\nTo verify the effectiveness of our method, we compare it with the following representative baselines:\n\n- POP: It is the simplest baseline that ranks items according to their popularity judged by the number of interactions.  \n- BPR-MF [39]: It optimizes the matrix factorization with implicit feedback using a pairwise ranking loss.  \n- NCF [12]: It models useråÅSitem interactions with a MLP instead of the inner product in matrix factorization.  \n- FPMC [40]: It captures users' general taste as well as their sequential behaviors by combing MF with first-order MCs.  \n- GRU4Rec [15]: It uses GRU with ranking based loss to model user sequences for session based recommendation.  \n- GRU4Rec+ [14]: It is an improved version of GRU4Rec with a new class of loss functions and sampling strategy.  \n- Caser [49]: It employs CNN in both horizontal and vertical way to model high-order MCs for sequential recommendation.  \n- SASRec [22]: It uses a left-to-right Transformer language model to capture users' sequential behaviors, and achieves state-of-the-art performance on sequential recommendation.\n\nFor  \\(\\mathrm{NCF^7}\\) , GRU4Rec \\(^8\\) , GRU4Rec \\(^{+8}\\) , Caser \\(^9\\) , and SASRec \\(^{10}\\) , we use code provided by the corresponding authors. For BPR-MF and\n\nFPMC, we implement them using TensorFlow. For common hyperparameters in all models, we consider the hidden dimension size  \\(d\\)  from  \\(\\{16, 32, 64, 128, 256\\}\\) , the  \\(\\ell_2\\)  regularizer from  \\(\\{1, 0.1, 0.01, 0.001, 0.0001\\}\\) , and dropout rate from  \\(\\{0, 0.1, 0.2, \\dots, 0.9\\}\\) . All other hyper-parameters (e.g., Markov order in Caser) and initialization strategies are either followed the suggestion from the methods' authors or tuned on the validation sets. We report the results of each baseline under its optimal hyper-parameter settings.\n\nWe implement BERT4Rec<sup>11</sup> with TensorFlow. All parameters are initialized using truncated normal distribution in the range  \\([-0.02, 0.02]\\) . We train the model using Adam [24] with learning rate of 1e-4,  \\(\\beta_{1} = 0.9\\) ,  \\(\\beta_{2} = 0.999\\) ,  \\(\\ell_{2}\\)  weight decay of 0.01, and linear decay of the learning rate. The gradient is clipped when its  \\(\\ell_{2}\\)  norm exceeds a threshold of 5. For fair comparison, we set the layer number  \\(L = 2\\)  and head number  \\(h = 2\\)  and use the same maximum sequence length as in [22],  \\(N = 200\\)  for ML-1m and ML-20m,  \\(N = 50\\)  for Beauty and Steam datasets. For head setting, we empirically set the dimensionality of each head as 32 (single head if  \\(d < 32\\) ). We tune the mask proportion  \\(\\rho\\)  using the validation set, resulting in  \\(\\rho = 0.6\\)  for Beauty,  \\(\\rho = 0.4\\)  for Steam, and  \\(\\rho = 0.2\\)  for ML-1m and ML-20m. All the models are trained from scratch without any pre-training on a single NVIDIA GeForce GTX 1080 Ti GPU with a batch size of 256.\n\n## 4.4 Overall Performance Comparison\n\nTable 2 summarized the best results of all models on four benchmark datasets. The last column is the improvements of BERT4Rec relative to the best baseline. We omit the NDCG@1 results since it is equal to HR@1 in our experiments. It can be observed that:\n\nThe non-personalized POP method gives the worst performance \\(^{12}\\)  on all datasets since it does not model user's personalized preference using the historical records. Among all the baseline methods, sequential methods (e.g., FPMC and GRU4Rec \\(^{+}\\) ) outperforms non-sequential methods (e.g., BPR-MF and NCF) on all datasets consistently. Compared with BPR-MF, the main improvement of FPMC is that it models users' historical records in a sequential way. This observation verifies that considering sequential information is beneficial for improving performances in recommendation systems.\n\nAmong sequential recommendation baselines, Caser outperforms FPMC on all datasets especially for the dense dataset ML-1m, suggesting that high-order MCs is beneficial for sequential recommendation. However, high-order MCs usually use very small order  \\(L\\)  since they do not scale well with the order  \\(L\\) . This causes Caser to perform worse than GRU4Rec+ and SASRec, especially on sparse datasets. Furthermore, SASRec performs distinctly better than GRU4Rec and GRU4Rec+, suggesting that self-attention mechanism is a more powerful tool for sequential recommendation.\n\nAccording to the results, it is obvious that BERT4Rec performs best among all methods on four datasets in terms of all evaluation metrics. It gains  \\(7.24\\%\\)  HR@10,  \\(11.03\\%\\)  NDCG@10, and  \\(11.46\\%\\)  MRR improvements (on average) against the strongest baselines.\n\nQuestion 1: Do the gains come from the bidirectional self-attention model or from the Cloze objective?\n\nTable 2: Performance comparison of different methods on next-item prediction. Bold scores are the best in each row, while underlined scores are the second best. Improvements over baselines are statistically significant with  \\(p < 0.01\\) .  \n\n<table><tr><td>Datasets</td><td>Metric</td><td>POP</td><td>BPR-MF</td><td>NCF</td><td>FPMC</td><td>GRU4Rec</td><td>GRU4Rec+</td><td>Caser</td><td>SASRec</td><td>BERT4Rec</td><td>Improv.</td></tr><tr><td rowspan=\"6\">Beauty</td><td>HR@1</td><td>0.0077</td><td>0.0415</td><td>0.0407</td><td>0.0435</td><td>0.0402</td><td>0.0551</td><td>0.0475</td><td>0.0906</td><td>0.0953</td><td>5.19%</td></tr><tr><td>HR@5</td><td>0.0392</td><td>0.1209</td><td>0.1305</td><td>0.1387</td><td>0.1315</td><td>0.1781</td><td>0.1625</td><td>0.1934</td><td>0.2207</td><td>14.12%</td></tr><tr><td>HR@10</td><td>0.0762</td><td>0.1992</td><td>0.2142</td><td>0.2401</td><td>0.2343</td><td>0.2654</td><td>0.2590</td><td>0.2653</td><td>0.3025</td><td>14.02%</td></tr><tr><td>NDCG@5</td><td>0.0230</td><td>0.0814</td><td>0.0855</td><td>0.0902</td><td>0.0812</td><td>0.1172</td><td>0.1050</td><td>0.1436</td><td>0.1599</td><td>11.35%</td></tr><tr><td>NDCG@10</td><td>0.0349</td><td>0.1064</td><td>0.1124</td><td>0.1211</td><td>0.1074</td><td>0.1453</td><td>0.1360</td><td>0.1633</td><td>0.1862</td><td>14.02%</td></tr><tr><td>MRR</td><td>0.0437</td><td>0.1006</td><td>0.1043</td><td>0.1056</td><td>0.1023</td><td>0.1299</td><td>0.1205</td><td>0.1536</td><td>0.1701</td><td>10.74%</td></tr><tr><td rowspan=\"6\">Steam</td><td>HR@1</td><td>0.0159</td><td>0.0314</td><td>0.0246</td><td>0.0358</td><td>0.0574</td><td>0.0812</td><td>0.0495</td><td>0.0885</td><td>0.0957</td><td>8.14%</td></tr><tr><td>HR@5</td><td>0.0805</td><td>0.1177</td><td>0.1203</td><td>0.1517</td><td>0.2171</td><td>0.2391</td><td>0.1766</td><td>0.2559</td><td>0.2710</td><td>5.90%</td></tr><tr><td>HR@10</td><td>0.1389</td><td>0.1993</td><td>0.2169</td><td>0.2551</td><td>0.3313</td><td>0.3594</td><td>0.2870</td><td>0.3783</td><td>0.4013</td><td>6.08%</td></tr><tr><td>NDCG@5</td><td>0.0477</td><td>0.0744</td><td>0.0717</td><td>0.0945</td><td>0.1370</td><td>0.1613</td><td>0.1131</td><td>0.1727</td><td>0.1842</td><td>6.66%</td></tr><tr><td>NDCG@10</td><td>0.0665</td><td>0.1005</td><td>0.1026</td><td>0.1283</td><td>0.1802</td><td>0.2053</td><td>0.1484</td><td>0.2147</td><td>0.2261</td><td>5.31%</td></tr><tr><td>MRR</td><td>0.0669</td><td>0.0942</td><td>0.0932</td><td>0.1139</td><td>0.1420</td><td>0.1757</td><td>0.1305</td><td>0.1874</td><td>0.1949</td><td>4.00%</td></tr><tr><td rowspan=\"6\">ML-1m</td><td>HR@1</td><td>0.0141</td><td>0.0914</td><td>0.0397</td><td>0.1386</td><td>0.1583</td><td>0.2092</td><td>0.2194</td><td>0.2351</td><td>0.2863</td><td>21.78%</td></tr><tr><td>HR@5</td><td>0.0715</td><td>0.2866</td><td>0.1932</td><td>0.4297</td><td>0.4673</td><td>0.5103</td><td>0.5353</td><td>0.5434</td><td>0.5876</td><td>8.13%</td></tr><tr><td>HR@10</td><td>0.1358</td><td>0.4301</td><td>0.3477</td><td>0.5946</td><td>0.6207</td><td>0.6351</td><td>0.6692</td><td>0.6629</td><td>0.6970</td><td>4.15%</td></tr><tr><td>NDCG@5</td><td>0.0416</td><td>0.1903</td><td>0.1146</td><td>0.2885</td><td>0.3196</td><td>0.3705</td><td>0.3832</td><td>0.3980</td><td>0.4454</td><td>11.91%</td></tr><tr><td>NDCG@10</td><td>0.0621</td><td>0.2365</td><td>0.1640</td><td>0.3439</td><td>0.3627</td><td>0.4064</td><td>0.4268</td><td>0.4368</td><td>0.4818</td><td>10.32%</td></tr><tr><td>MRR</td><td>0.0627</td><td>0.2009</td><td>0.1358</td><td>0.2891</td><td>0.3041</td><td>0.3462</td><td>0.3648</td><td>0.3790</td><td>0.4254</td><td>12.24%</td></tr><tr><td rowspan=\"6\">ML-20m</td><td>HR@1</td><td>0.0221</td><td>0.0553</td><td>0.0231</td><td>0.1079</td><td>0.1459</td><td>0.2021</td><td>0.1232</td><td>0.2544</td><td>0.3440</td><td>35.22%</td></tr><tr><td>HR@5</td><td>0.0805</td><td>0.2128</td><td>0.1358</td><td>0.3601</td><td>0.4657</td><td>0.5118</td><td>0.3804</td><td>0.5727</td><td>0.6323</td><td>10.41%</td></tr><tr><td>HR@10</td><td>0.1378</td><td>0.3538</td><td>0.2922</td><td>0.5201</td><td>0.5844</td><td>0.6524</td><td>0.5427</td><td>0.7136</td><td>0.7473</td><td>4.72%</td></tr><tr><td>NDCG@5</td><td>0.0511</td><td>0.1332</td><td>0.0771</td><td>0.2239</td><td>0.3090</td><td>0.3630</td><td>0.2538</td><td>0.4208</td><td>0.4967</td><td>18.04%</td></tr><tr><td>NDCG@10</td><td>0.0695</td><td>0.1786</td><td>0.1271</td><td>0.2895</td><td>0.3637</td><td>0.4087</td><td>0.3062</td><td>0.4665</td><td>0.5340</td><td>14.47%</td></tr><tr><td>MRR</td><td>0.0709</td><td>0.1503</td><td>0.1072</td><td>0.2273</td><td>0.2967</td><td>0.3476</td><td>0.2529</td><td>0.4026</td><td>0.4785</td><td>18.85%</td></tr></table>\n\nTable 3: Analysis on bidirection and Cloze with  \\(d = 256\\)  \n\n<table><tr><td rowspan=\"2\">Model</td><td colspan=\"3\">Beauty</td><td colspan=\"3\">ML-1m</td></tr><tr><td>HR@10</td><td>NDCG@10</td><td>MRR</td><td>HR@10</td><td>NDCG@10</td><td>MRR</td></tr><tr><td>SASRec</td><td>0.2653</td><td>0.1633</td><td>0.1536</td><td>0.6629</td><td>0.4368</td><td>0.3790</td></tr><tr><td>BERT4Rec (1 mask)</td><td>0.2940</td><td>0.1769</td><td>0.1618</td><td>0.6869</td><td>0.4696</td><td>0.4127</td></tr><tr><td>BERT4Rec</td><td>0.3025</td><td>0.1862</td><td>0.1701</td><td>0.6970</td><td>0.4818</td><td>0.4254</td></tr></table>\n\nTo answer this question, we try to isolate the effects of these two factors by constraining the Cloze task to mask only one item at a time. In this way, the main difference between our BERT4Rec (with 1 mask) and SASRec is that BERT4Rec predicts the target item jointly conditioning on both left and right context. We report the results on Beauty and ML-1m with  \\(d = 256\\)  in Table 3 due to the space limitation. The results show that BERT4Rec with 1 mask significantly outperforms SASRec on all metrics. It demonstrates the importance of bidirectional representations for sequential recommendation. Besides, the last two rows indicate that the Cloze objective also improves the performances. Detailed analysis of the mask proportion  \\(\\rho\\)  in Cloze task can be found in § 4.6\n\nQuestion 2: Why and how does bidirectional model outperform unidirectional models?\n\nTo answer this question, we try to reveal meaningful patterns by visualizing the average attention weights of the last 10 items during the test on Beauty in Figure 2. Due to the space limitation, we only report four representative attention heat-maps in different layers and heads.\n\n![](images/107c0f56dd801c30b8dd72607d2cbb99e912d5609d74df67a30444bf06c8e154.jpg)  \n(a) Layer 1, head 1\n\n![](images/5e23364b04143e2a44149b06909273663e57778edec68f6327772f996ec62dfe.jpg)  \n(b) Layer 1, head 2\n\n![](images/a7d77f66404bbbf4e0b669f407ca1dc2ba64d05db62c13f206e996ef376e02d9.jpg)  \n(c) Layer 2, head 2  \nFigure 2: Heat-maps of average attention weights on Beauty, the last position \"9\" denotes \"[mask]\" (best viewed in color).\n\n![](images/69e0c099463a742ec84fdc0ad42fc81128f02a66d1e53402e9ff1b86f427352f.jpg)  \n(d) Layer 2, head 4\n\nWe make several observations from the results.  \\(a)\\)  Attention varies across different heads. For example, in layer 1, head 1 tends\n\n![](images/aae5613fc04607693736dd895cd178a62e9772d96acf8a8481144b3015c2b421.jpg)  \nFigure 3: Effect of the hidden dimensionality  \\(d\\)  on  \\(\\mathrm{HR}@\\mathbf{10}\\)  and NDCG@10 for neural sequential models.\n\nto attend on items at the left side while head 2 prefers to attend on items on the right side.  \\(b\\)  Attention varies across different layers. Apparently, attentions in layer 2 tend to focus on more recent items. This is because layer 2 is directly connected to the output layer and the recent items play a more important role in predicting the future. Another interesting pattern is that heads in Figure 2a and 2b also tend to attend on  \\([\\mathsf{mask}]^{13}\\) . It may be a way for self-attention to propagate sequence-level state to the item level. c) Finally and most importantly, unlike unidirectional model can only attend on items at the left side, items in BERT4Rec tend to attend on the items at both sides. This indicates that bidirectional is essential and beneficial for user behavior sequence modeling.\n\nIn the following studies, we examine the impact of the hyperparameters, including the hidden dimensionality  \\(d\\) , the mask proportion  \\(\\rho\\) , and the maximum sequence length  \\(N\\) . We analyze one hyper-parameter at a time by fixing the remaining hyper-parameters at their optimal settings. Due to space limitation, we only report NDCG@10 and HR@10 for the follow-up experiments.\n\n### 4.5 Impact of Hidden Dimensionality  \\(d\\)\n\nWe now study how the hidden dimensionality  \\(d\\)  affects the recommendation performance. Figure 3 shows NDCG@10 and HR@10 for neural sequential methods with the hidden dimensionality  \\(d\\)  varying from 16 to 256 while keeping other optimal hyper-parameters unchanged. We make some observations from this figure.\n\nThe most obvious observation from these sub-figures is that the performance of each model tends to converge as the dimensionality increases. A larger hidden dimensionality does not necessarily lead to better model performance, especially on sparse datasets like Beauty and Steam. This is probably caused by overfitting. In terms of details, Caser performs unstably on four datasets, which might limit its usefulness. Self-attention based methods (i.e., SASRec and BERT4Rec) achieve superior performances on all datasets. Finally, our model consistently outperforms all other baselines on all\n\ndatasets even with a relatively small hidden dimensionality. Considering that our model achieves satisfactory performance with  \\(d \\geq 64\\) , we only report the results with  \\(d = 64\\)  in the following analysis.\n\n### 4.6 Impact of Mask Proportion  \\(\\rho\\)\n\n![](images/78859754b51136734d6f2ee0ccdc857b5b814d626eeebf60f9f66a32d0dbdc1e.jpg)  \nFigure 4: Performance with different mask proportion  \\(\\rho\\)  on  \\(d = 64\\) . Bold symbols denote the best scores in each line.\n\n![](images/8edcca8c7b62f168a7ecd392bb26fd623a0826d899c90c1b04c7ebf43cbc536c.jpg)\n\nAs described in § 3.6, mask proportion  \\(\\rho\\)  is a key factor in model training, which directly affects the loss function (Equation 8). Obviously, mask proportion  \\(\\rho\\)  should not be too small or it is not enough to learn a strong model. Meanwhile, it should not be too large, otherwise, it would be hard to train since there are too many items to guess based on a few contexts in such case. To examine this, we study how mask proportion  \\(\\rho\\)  affects the recommendation performances on different datasets.\n\nFigure 4 shows the results with varying mask proportion  \\(\\rho\\)  from 0.1 to 0.9. Considering the results with  \\(\\rho > 0.6\\)  on all datasets, a general pattern emerges, the performances decreasing as  \\(\\rho\\)  increases. From the results of the first two columns, it is easy to see that  \\(\\rho = 0.2\\)  performs better than  \\(\\rho = 0.1\\)  on all datasets. These results verify what we claimed above.\n\nIn addition, we observe that the optimal  \\(\\rho\\)  is highly dependent on the sequence length of the dataset. For the datasets with short sequence length (e.g., Beauty and Steam), the best performances are\n\nTable 4: Performance with different maximum length  \\(N\\) .  \n\n<table><tr><td></td><td></td><td>10</td><td>20</td><td>30</td><td>40</td><td>50</td></tr><tr><td rowspan=\"3\">Beauty</td><td>#samples/s</td><td>5504</td><td>3256</td><td>2284</td><td>1776</td><td>1441</td></tr><tr><td>HR@10</td><td>0.3006</td><td>0.3061</td><td>0.3057</td><td>0.3054</td><td>0.3047</td></tr><tr><td>NDCG@10</td><td>0.1826</td><td>0.1875</td><td>0.1837</td><td>0.1833</td><td>0.1832</td></tr><tr><td></td><td></td><td>10</td><td>50</td><td>100</td><td>200</td><td>400</td></tr><tr><td rowspan=\"3\">ML-1m</td><td>#samples/s</td><td>14255</td><td>8890</td><td>5711</td><td>2918</td><td>1213</td></tr><tr><td>HR@10</td><td>0.6788</td><td>0.6854</td><td>0.6947</td><td>0.6955</td><td>0.6898</td></tr><tr><td>NDCG@10</td><td>0.4631</td><td>0.4743</td><td>0.4758</td><td>0.4759</td><td>0.4715</td></tr></table>\n\nachieved at  \\(\\rho = 0.6\\)  (Beauty) and  \\(\\rho = 0.4\\)  (Steam), while the datasets with long sequence length (e.g., ML-1m and ML-20m) prefer a small  \\(\\rho = 0.2\\) . This is reasonable since, compared with short sequence datasets, a large  \\(\\rho\\)  in long sequence datasets means much more items that need to be predicted. Take ML-1m and Beauty as example,  \\(\\rho = 0.6\\)  means we need to predict  \\(98 = \\lfloor 163.5 \\times 0.6 \\rfloor\\)  items on average per sequence for ML-1m, while it is only  \\(5 = \\lfloor 8.8 \\times 0.6 \\rfloor\\)  items for Beauty. The former is too hard for model training.\n\n### 4.7 Impact of Maximum Sequence Length  \\(N\\)\n\nWe also investigate the effect of the maximum sequence length  \\(N\\)  on model's recommendation performances and efficiency.\n\nTable 4 shows recommendation performances and training speed with different maximum length  \\(N\\)  on Beauty and ML-1m. We observe that the proper maximum length  \\(N\\)  is also highly dependent on the average sequence length of the dataset. Beauty prefers a smaller  \\(N = 20\\) , while ML-1m achieves the best performances on  \\(N = 200\\) . This indicates that a user's behavior is affected by more recent items on short sequence datasets and less recent items for long sequence datasets. The model does not consistently benefit from a larger  \\(N\\)  since a larger  \\(N\\)  tends to introduce both extra information and more noise. However, our model performs very stably as the length  \\(N\\)  becomes larger. This indicates that our model can attend to the informative items from the noisy historical records.\n\nA scalability concern about BERT4Rec is that its computational complexity per layer is  \\(O(n^{2}d)\\) , quadratic with the length  \\(n\\) . Fortunately, the results in Table 4 shows that the self-attention layer can be effectively parallelized using GPUs.\n\n## 4.8 Ablation Study\n\nFinally, we perform ablation experiments over a number of key components of BERT4Rec in order to better understand their impacts, including positional embedding (PE), position-wise feed-forward network (PFFN), layer normalization (LN), residual connection (RC), dropout, the layer number  \\(L\\)  of self-attention, and the number of heads  \\(h\\)  in multi-head attention. Table 5 shows the results of our default version  \\((L = 2, h = 2)\\)  and its eleven variants on all four datasets with dimensionality  \\(d = 64\\)  while keeping other hyperparameters  \\((e,g,\\rho)\\)  at their optimal settings.\n\nWe introduce the variants and analyze their effects respectively:\n\n(1) PE. The results show that removing positional embeddings causes BERT4Rec's performances decreasing dramatically on long sequence datasets (i.e., ML-1m and ML-20m). Without the positional embeddings, the hidden representation  \\(H_{i}^{L}\\)\n\nTable 5: Ablation analysis (NDCG@10) on four datasets. Bold score indicates performance better than the default version, while  \\(\\downarrow\\)  indicates performance drop more than  \\(10\\%\\) .  \n\n<table><tr><td rowspan=\"2\">Architecture</td><td colspan=\"4\">Dataset</td></tr><tr><td>Beauty</td><td>Steam</td><td>ML-1m</td><td>ML-20m</td></tr><tr><td>L=2,h=2</td><td>0.1832</td><td>0.2241</td><td>0.4759</td><td>0.4513</td></tr><tr><td>w/o PE</td><td>0.1741</td><td>0.2060</td><td>0.2155↓</td><td>0.2867↓</td></tr><tr><td>w/o PFFN</td><td>0.1803</td><td>0.2137</td><td>0.4544</td><td>0.4296</td></tr><tr><td>w/o LN</td><td>0.1642↓</td><td>0.2058</td><td>0.4334</td><td>0.4186</td></tr><tr><td>w/o RC</td><td>0.1619↓</td><td>0.2193</td><td>0.4643</td><td>0.4483</td></tr><tr><td>w/o Dropout</td><td>0.1658</td><td>0.2185</td><td>0.4553</td><td>0.4471</td></tr><tr><td>1 layer (L=1)</td><td>0.1782</td><td>0.2122</td><td>0.4412</td><td>0.4238</td></tr><tr><td>3 layers (L=3)</td><td>0.1859</td><td>0.2262</td><td>0.4864</td><td>0.4661</td></tr><tr><td>4 layers (L=4)</td><td>0.1834</td><td>0.2279</td><td>0.4898</td><td>0.4732</td></tr><tr><td>1 head (h=1)</td><td>0.1853</td><td>0.2187</td><td>0.4568</td><td>0.4402</td></tr><tr><td>4 heads (h=4)</td><td>0.1830</td><td>0.2245</td><td>0.4770</td><td>0.4520</td></tr><tr><td>8 heads (h=8)</td><td>0.1823</td><td>0.2248</td><td>0.4743</td><td>0.4550</td></tr></table>\n\nfor each item  \\(v_{i}\\)  depends only on item embeddings. In this situation, we predict different target items using the same hidden representation of \"[mask]\". This makes the model ill-posed. This issue is more serious on long sequence datasets since they have more masked items to predict.\n\n(2) PFFN. The results show that long sequence datasets (e.g., ML-20m) benefit more from PFFN. This is reasonable since a purpose of PFFN is to integrate information from many heads which are preferred by long sequence datasets as discussed in the analysis about head number  \\(h\\)  in ablation study (5).  \n(3) LN, RC, and Dropout. These components are introduced mainly to alleviate overfitting. Obviously, they are more effective on small datasets like Beauty. To verify their effectiveness on large datasets, we conduct an experiment on ML-20m with layer  \\(L = 4\\) . The results show that NDCG@10 decreases about  \\(10\\%\\)  w/o RC.  \n(4) Number of layers  \\(L\\) . The results show that stacking Transformer layer can boost performances especially on large datasets (e.g., ML-20m). This verifies that it is helpful to learn more complex item transition patterns via deep self-attention architecture. The decline in Beauty with  \\(L = 4\\)  is largely due to overfitting.  \n(5) Head number  \\(h\\) . We observe that long sequence datasets (e.g., ML-20m) benefit from a larger  \\(h\\)  while short sequence datasets (e.g., Beauty) prefer a smaller  \\(h\\) . This phenomenon is consistent with the empirical result in [48] that large  \\(h\\)  is essential for capturing long distance dependencies with multi-head self-attention.\n",
  "hyperparameter": "Hidden dimensionality d: {16, 32, 64, 128, 256}, recommended d=64 for stable performance; Number of Transformer layers L=2 (default), L=3-4 for large datasets; Number of attention heads h=2 (default), with each head dimension=32; Maximum sequence length N=50 for short sequences (Beauty, Steam), N=200 for long sequences (ML-1m, ML-20m); Mask proportion ρ=0.6 for Beauty, ρ=0.4 for Steam, ρ=0.2 for ML-1m and ML-20m (inversely related to sequence length); Learning rate=1e-4 with Adam optimizer (β1=0.9, β2=0.999); L2 weight decay=0.01; Gradient clipping threshold=5.0; Batch size=256; Dropout rate tuned from {0, 0.1, 0.2, ..., 0.9}; Parameters initialized from truncated normal distribution [-0.02, 0.02]"
}