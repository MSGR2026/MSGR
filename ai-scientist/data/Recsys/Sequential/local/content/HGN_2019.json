{
  "id": "HGN_2019",
  "paper_title": "Hierarchical Gating Networks for Sequential Recommendation",
  "alias": "HGN",
  "year": 2019,
  "domain": "Recsys",
  "task": "SequentialRecommendation",
  "idea": "HGN proposes a hierarchical gating network for sequential recommendation that captures both group-level and instance-level relations. The model introduces two key innovations: (1) a feature gating module that selects salient latent features from items based on user preferences, and (2) an instance gating module that identifies informative items in the sequence. Additionally, it explicitly models item-item relations through inner product between input and output item embeddings, combining short-term sequential patterns with long-term user interests for improved recommendation performance.",
  "introduction": "# 1 INTRODUCTION\n\nAs the Internet service and mobile device usages keep growing, Internet users can easily access a large number of online products and services. Although this growth provides users with more available choices, it is also difficult for users to pick up one of the most favorite items out of plenty of candidates. To reduce information overload and satisfy the diverse needs of users, personalized recommender systems come into being and play more and more important roles in modern society. These systems can provide personalized experiences, serve huge service demands, and bring significant benefits to at least two parties: (1) help users easily discover products that they are interested in; (2) create opportunities for product providers to increase the revenue.\n\nIn all kinds of Internet services, users access the products or items in a chronological order, where the items a user will interact may be closely relevant to those items she just accessed. This property\n\nfacilitates a non-trivial recommendation task—sequential recommendation, which treats the user behavior history as an action sequence ordered by the operating timestamp. This task is challenging to address due to one major reason: the difficulty of inferring users' short-term interests and intentions. Indeed, both the long-term and short-term interests of users together determine the users' actions on items. With the large accumulated data, the long-term user interests can be effectively modeled. However, within a short-term context, how to take advantage of the sequential dynamics for predicting user actions in the near future is non-trivial.\n\nTo capture the sequential dynamics in the user action history, effective models are proposed to learn the short-term user preference in the sequential user interactions, such as Markov Chains (MCs), convolutional neural networks (CNNs), and recurrent neural networks (RNNs). MC-based methods [8, 30] apply a  $K$ -order Markov chain to make recommendations based on the  $K$  previous actions. CNN-based methods [34] utilize convolutional filters and sliding window strategies to capture the short-term contexts for future prediction. RNN-based methods [12, 13, 28] adopt gated recurrent (GRU) or long short-term memory (LSTM) units to learn the user-item sequence, where the short-term user interests are captured by the hidden states of RNNs.\n\nAlthough existing methods have proposed effective models and achieved satisfactory results, we argue that there are still several factors to be considered for enhancing the performance. First, previous studies [12, 13, 28, 34] learn the user action sequence by CNN or RNN structures, which does not consider the specific parts of features of different items. Neglecting the representative features may fail to capture the true user interests in a short context. Second, these CNN or RNN based methods also do not discriminate the item importance based on users' preferences. Equally treating those informative items along with other items may lead to the incomplete understanding of user intentions. Third, it is also important to note that the relations between items are neglected in previous works [12, 18, 34]. It is very likely that closely related items may be interacted by users one after the other. As such, explicitly capturing the item-item relations will largely benefit predicting subsequent items users will interact.\n\nTo address the problems mentioned above, we propose a novel recommendation model, hierarchical gating network (HGN), for the sequential recommendation task without using complex recurrent or convolutional neural networks. HGN consists of a feature gating module, an instance gating module, and an item-item product module, integrated with the matrix factorization model and optimized by the Bayesian Personalized Ranking (BPR) objective. In particular, the feature gating module allows the adaptive selections of attractive latent features of items based on the user preference, where the selected user-specific features will be passed to the instance gating module. At the instance gating module, important\n\nitems that reflect the short-term user interests will be distinguished and selected for future item prediction. Thus, the feature gating and instance gating modules form a hierarchical gating network to control what features or items can be passed to the downstream layers. On the other hand, item-item relations provide important auxiliary information to predict users' sequential behaviors, since closely related items may be interacted by users one after the other. Thus, we apply an item-item product module to explicitly capture the relations between the items users have interacted and those items user will interact in the future. We extensively evaluate our model with many state-of-the-art methods and different validation metrics on five real-world datasets. The experimental results not only demonstrate the improvements of our model over other baselines but also show the effectiveness of the gating and item-item product modules.\n\nTo summarize, the major contributions of this paper are listed as follows:\n\n- To infer the user interests in a short-term context, we propose a hierarchical gating network to control what item latent features and which relevant item can be passed to the downstream layers. Our hierarchical gating network achieves better performance compared with complex recurrent or convolutional neural networks yet with fewer parameters and faster training speed.  \n- To explicitly capture the item-item relations, we utilize an item-item product module to learn the relationships between the items users have interacted and those items user will interact in the near future.  \n- Experiments on five real-world datasets show that the proposed HGN model significantly outperforms the state-of-the-art methods for the sequential recommendation task.",
  "method": "# 4 METHODOLOGIES\n\nTo model the sequential recommendation task, for each user  $i$ , we extract every  $|L|$ , i.e.  $L = (S_j^i,S_{j + 1}^i,\\dots,S_{j + |L| - 1}^i)$ , successive items as input and their next  $|T|$  items as the targets to be predicted. The problem can be formulated as: in the user-item interaction sequence  $S^i$ , given the  $|L|$  successive items, how likely other  $N$  items will be interacted subsequently.\n\nIn the sequential recommendation problem, the prediction of users' preferences on items can be modeled in two perspectives: long-term interests and short-term interests. The long-term user preference modeling has been widely investigated in the conventional Top-N recommendation methods, such as matrix factorization [15, 29]. On the other hand, how to capture the short-term user interests from the sequential data is the key point for performance improvement.\n\nFor the short-term interest modeling, we argue that there are two kinds of relationships existing between items users have interacted and items users will interact in the future: group-level and instance-level relations. The group-level influence illustrates a phenomenon that several items in  $L$  together have an impact on the items user may interact in the future. For example, if a user has bought a bed frame and a mattress, a pillow is probably a more suitable recommendation than a table. On the other hand, the instance-level influence depicts the strong relation between a single item in  $L$  and a single item in  $T$ . For example, if a user bought a mobile phone, she may also need to buy a screen protector or a case. Thus, these two kinds of relations together determine users' short-term interests.\n\nIn this section, we introduce the proposed model to capture both the long-term interests and short-term interests of users for the sequential recommendation, which is shown in Figure 1 and Figure 2. We first illustrate the hierarchical gating network for learning\n\nusers' group-level preferences. Next, we present the inner product of item embeddings to model the item-item relations. Then we introduce the prediction layer for aggregating the long-term and short-term interests of users. Lastly, we go through the loss function and training process of the proposed model.\n\n# 4.1 Hierarchical Gating for Group-level Influence\n\nIn the sequential recommendation, taking advantage of the properties of sequential data to learn the (sub)sequence representation is a critical point, where an item may be closely related to its previous or subsequent items, or a group of previous items will have an impact on the items in the near future. In previous works, researchers have utilized various methods to model the group-level sequential interactions, e.g., convolutional neural networks [34], recurrent neural networks [12, 13, 27, 28], and the self-attention model [18]. Different from previous works, we propose a hierarchical gating network for modeling group-level user-item interactions, which consists of two components: a feature gating module and an instance gating module. These two modules allow the selection of effective latent features and relevant items, respectively, for predicting the subsequent items. Our proposed gating network is both effective and efficient (section 5).\n\n# 4.1.1 Feature Gating\n\nUnlike previous works [12, 18, 34] that only operate on the item-level, we provide a learnable feature gating module to select salient latent features of items from the feature-level. For a certain item, some parts of the latent features are more relevant to predict the subsequent items. For example, for a big fan of Robert Downey Jr., after watching Iron Man I and Iron Man II, it is better to recommend Iron Man III rather than Aquaman, although Aquaman is also a superhero movie. Thus, to capture the representative item features based on users' long-term preferences is a necessary point to capture.\n\n**Embedding Layer.** In the proposed module, the input is a sequence of  $|L|$  items, where each item is represented by a unique index. At the embedding layer, the item index is converted into a low-dimensional real-valued dense vector representation by an item embedding matrix  $\\mathbf{E} \\in \\mathbb{R}^{d \\times N}$ , where  $d$  is the dimension of the item embedding and  $N$  is the number of items. After converted by the embedding layer, the item subsequence embeddings are\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-16/d052713c-2701-4863-b95b-2b2315a4dc5c/f169872a2c77b8cf011ef331bc3c9742a919301fdb29a120bd79584e4178c68a.jpg)  \nFigure 2: The architecture of HGN. HGN consists of three major components: the embedding layer, the hierarchical gating layer, and the prediction layer. Specifically,  $F$  Gating denotes the feature gating module,  $I$  Gating denotes the instance gating module, Aggregation denotes the aggregation layer, and  $\\otimes$  denotes the element-wise multiplication.\n\nrepresented as:\n\n$$\n\\mathbf {S} _ {i, l} = \\left[ \\begin{array}{c c c c c} & | & | & | \\\\ ... & \\mathbf {e} _ {j - 1} & \\mathbf {e} _ {j} & \\mathbf {e} _ {j + 1} & ... \\\\ & | & | & | \\end{array} \\right]\n$$\n\nwhere  $\\mathsf{S}_{i,l}\\in \\mathbb{R}^{d\\times |L|}$  indicates the embeddings of the  $l$ -th subsequence of user  $i$ ,  $\\mathbf{e}_j\\in \\mathbb{R}^d$  is the  $j$ -th column of the embedding matrix  $\\mathbf{E}$ .\n\nGated Linear Unit. Inspired by the gated linear unit (GLU) proposed by Dauphin et al. in [4], which is utilized to control what information should be propagated for predicting the next word in the language modeling task, we also adopt a similar model to select what features are relevant to predict future items. The GLU in the original paper is shown:\n\n$$\n(\\mathrm {X} * \\mathrm {W} + \\mathrm {b}) \\otimes \\sigma (\\mathrm {X} * \\mathrm {V} + \\mathrm {c}),\n$$\n\nwhere  $\\mathbf{X}$  is the input embeddings,  $\\mathbf{W},\\mathbf{V},\\mathbf{b},\\mathbf{c}$  are learnable parameters,  $\\sigma$  is the sigmoid function,  $^*$  is the convolution operation, and  $\\otimes$  is the element-wise product between matrices.\n\nPersonalized Feature Gating. However, directly applying the GLU to select item features does not explicitly consider the user preference on items. For a certain item, a user may just focus a specific part of the item and neglect other unattractive parts. For example, a user may only care about whether the starring role is Tom Cruise rather than the movie content.\n\nTherefore, to capture the item features that tailored to users' preferences, we need to modify the GLU to be user-specific. To reduce the number of learnable parameters, we apply the inner product instead of the convolution operation in the original GLU (the superscript  $F$  indicates the item sequence embeddings are learned from the feature gating module):\n\n$$\n\\mathbf {S} _ {i, l} ^ {F} = \\mathbf {S} _ {i, l} \\otimes \\sigma \\left(\\mathbf {W} _ {g _ {1}} \\cdot \\mathbf {S} _ {i, l} + \\mathbf {W} _ {g _ {2}} \\cdot \\mathbf {u} _ {i} + \\mathbf {b} _ {g}\\right), \\tag {1}\n$$\n\nwhere  $\\mathbf{u}_i\\in \\mathbb{R}^d$  is the embedding of user  $i$ ,  $\\mathbf{W}_{g_1},\\mathbf{W}_{g_2}\\in \\mathbb{R}^{d\\times d}$  and  $\\mathsf{b}_g\\in \\mathbb{R}^d$  are learnable parameters, and  $\\otimes$  is the element-wise product between matrices. By doing this, user-specific features of items can be passed to downstream layers.\n\n# 4.1.2 Instance Gating\n\nPersonalized Instance Gating. Since our formulated problem is: given  $|L|$  successive items, how likely other items will appear after  $L$  in the near feature, we argue that there are some items are more relevant in  $L$  to predict the items users will interact. However, existing works either do not consider the representative items in  $L$  [12, 34] or apply attention models to capture the representative items [18, 20]. Unlike previous works benefiting from attention models, we adopt an instance-level gating module to select the informative items that are helpful to predict items in the near future according to users' preferences:\n\n$$\n\\mathbf {S} _ {i, l} ^ {I} = \\mathbf {S} _ {i, l} ^ {F} \\otimes \\sigma \\left(\\mathbf {w} _ {g _ {3}} ^ {\\top} \\cdot \\mathbf {S} _ {i, l} ^ {F} + \\mathbf {u} _ {i} ^ {\\top} \\cdot \\mathbf {W} _ {g _ {4}}\\right), \\tag {2}\n$$\n\nwhere  $\\mathbf{S}_{i,l}^{I}\\in \\mathbb{R}^{d\\times |L|}$  is the sequence embedding after the instance gating,  $\\mathbf{w}_{g_3}\\in \\mathbb{R}^d$ $\\mathbf{W}_{g_4}\\in \\mathbb{R}^{d\\times |L|}$  are learnable parameters. By applying the instance gating, the representative items will contribute more to make predictions about the future items and irrelevant items will be largely neglected.\n\nAggregation Layer. To make the item embeddings  $\\mathbf{S}_{i,l}^{I}$  into one group-level latent representation, we can either apply average pooling or max pooling on  $\\mathbf{S}_{i,l}^{I}$ :\n\n$$\n\\mathbf {s} _ {i, l} ^ {a v g} = a v g - p o o l i n g \\left(\\mathbf {S} _ {i, l} ^ {I}\\right), \\tag {3}\n$$\n\n$$\n\\mathbf {s} _ {i, l} ^ {\\text {m a x}} = \\max  - \\operatorname {p o o l i n g} \\left(\\mathbf {S} _ {i, l} ^ {I}\\right), \\tag {4}\n$$\n\nwhere  $\\mathbf{s}_{i,l}^{avg},\\mathbf{s}_{i,l}^{max}\\in \\mathbb{R}^d$  . Since the item embeddings have manipulated by the feature-level and instance-level gating modules, the\n\ninformative features and items have been selected and irrelevant ones have been eliminated. Thus, the average pooling will accumulate the informative parts in these embeddings. On the other hand, max-pooling directly selects the most representative features from each embedding to form the group-level representation.\n\n# 4.2 Item-item Product\n\nThe relation between two single items is an important factor to model in the recommendation task and has been widely studied in many years [17, 25], e.g., item-based collaborative filtering methods utilizing the rating vectors of two items to calculate the similarity. However, most of the recent works [12, 18, 34] only consider the sequential recommendation from the group-level, but do not explicitly capture the item-item relations between the items in  $L$  and the items user will interact in the future. Since strongly related item pairs will appear in  $L$  and  $T$  simultaneously. Unlike previous works, we apply the inner product between the input item embeddings and the output item embeddings to capture the item relations between  $L$  and  $T$ :\n\n$$\n\\sum_ {\\mathbf {e} _ {j} \\in \\mathbb {S} _ {i, l}} \\mathbf {e} _ {j} ^ {\\top} \\cdot \\mathbb {Q},\n$$\n\nwhere  $\\mathbf{Q} \\in \\mathbb{R}^{d \\times N}$  is the output item embeddings, the sum of multiplication results captures the accumulated item-item relation scores from each item in  $L$  to all other items.\n\n# 4.3 Prediction Layer\n\nAfter applying the hierarchical gating network to capture the short-term interests of users and item-item product to capture the relevant item pairs, we adopt the classical matrix factorization term to capture the global and long-time interests of users. Given the  $l$ -th subsequence to predict, the prediction score of user  $i$  on item  $j$  is:\n\n$$\n\\hat {r} _ {i, j} = \\mathbf {u} _ {i} ^ {\\top} \\cdot \\mathbf {q} _ {j} + \\mathbf {s} _ {i, l} ^ {a v g \\top} \\cdot \\mathbf {q} _ {j} + \\sum_ {\\mathbf {e} _ {k} \\in \\mathbb {S} _ {i, l}} \\mathbf {e} _ {k} ^ {\\top} \\cdot \\mathbf {q} _ {j}, \\tag {5}\n$$\n\nwhere  $\\mathbf{q}_j\\in \\mathbb{R}^d$  is the  $j$ -th column of the output item embedding  $\\mathbf{Q}$ . In the prediction layer, the first term captures the user long-term interests, the second term models the user short-term interests, and the third term reflects the relations between item pairs.\n\n# 4.4 Network Training\n\nAs the training data is from the user implicit feedback, we optimize the proposed model by the Bayesian Personalized Ranking objective [29]: optimizing the pairwise ranking between the positive and non-observing items:\n\n$$\n\\underset {\\mathrm {U}, \\mathrm {Q}, \\mathrm {E}, \\Theta} {\\arg \\min } \\sum_ {(i, L _ {i}, j, k) \\in \\mathcal {D}} - l o g \\sigma \\left(\\hat {r} _ {i, j} - \\hat {r} _ {i, k}\\right) + \\lambda \\left(\\left\\| \\mathbf {U} \\right\\| ^ {2} + \\left\\| \\mathbf {Q} \\right\\| ^ {2} + \\left\\| \\mathbf {E} \\right\\| ^ {2} + \\left\\| \\boldsymbol {\\Theta} \\right\\| ^ {2}\\right), \\tag {6}\n$$\n\nwhere  $L_{i}$  denotes one of the  $|L|$  successive items of user  $i$ ,  $j$  denotes the item that in  $T_{i}$ , and  $k$  denotes the randomly sampled negative item,  $\\Theta$  is the parameters in the gating network,  $\\lambda$  is the regularization parameter. By minimizing the objective function, the partial derivatives with respect to all the parameters can be computed by gradient descent with back-propagation. We apply Adam [19] to automatically adapt the learning rate during the learning procedure.\n\nTime complexity. The computational complexity of our model for each  $L$  is mainly due to the feature gating layer and item-item product module, which is  $O(|L|d^2 + |L|Nd)$  ( $|L|$  is the length of  $L$ ,  $d$  is the dimension of embeddings, and  $N$  is the number of items). This computational complexity makes our model scalable on large datasets. We empirically test the training speed with other state-of-the-art methods and find that our model is faster than other methods (section 5.7).",
  "experiments": "# 5 EXPERIMENTS\n\nIn this section, we evaluate the proposed model with the state-of-the-art methods on five real-world datasets<sup>1</sup>.\n\n# 5.1 Datasets\n\nThe proposed model is evaluated on five real-world datasets from various domains with different sparsities: MovieLens-20M [6], Amazon-Books and Amazon-CDs [9], Goodreads-Children and Goodreads-Comics [38]. MovieLens-20M is a user-movie dataset collected from the MovieLens website, where this dataset has 20 million user-movie interactions. The Amazon-Books and Amazon-CDs datasets are adopted from the Amazon review dataset<sup>2</sup> with different categories, i.e., CDs and Books, which cover a large amount of user-item interaction data, e.g., user ratings and reviews. Goodreads-Children and Goodreads-Comics datasets<sup>3</sup> are collected in late 2017 from goodreads website with different genres, and we use the genres of Children and Comics. In order to be consistent with the implicit feedback setting, we keep those with ratings no less than four (out of five) as positive feedback and treat all other ratings as missing entries on all datasets. To filter noisy data, we only keep the users with at least ten ratings and the items at least with five ratings. The data statistics after preprocessing are shown in Table 2.\n\nFor each user, we hold the  $70\\%$  of interactions in the user sequence as the training set and use the next  $10\\%$  of interactions as the validation set for hyper-parameter tuning. The remaining  $20\\%$  constitutes the test set for reporting model performance. Note that during the testing procedure, the input sequences include the interactions in both the training set and validation set. The execution of all the models is carried out five times independently, and we report the average results.\n\nTable 2: The statistics of datasets.  \n\n<table><tr><td>Dataset</td><td>#Users</td><td>#Items</td><td>#Interactions</td><td>Density</td></tr><tr><td>ML20M</td><td>129,797</td><td>13,649</td><td>9,921,393</td><td>0.560%</td></tr><tr><td>Books</td><td>52,406</td><td>41,264</td><td>1,856,747</td><td>0.086%</td></tr><tr><td>CDs</td><td>17,052</td><td>35,118</td><td>472,265</td><td>0.079%</td></tr><tr><td>Children</td><td>48,296</td><td>32,871</td><td>2,784,423</td><td>0.175%</td></tr><tr><td>Comics</td><td>34,445</td><td>33,121</td><td>2,411,314</td><td>0.211%</td></tr></table>\n\n# 5.2 Evaluation Metrics\n\nWe evaluate our model versus other methods in terms of  $Recall@k$  and  $NDCG@k$ . For each user,  $Recall@k$  ( $R@k$ ) indicates what percentage of her rated items can emerge in the top  $k$  recommended items.  $NDCG@k$  ( $N@k$ ) is the normalized discounted cumulative\n\ngain at  $k$ , which takes the position of correctly recommended items into account.\n\n# 5.3 Methods Studied\n\nTo demonstrate the effectiveness of our model, we compare to the following recommendation methods.\n\nClassical methods for implicit feedback:\n\n- BPRMF, the Bayesian Personalized Ranking based matrix factorization [29], which is a classic method for learning pairwise personalized rankings from user implicit feedback. Specifically, we use BPR-MF for model learning.\n\nState-of-the-art session-based recommendation methods:\n\n- GRU4Rec, gated recurrent unit for recommendation [13], which uses recurrent neural networks to model user-item interaction sequences for session-based recommendation. Each user sequence is treated as a session.  \n- GRU4Rec+, an improved version of GRU4Rec [12], which adopts a different loss function and sampling strategy, and shows significant performance gains on Top-N recommendation.  \n- NextItNet, the next item recommendation net [42], applies dilated convolutional neural networks to increase the receptive fields without relying on the pooling operation.\n\nState-of-the-art sequential recommendation methods:\n\n- Caser, convolutional sequence embedding model [34], which captures high-order Markov chains by applying convolution operations on the embeddings of the  $|L|$  recent items.  \n- SASRec, self-attention based sequential model [18], which uses an attention mechanism to identify relevant items for predicting the next item.\n\nThe proposed method:\n\n- HGN, the proposed model, applies a hierarchical gating network to learn the group-level representations of a sequence of items and adopts the item-item product to explicitly capture the item-item relations.\n\nGiven our extensive comparisons against the state-of-the-art methods, we omit comparisons with methods such as FMC and FPMC [30], Fossil [8], since they have been outperformed by the recently proposed Caser and SASRec.\n\n# 5.4 Experiment Settings\n\nIn the experiments, the latent dimension of all the models is set to 50. For those session-based methods, we treat each user sequence as one session. For GRU4Rec and GRU4Rec+, we find that when the learning rate is 0.001, and batch size is 50 can achieve good performance. These two methods adopt Top1 loss and BPR-max loss, respectively. For NextItNet, we following the original settings in the paper to set the learning rate to 0.001, the kernel size to 3, the dilated levels to 1 and 2, the batch size to 32. For Caser, we follow the settings in the author-provided code to set  $|L| = 5$ ,  $|T| = 3$ , the number of horizontal filters to 16, the number of vertical filters to 4, where Caser can achieve good results. For SASRec, we set the number of self-attention blocks to 2, the batch size to 128, and the maximum sequence length to 50. The network architectures of\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-16/d052713c-2701-4863-b95b-2b2315a4dc5c/c647fed2e94fbf24d102ba64353ef193263862b10e79caeb1866ede14f24d5bd.jpg)  \n(a) Recall@k on MovieLens-20M\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-16/d052713c-2701-4863-b95b-2b2315a4dc5c/2930e8fb30d013060027a5ead9fe1581de09cca30b7d5fad493e618ef783a6ac.jpg)  \n(b) NDCG@k on MovieLens-20M\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-16/d052713c-2701-4863-b95b-2b2315a4dc5c/eff8fbf24192a4b0b657fea5df4b5af5b40c92e1c5e3ec5bb624eae55c3286ab.jpg)  \nFigure 3: The performance comparison on MovieLens-20M.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-16/d052713c-2701-4863-b95b-2b2315a4dc5c/4158e6e4629f543dd53692973e31677a03918c7d3f06360b7e6d60c05c826af8.jpg)  \n(a) Recall@k on Amazon-Books  \n(b) NDCG@k on Amazon-Books\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-16/d052713c-2701-4863-b95b-2b2315a4dc5c/c385cfc4e7fbba5476f08e43bd4edf1dbcf36fa5bd09462fa1a717722d049802.jpg)  \nFigure 4: The performance comparison on Amazon-Books.  \n(a) Recall@k on Amazon-CDs  \nFigure 5: The performance comparison on Amazon-CDs.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-16/d052713c-2701-4863-b95b-2b2315a4dc5c/af71699a9c9a2aefb2b221e65167aac41ae73b74265a7c4b5eddc0cafeb47a86.jpg)  \n(b) NDCG@k on Amazon-CDs\n\nabove methods are also set the same with the original papers. The hyper-parameters are tuned using the validation set.\n\nFor HGN, we follow the same setting in Caser to set  $|L| = 5$  and  $|T| = 3$ , where the length effects are shown in the section 5.8. Hyper-parameters are tuned by grid search on the validation set. The network embedding size  $d$  is also set to 50. The learning learning rate and  $\\lambda$  are set to 0.001 and 0.001, respectively. The batch size is set to 4096. Our experiments are conducted with PyTorch<sup>4</sup> running on GPU machines (Nvidia GeForce GTX 1080 Ti).\n\n# 5.5 Performance Comparison\n\nThe performance comparison results are shown in Figure 3, 4, 5, 6, 7, and Table 3.\n\nObservations about our model. First, the proposed model—HGN, achieves the best performance on five datasets with all evaluation metrics, which illustrates the superiority of our model. Second, HGN achieves better performance than SASRec. The reasons are three-fold: (1) SASRec only applies the instance-level selection but neglecting the feature-level one, which plays an important role in learning short-term user interests (section 5.6); (2) SASRec adopts\n\nTable 3: The performance comparison of all methods in terms of  $Recall@10$  and  $NDCG@10$ . The best performing method is boldfaced. The underlined number is the second best performing method. *, **, *** indicate the statistical significance for  $p <= 0.05$ ,  $p <= 0.01$ , and  $p <= 0.001$ , respectively, compared to the best baseline method based on the paired t-test. Improv. denotes the improvement of our model over the best baseline method.  \n\n<table><tr><td></td><td>BPRMF</td><td>GRU4Rec</td><td>GRU4Rec+</td><td>NextItRec</td><td>Caser</td><td>SASRec</td><td>HGN</td><td>Improv.</td></tr><tr><td colspan=\"9\">Recall@10</td></tr><tr><td>MovieLens-20M</td><td>0.0774</td><td>0.0804</td><td>0.0904</td><td>0.0833</td><td>0.1169</td><td>0.1069</td><td>0.1255*</td><td>7.36%</td></tr><tr><td>Amazon-Books</td><td>0.0260</td><td>0.0266</td><td>0.0301</td><td>0.0303</td><td>0.0297</td><td>0.0358</td><td>0.0429***</td><td>19.83%</td></tr><tr><td>Amazon-CDs</td><td>0.0269</td><td>0.0302</td><td>0.0356</td><td>0.0310</td><td>0.0297</td><td>0.0341</td><td>0.0426**</td><td>19.66%</td></tr><tr><td>GoodReads-Children</td><td>0.0814</td><td>0.0857</td><td>0.0978</td><td>0.0879</td><td>0.1060</td><td>0.1165</td><td>0.1263*</td><td>8.41%</td></tr><tr><td>GooReads-Comics</td><td>0.0788</td><td>0.0958</td><td>0.1288</td><td>0.1078</td><td>0.1473</td><td>0.1494</td><td>0.1743***</td><td>16.67%</td></tr><tr><td colspan=\"9\">NDCG@10</td></tr><tr><td>MovieLens-20M</td><td>0.0785</td><td>0.0815</td><td>0.0946</td><td>0.0828</td><td>0.1116</td><td>0.1014</td><td>0.1195*</td><td>7.07%</td></tr><tr><td>Amazon-Books</td><td>0.0151</td><td>0.0157</td><td>0.0173</td><td>0.0174</td><td>0.0216</td><td>0.0240</td><td>0.0298***</td><td>24.17%</td></tr><tr><td>Amazon-CDs</td><td>0.0145</td><td>0.0154</td><td>0.0171</td><td>0.0155</td><td>0.0163</td><td>0.0193</td><td>0.0233**</td><td>20.73%</td></tr><tr><td>GoodReads-Children</td><td>0.0664</td><td>0.0715</td><td>0.0821</td><td>0.0720</td><td>0.0943</td><td>0.1007</td><td>0.1130*</td><td>12.21%</td></tr><tr><td>GoodReads-Comics</td><td>0.0713</td><td>0.0912</td><td>0.1328</td><td>0.1171</td><td>0.1629</td><td>0.1592</td><td>0.1927***</td><td>18.29%</td></tr></table>\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-16/d052713c-2701-4863-b95b-2b2315a4dc5c/b6792be876f6d5ff4856dcc3d4784dda441e12cb281e884f47467f138555e0f0.jpg)  \n(a) Recall@k on Children\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-16/d052713c-2701-4863-b95b-2b2315a4dc5c/4929e59dea3db25c5440651080da49d310dcde959195e21df354bc9f279a7352.jpg)  \n(b) NDCG@k on Children\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-16/d052713c-2701-4863-b95b-2b2315a4dc5c/9c41a61fe400d74651c66da05def91977575f8ca05e4ad18c8f0415d0d4f21cb.jpg)  \nFigure 6: The performance comparison on Children.  \n(a) Recall@k on Comics  \nFigure 7: The performance comparison on Comics.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-16/d052713c-2701-4863-b95b-2b2315a4dc5c/291d545f51069d515698338deaaafd9e8e3b19eeef2d2a69a7949029629a0016.jpg)  \n(b) NDCG@k on Comics\n\na hyper-parameter—the maximum sequence length to reduce the computation burden, where only using part of the user data may lead to the insufficient understanding of long-term user interests; (3) SASRec does not explicitly model the item-item relations between two closely relevant items, which is captured by our item-item product module. Third, HGN outperforms Caser, one major reason is that Caser only applies CNNs to learn the group-level representation of several successive items without considering the item importance for different users. Fourth, HGN obtains better results than GRU4Rec, GRU4Rec+, and NextItNet. Two possible reasons are: (1) these models are session-based methods without explicitly modeling the long-term user interests; (2) these methods equally treat all the items in a short context, which may fail to capture the short-term user intentions. Fifth, HGN outperforms BPRMF. Since BPRMF only captures the long-term interests of users, which does not incorporate the sequential patterns of user-item interactions.\n\nOn the top of BPRMF, HGN adopts a hierarchical gating network to capture the sequential dynamics in the user actions and an item-item product module to explicitly capture the item-item relations, which leads to better performance.\n\nOther observations. First, all the results reported on MovieLens20M, GoodReads-Children and GoodReads-Comics are better than the results on other datasets, the major reason is that other datasets are more sparse and the data sparsity declines the recommendation performance. Second, SASRec outperforms Caser on most of the datasets. The main reason is that SASRec adaptively attends items that would reflect the short-term user interests. Third, SASRec and Caser achieve better performance than GRU4Rec, GRU4Rec+, and NextItNet in most cases. One possible reason is that SASRec and Caser both explicitly plug the user embeddings in their models, which allows the long-term user interests modeling. Fourth, GRU4Rec+ performs better than other methods on one dataset. The reason is that GRU4Rec+ not only captures the sequential patterns in the user-item sequence but also has a promising object function-BPR-max. Fifth, all the methods perform better than BPR. This illustrates that only effectively modeling the long-term user interests is not sufficient to capture the user sequential behaviors.\n\nTable 4: The ablation analysis on GoodReads-Comics and Amazon-Books datasets.  $F$  denotes the feature gating module,  $I$  denotes the instance gating module,  $avg$  denotes the average pooling, and max denotes the max pooling.  \n\n<table><tr><td rowspan=\"2\">Architecture</td><td colspan=\"2\">Comics</td><td colspan=\"2\">Books</td></tr><tr><td>R@10</td><td>N@10</td><td>R@10</td><td>N@10</td></tr><tr><td>(1) BPR</td><td>0.0911</td><td>0.0802</td><td>0.0310</td><td>0.0177</td></tr><tr><td>(2) BPR+F+avg</td><td>0.1555</td><td>0.1624</td><td>0.0361</td><td>0.0266</td></tr><tr><td>(3) BPR+F+max</td><td>0.1456</td><td>0.1550</td><td>0.0355</td><td>0.0240</td></tr><tr><td>(4) BPR+I+avg</td><td>0.1538</td><td>0.1591</td><td>0.0351</td><td>0.0254</td></tr><tr><td>(5) BPR+I+max</td><td>0.1489</td><td>0.1585</td><td>0.0329</td><td>0.0241</td></tr><tr><td>(6) BPR+GRU</td><td>0.1456</td><td>0.1581</td><td>0.0289</td><td>0.0216</td></tr><tr><td>(7) BPR+CNN</td><td>0.1305</td><td>0.1387</td><td>0.0278</td><td>0.0207</td></tr><tr><td>(8) BPR+F+I+avg</td><td>0.1635</td><td>0.1791</td><td>0.0391</td><td>0.0250</td></tr><tr><td>(9) BPR+F+I+max</td><td>0.1569</td><td>0.1658</td><td>0.0355</td><td>0.0234</td></tr><tr><td>(10) HGN</td><td>0.1743</td><td>0.1927</td><td>0.0429</td><td>0.0298</td></tr></table>\n\n# 5.6 Ablation Analysis\n\nTo verify the effectiveness of the proposed feature gating, instance gating, and item-item product modules, we conduct an ablation analysis in Table 4 to demonstrate the importance each module contributes to the HGN model. In (1), we utilize only the BPR matrix factorization without any other components. In (2), we only incorporate the feature gating and apply the average pooling on the embeddings after the feature gating, on the top of (1). In (3), we replace the average pooling in (2) with max pooling. In (4), we only include the instance gating and apply the average pooling on the top of (1). In (5), we replace the average pooling in (4) with max-pooling. In (6), we adopt a recurrent neural network structure—gated recurrent unit (GRU) [3] to learn the group-level representations of items. In (7), we replace the GRU in (6) with a convolutional neural network (CNN), where the structure and hyper-parameters are set the same in Caser [34]. In (8), we both apply the feature and instance gating with average pooling. In (9), we replace the average pooling with max pooling. In (10), we present the overall HGN model to show the significance of the item-item product module.\n\nFrom the results shown in Table 4, we have some observations. First, from (1) and all others, we can observe that the conventional BPR matrix factorization to capture the long-term user interests cannot effectively model the short-term user interests. Second, from (2), (3), (4) and (5), the feature gating seems to achieve slightly better results than the instance gating. And the average pooling is slightly better than the max pooling, one possible reason is that the average pooling makes the representative item features accumulated, which results in a more effective representation of a group of  $|L|$  successive items. Third, from (6), (7), and (8), we observe that our hierarchical gating network achieves better performance than GRU and CNN but with fewer learnable parameters<sup>5</sup> (if we set the item embedding size to 50 ( $d = 50$ ), then the number of learnable parameters of our hierarchical gating network is 5,350, the number of parameters of the one-recurrent-layer GRU is 15,300, the number of parameters of the CNN in [34] is 26,154). This result demonstrates that the proposed hierarchical gating network can effectively capture the sequential patterns in the user-item interaction sequence. Lastly, from (1), (8), and (9), we observe that by incorporating the item-item product, the performance further improves. The results demonstrate that explicitly capturing the relations between the items users accessed and those items users may interact in the future can provide a significant supplementary to model the user sequential dynamics.\n\n# 5.7 Training Efficiency\n\nIn this section, we evaluate the training efficiency with other state-of-the-art methods in terms of the training speed (time taken for one epoch of training). Since GRU4Rec+ has been compared with SASRec in [18], we omit the training time comparison with GRU4Rec+. To make a fair comparison, we set the max sequence length of SASRec as 300 to cover more than  $95\\%$  of the sequence. All the experiments are conducted on a single GPU of Nvidia GeForce GTX 1080 Ti. All the compared methods are executed 20 epochs and we report the average computation time, which is shown in Table\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-16/d052713c-2701-4863-b95b-2b2315a4dc5c/286a8ce481c7a5f4f97be543febd9e2f4a4bd6d095c1edac2424ba4895c8e3b1.jpg)  \n(a)  $d$  on Children\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-12-16/d052713c-2701-4863-b95b-2b2315a4dc5c/70a5d222aad55a79b065f35c2ab16e36cd1b8d4d91978e6c47f78f0eb4736fd7.jpg)  \n(b)  $d$  on Comics  \nFigure 8: The dimension variations of embeddings.\n\n5. Note that the time reported only includes the training time of models without including the negative sampling time.\n\nTable 5: The training time per epoch comparison on five datasets in terms of seconds.  \n\n<table><tr><td></td><td>CDs</td><td>Books</td><td>ML20M</td><td>Children</td><td>Comics</td></tr><tr><td>HGN</td><td>0.957s</td><td>2.086s</td><td>28.304s</td><td>3.496s</td><td>2.228s</td></tr><tr><td>SASRec</td><td>2.242s</td><td>16.154s</td><td>39.937s</td><td>14.913s</td><td>10.468s</td></tr><tr><td>Caser</td><td>5.063s</td><td>17.577s</td><td>63.702s</td><td>28.593s</td><td>25.657s</td></tr></table>\n\nFrom the results in Table 5, we can observe that HGN yields the fastest training speed on all datasets. As we have discussed in section 4.4, our model has less item complexity than SASRec, which is  $O(N^2 d + Nd^2)$ . Thus, our proposed model has better training efficiency both theoretically and practically.\n\nTable 6: The effect of the length  $\\left| L\\right|$  and  $\\left| T\\right|$  .  \n\n<table><tr><td rowspan=\"2\">Settings</td><td colspan=\"2\">CDs</td><td colspan=\"2\">Comics</td></tr><tr><td>R@5</td><td>R@10</td><td>R@5</td><td>R@10</td></tr><tr><td>|L|=3, |T|=1</td><td>0.0260</td><td>0.0415</td><td>0.1202</td><td>0.1684</td></tr><tr><td>|L|=3, |T|=2</td><td>0.0291</td><td>0.0448</td><td>0.1275</td><td>0.1758</td></tr><tr><td>|L|=3, |T|=3</td><td>0.0289</td><td>0.0450</td><td>0.1296</td><td>0.1793</td></tr><tr><td>|L|=5, |T|=1</td><td>0.0254</td><td>0.0417</td><td>0.1155</td><td>0.1645</td></tr><tr><td>|L|=5, |T|=2</td><td>0.0261</td><td>0.0432</td><td>0.1215</td><td>0.1711</td></tr><tr><td>|L|=5, |T|=3</td><td>0.0290</td><td>0.0456</td><td>0.1238</td><td>0.1738</td></tr><tr><td>|L|=8, |T|=1</td><td>0.0220</td><td>0.0372</td><td>0.1083</td><td>0.1566</td></tr><tr><td>|L|=8, |T|=2</td><td>0.0248</td><td>0.0401</td><td>0.1142</td><td>0.1636</td></tr><tr><td>|L|=8, |T|=3</td><td>0.0260</td><td>0.0413</td><td>0.1160</td><td>0.1658</td></tr></table>\n\n# 5.8 The Sensitivity of Hyper-parameters\n\nWe present the effect of two hyper-parameters: the dimension of the item embeddings  $d$  and the length of successive items  $|L|$  and  $|T|$ . The effects of these two parameters are shown in Figure 8 and Table 6. Due to the space limit, we only present the effects on two datasets, the parameter effects on other datasets have similar trends.\n\nThe variation of  $d$  is shown in Figure 8. We can observe that a small dimension of item embeddings is not sufficient to express the latent features of items. By increasing the dimension of item embeddings, the model has more capacity to model the complex features of items. With the increase of  $d$ , the model performance largely improves and becomes steady.\n\nThe variation of  $|L|$  and  $|T|$  is shown in Table 6. We observe that when  $|L|$  is fixed, a larger value of  $|T|$ , i.e. 3, can achieve better performance. This may illustrate that a group of  $|L|$  items may\n\ndetermine several items that user will interact in the near future. We also observe that smaller  $|L|$  has better results than larger ones. One possible reason is that larger  $|L|$  may include too many irrelevant items for predicting future items.",
  "hyperparameter": "Embedding dimension d=50; Sequence length |L|=5 (number of input items); Target length |T|=3 (number of items to predict); Learning rate=0.001; Regularization parameter λ=0.001; Batch size=4096; Number of horizontal filters (for Caser baseline)=16; Number of vertical filters (for Caser baseline)=4; Number of self-attention blocks (for SASRec baseline)=2; Maximum sequence length (for SASRec baseline)=50"
}